{
  "repo": "https://github.com/modelcontextprotocol/python-sdk.git",
  "analysis_time": "2025-11-19T21:48:49.708370",
  "transport": {
    "type": "http",
    "confidence": 1.0,
    "evidence": [
      "HTTP pattern in .gitignore",
      "HTTP pattern in CODE_OF_CONDUCT.md",
      "HTTP pattern in LICENSE",
      "HTTP pattern in pyproject.toml",
      "WS pattern in pyproject.toml",
      "WS pattern in uv.lock",
      "WS pattern in .git\\index",
      "HTTP pattern in .git\\hooks\\fsmonitor-watchman.sample",
      "WS pattern in .git\\objects\\pack\\pack-3699aab3c7d49e521747555e7bcf95fa0137bea6.pack",
      "CLI pattern in scripts\\update_readme_snippets.py",
      "HTTP pattern in src\\mcp\\types.py",
      "SSE pattern in src\\mcp\\client\\streamable_http.py",
      "WS pattern in src\\mcp\\client\\websocket.py",
      "CLI pattern in src\\mcp\\client\\__main__.py",
      "SSE pattern in src\\mcp\\server\\sse.py",
      "CLI pattern in src\\mcp\\server\\stdio.py",
      "SSE pattern in src\\mcp\\server\\streamable_http.py",
      "WS pattern in src\\mcp\\server\\websocket.py",
      "HTTP pattern in src\\mcp\\server\\fastmcp\\server.py",
      "HTTP pattern in src\\mcp\\server\\fastmcp\\utilities\\func_metadata.py",
      "CLI pattern in tests\\client\\test_stdio.py",
      "CLI pattern in tests\\issues\\test_552_windows_hang.py",
      "SSE pattern in tests\\server\\test_streamable_http_manager.py",
      "SSE pattern in tests\\server\\test_streamable_http_security.py",
      "SSE pattern in tests\\shared\\test_sse.py",
      "SSE pattern in tests\\shared\\test_streamable_http.py",
      "WS pattern in tests\\shared\\test_ws.py"
    ]
  },
  "tools": [
    {
      "name": "cli",
      "description": "make an HTTP request to an external API. Function `cli`.",
      "predicted_filename": "examples\\clients\\simple-auth-client\\mcp_simple_auth_client\\main.py",
      "predicted_code_snippet": "def cli():\n    \"\"\"CLI entry point for uv script.\"\"\"\n    asyncio.run(main())",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `cli` in examples\\clients\\simple-auth-client\\mcp_simple_auth_client\\main.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        },
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.28,
      "evidence": [
        "function cli in examples\\clients\\simple-auth-client\\mcp_simple_auth_client\\main.py",
        "matched template: make an HTTP request to an external API (sim=0.36)"
      ]
    },
    {
      "name": "main",
      "description": "make an HTTP request to an external API. Function `main`.",
      "predicted_filename": "examples\\clients\\simple-chatbot\\mcp_simple_chatbot\\main.py",
      "predicted_code_snippet": "def main() -> None:\n    asyncio.run(run())",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `main` in examples\\clients\\simple-chatbot\\mcp_simple_chatbot\\main.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.18,
      "evidence": [
        "function main in examples\\clients\\simple-chatbot\\mcp_simple_chatbot\\main.py",
        "matched template: make an HTTP request to an external API (sim=0.17)"
      ]
    },
    {
      "name": "name_shrimp",
      "description": "validate and sanitize user input. Function `name_shrimp`.",
      "predicted_filename": "examples\\fastmcp\\complex_inputs.py",
      "predicted_code_snippet": "def name_shrimp(\n    tank: ShrimpTank,\n    # You can use pydantic Field in function signatures for validation.\n    extra_names: Annotated[list[str], Field(max_length=10)],\n) -> list[str]:\n    \"\"\"List all shrimp names in the tank\"\"\"\n    return [shrimp.name for shrimp in tank.shrimp] + extra_names",
      "input_schema": {
        "type": "object",
        "properties": {
          "tank": {
            "type": "string",
            "required": true
          },
          "extra_names": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "tank",
          "extra_names"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "tank": "string",
          "extra_names": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `name_shrimp` in examples\\fastmcp\\complex_inputs.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function name_shrimp in examples\\fastmcp\\complex_inputs.py",
        "matched template: validate and sanitize user input (sim=0.25)"
      ]
    },
    {
      "name": "desktop",
      "description": "list files in a directory. Function `desktop`.",
      "predicted_filename": "examples\\fastmcp\\desktop.py",
      "predicted_code_snippet": "def desktop() -> list[str]:\n    \"\"\"List the files in the user's desktop\"\"\"\n    desktop = Path.home() / \"Desktop\"\n    return [str(f) for f in desktop.iterdir()]",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `desktop` in examples\\fastmcp\\desktop.py",
      "possible_syscalls": [],
      "confidence": 0.35,
      "evidence": [
        "function desktop in examples\\fastmcp\\desktop.py",
        "matched template: list files in a directory (sim=0.45)"
      ]
    },
    {
      "name": "sum",
      "description": "list files in a directory. Function `sum`.",
      "predicted_filename": "examples\\fastmcp\\desktop.py",
      "predicted_code_snippet": "def sum(a: int, b: int) -> int:\n    \"\"\"Add two numbers\"\"\"\n    return a + b",
      "input_schema": {
        "type": "object",
        "properties": {
          "a": {
            "type": "integer",
            "required": true
          },
          "b": {
            "type": "integer",
            "required": true
          }
        },
        "required": [
          "a",
          "b"
        ]
      },
      "output_schema": {
        "type": "integer"
      },
      "payload_shape": {
        "request": {
          "a": "integer",
          "b": "integer"
        },
        "response": {
          "type": "integer"
        }
      },
      "explanation": "Detected Python function `sum` in examples\\fastmcp\\desktop.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function sum in examples\\fastmcp\\desktop.py",
        "matched template: list files in a directory (sim=0.28)"
      ]
    },
    {
      "name": "echo",
      "description": "write data to a file. Function `echo`.",
      "predicted_filename": "examples\\fastmcp\\direct_call_tool_result_return.py",
      "predicted_code_snippet": "def echo(text: str) -> Annotated[CallToolResult, EchoResponse]:\n    \"\"\"Echo the input text with structure and metadata\"\"\"\n    return CallToolResult(\n        content=[TextContent(type=\"text\", text=text)], structuredContent={\"text\": text}, _meta={\"some\": \"metadata\"}\n    )",
      "input_schema": {
        "type": "object",
        "properties": {
          "text": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "text"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "text": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `echo` in examples\\fastmcp\\direct_call_tool_result_return.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function echo in examples\\fastmcp\\direct_call_tool_result_return.py",
        "matched template: write data to a file (sim=0.27)"
      ]
    },
    {
      "name": "echo_tool",
      "description": "execute a shell command. Function `echo_tool`.",
      "predicted_filename": "examples\\fastmcp\\echo.py",
      "predicted_code_snippet": "def echo_tool(text: str) -> str:\n    \"\"\"Echo the input text\"\"\"\n    return text",
      "input_schema": {
        "type": "object",
        "properties": {
          "text": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "text"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "text": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `echo_tool` in examples\\fastmcp\\echo.py",
      "possible_syscalls": [],
      "confidence": 0.24,
      "evidence": [
        "function echo_tool in examples\\fastmcp\\echo.py",
        "matched template: execute a shell command (sim=0.29)"
      ]
    },
    {
      "name": "echo_resource",
      "description": "execute a shell command. Function `echo_resource`.",
      "predicted_filename": "examples\\fastmcp\\echo.py",
      "predicted_code_snippet": "def echo_resource() -> str:\n    return \"Echo!\"",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `echo_resource` in examples\\fastmcp\\echo.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function echo_resource in examples\\fastmcp\\echo.py",
        "matched template: execute a shell command (sim=0.27)"
      ]
    },
    {
      "name": "echo_template",
      "description": "execute a shell command. Function `echo_template`.",
      "predicted_filename": "examples\\fastmcp\\echo.py",
      "predicted_code_snippet": "def echo_template(text: str) -> str:\n    \"\"\"Echo the input text\"\"\"\n    return f\"Echo: {text}\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "text": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "text"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "text": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `echo_template` in examples\\fastmcp\\echo.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function echo_template in examples\\fastmcp\\echo.py",
        "matched template: execute a shell command (sim=0.27)"
      ]
    },
    {
      "name": "echo_prompt",
      "description": "execute a shell command. Function `echo_prompt`.",
      "predicted_filename": "examples\\fastmcp\\echo.py",
      "predicted_code_snippet": "def echo_prompt(text: str) -> str:\n    return text",
      "input_schema": {
        "type": "object",
        "properties": {
          "text": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "text"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "text": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `echo_prompt` in examples\\fastmcp\\echo.py",
      "possible_syscalls": [],
      "confidence": 0.24,
      "evidence": [
        "function echo_prompt in examples\\fastmcp\\echo.py",
        "matched template: execute a shell command (sim=0.29)"
      ]
    },
    {
      "name": "demo_tool",
      "description": "process image data (resize, crop, convert). Function `demo_tool`.",
      "predicted_filename": "examples\\fastmcp\\icons_demo.py",
      "predicted_code_snippet": "def demo_tool(message: str) -> str:\n    \"\"\"A demo tool with an icon.\"\"\"\n    return message",
      "input_schema": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "message"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "message": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `demo_tool` in examples\\fastmcp\\icons_demo.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function demo_tool in examples\\fastmcp\\icons_demo.py",
        "matched template: process image data (resize, crop, convert) (sim=0.23)"
      ]
    },
    {
      "name": "readme_resource",
      "description": "process image data (resize, crop, convert). Function `readme_resource`.",
      "predicted_filename": "examples\\fastmcp\\icons_demo.py",
      "predicted_code_snippet": "def readme_resource() -> str:\n    \"\"\"A demo resource with an icon\"\"\"\n    return \"This resource has an icon\"",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `readme_resource` in examples\\fastmcp\\icons_demo.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function readme_resource in examples\\fastmcp\\icons_demo.py",
        "matched template: process image data (resize, crop, convert) (sim=0.24)"
      ]
    },
    {
      "name": "prompt_with_icon",
      "description": "process image data (resize, crop, convert). Function `prompt_with_icon`.",
      "predicted_filename": "examples\\fastmcp\\icons_demo.py",
      "predicted_code_snippet": "def prompt_with_icon(text: str) -> str:\n    \"\"\"A demo prompt with an icon\"\"\"\n    return text",
      "input_schema": {
        "type": "object",
        "properties": {
          "text": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "text"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "text": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `prompt_with_icon` in examples\\fastmcp\\icons_demo.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function prompt_with_icon in examples\\fastmcp\\icons_demo.py",
        "matched template: process image data (resize, crop, convert) (sim=0.20)"
      ]
    },
    {
      "name": "multi_icon_tool",
      "description": "process image data (resize, crop, convert). Function `multi_icon_tool`.",
      "predicted_filename": "examples\\fastmcp\\icons_demo.py",
      "predicted_code_snippet": "def multi_icon_tool(action: str) -> str:\n    \"\"\"A tool demonstrating multiple icons.\"\"\"\n    return \"multi_icon_tool\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "action": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "action"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "action": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `multi_icon_tool` in examples\\fastmcp\\icons_demo.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function multi_icon_tool in examples\\fastmcp\\icons_demo.py",
        "matched template: process image data (resize, crop, convert) (sim=0.21)"
      ]
    },
    {
      "name": "cosine_similarity",
      "description": "cache results to disk or memory. Function `cosine_similarity`.",
      "predicted_filename": "examples\\fastmcp\\memory.py",
      "predicted_code_snippet": "def cosine_similarity(a: list[float], b: list[float]) -> float:\n    a_array = np.array(a, dtype=np.float64)\n    b_array = np.array(b, dtype=np.float64)\n    return np.dot(a_array, b_array) / (np.linalg.norm(a_array) * np.linalg.norm(b_array))",
      "input_schema": {
        "type": "object",
        "properties": {
          "a": {
            "type": "number",
            "required": true
          },
          "b": {
            "type": "number",
            "required": true
          }
        },
        "required": [
          "a",
          "b"
        ]
      },
      "output_schema": {
        "type": "number"
      },
      "payload_shape": {
        "request": {
          "a": "number",
          "b": "number"
        },
        "response": {
          "type": "number"
        }
      },
      "explanation": "Detected Python function `cosine_similarity` in examples\\fastmcp\\memory.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function cosine_similarity in examples\\fastmcp\\memory.py",
        "matched template: cache results to disk or memory (sim=0.19)"
      ]
    },
    {
      "name": "greet_user",
      "description": "perform database query and return records. Function `greet_user`.",
      "predicted_filename": "examples\\fastmcp\\parameter_descriptions.py",
      "predicted_code_snippet": "def greet_user(\n    name: str = Field(description=\"The name of the person to greet\"),\n    title: str = Field(description=\"Optional title like Mr/Ms/Dr\", default=\"\"),\n    times: int = Field(description=\"Number of times to repeat the greeting\", default=1),\n) -> str:\n    \"\"\"Greet a user with optional title and repetition\"\"\"\n    greeting = f\"Hello {title + ' ' if title else ''}{name}!\"\n    return \"\\n\".join([greeting] * times)",
      "input_schema": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "required": false
          },
          "title": {
            "type": "string",
            "required": false
          },
          "times": {
            "type": "integer",
            "required": false
          }
        },
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "name": "string",
          "title": "string",
          "times": "integer"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `greet_user` in examples\\fastmcp\\parameter_descriptions.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function greet_user in examples\\fastmcp\\parameter_descriptions.py",
        "matched template: perform database query and return records (sim=0.20)"
      ]
    },
    {
      "name": "sum",
      "description": "compute statistics (mean, median, stddev) on numeric data. Function `sum`.",
      "predicted_filename": "examples\\fastmcp\\readme-quickstart.py",
      "predicted_code_snippet": "def sum(a: int, b: int) -> int:\n    \"\"\"Add two numbers\"\"\"\n    return a + b",
      "input_schema": {
        "type": "object",
        "properties": {
          "a": {
            "type": "integer",
            "required": true
          },
          "b": {
            "type": "integer",
            "required": true
          }
        },
        "required": [
          "a",
          "b"
        ]
      },
      "output_schema": {
        "type": "integer"
      },
      "payload_shape": {
        "request": {
          "a": "integer",
          "b": "integer"
        },
        "response": {
          "type": "integer"
        }
      },
      "explanation": "Detected Python function `sum` in examples\\fastmcp\\readme-quickstart.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function sum in examples\\fastmcp\\readme-quickstart.py",
        "matched template: compute statistics (mean, median, stddev) on numeric data (sim=0.18)"
      ]
    },
    {
      "name": "get_greeting",
      "description": "compute cryptographic hash of input data. Function `get_greeting`.",
      "predicted_filename": "examples\\fastmcp\\readme-quickstart.py",
      "predicted_code_snippet": "def get_greeting(name: str) -> str:\n    \"\"\"Get a personalized greeting\"\"\"\n    return f\"Hello, {name}!\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "name"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "name": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `get_greeting` in examples\\fastmcp\\readme-quickstart.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function get_greeting in examples\\fastmcp\\readme-quickstart.py",
        "matched template: compute cryptographic hash of input data (sim=0.14)"
      ]
    },
    {
      "name": "take_screenshot",
      "description": "process image data (resize, crop, convert). Function `take_screenshot`.",
      "predicted_filename": "examples\\fastmcp\\screenshot.py",
      "predicted_code_snippet": "def take_screenshot() -> Image:\n    \"\"\"\n    Take a screenshot of the user's screen and return it as an image. Use\n    this tool anytime the user wants you to look at something they're doing.\n    \"\"\"\n    import pyautogui\n\n    buffer = io.BytesIO()\n\n    # if the file exceeds ~1MB, it will be rejected by Claude\n    screenshot = pyautogui.screenshot()\n    screenshot.convert(\"RGB\").save(buffer, format=\"JPEG\", quality=60, optimize=True)\n    return Image(data=buffer.getvalue(), format=\"jpeg\")",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `take_screenshot` in examples\\fastmcp\\screenshot.py",
      "possible_syscalls": [],
      "confidence": 0.29,
      "evidence": [
        "function take_screenshot in examples\\fastmcp\\screenshot.py",
        "matched template: process image data (resize, crop, convert) (sim=0.37)"
      ]
    },
    {
      "name": "echo",
      "description": "write data to a file. Function `echo`.",
      "predicted_filename": "examples\\fastmcp\\simple_echo.py",
      "predicted_code_snippet": "def echo(text: str) -> str:\n    \"\"\"Echo the input text\"\"\"\n    return text",
      "input_schema": {
        "type": "object",
        "properties": {
          "text": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "text"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "text": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `echo` in examples\\fastmcp\\simple_echo.py",
      "possible_syscalls": [],
      "confidence": 0.24,
      "evidence": [
        "function echo in examples\\fastmcp\\simple_echo.py",
        "matched template: write data to a file (sim=0.28)"
      ]
    },
    {
      "name": "text_me",
      "description": "stream data over websocket. Function `text_me`.",
      "predicted_filename": "examples\\fastmcp\\text_me.py",
      "predicted_code_snippet": "def text_me(text_content: str) -> str:\n    \"\"\"Send a text message to a phone number via https://surgemsg.com/\"\"\"\n    with httpx.Client() as client:\n        response = client.post(\n            \"https://api.surgemsg.com/messages\",\n            headers={\n                \"Authorization\": f\"Bearer {surge_settings.api_key}\",\n                \"Surge-Account\": surge_settings.account_id,\n                \"Content-Type\": \"application/json\",\n            },\n            json={\n                \"body\": text_content,\n                \"conversation\": {\n                    \"contact\": {\n                        \"first_name\": surge_settings.my_first_name,\n                        \"last_name\": surge_settings.my_last_name,\n                        \"phone_number\": surge_settings.my_phone_number,\n                    }\n                },\n            },\n        )\n        response.raise_for_status()\n        return f\"Message sent: {text_content}\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "text_content": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "text_content"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "text_content": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `text_me` in examples\\fastmcp\\text_me.py",
      "possible_syscalls": [],
      "confidence": 0.28,
      "evidence": [
        "function text_me in examples\\fastmcp\\text_me.py",
        "matched template: stream data over websocket (sim=0.35)"
      ]
    },
    {
      "name": "hello_unicode",
      "description": "validate and sanitize user input. Function `hello_unicode`.",
      "predicted_filename": "examples\\fastmcp\\unicode_example.py",
      "predicted_code_snippet": "def hello_unicode(name: str = \"\u4e16\u754c\", greeting: str = \"\u00a1Hola\") -> str:\n    \"\"\"\n    A simple tool that demonstrates Unicode handling in:\n    - Tool description (emojis, accents, CJK characters)\n    - Parameter defaults (CJK characters)\n    - Return values (Spanish punctuation, emojis)\n    \"\"\"\n    return f\"{greeting}, {name}! \ud83d\udc4b\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "required": false
          },
          "greeting": {
            "type": "string",
            "required": false
          }
        },
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "name": "string",
          "greeting": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `hello_unicode` in examples\\fastmcp\\unicode_example.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function hello_unicode in examples\\fastmcp\\unicode_example.py",
        "matched template: validate and sanitize user input (sim=0.21)"
      ]
    },
    {
      "name": "list_emoji_categories",
      "description": "validate and sanitize user input. Function `list_emoji_categories`.",
      "predicted_filename": "examples\\fastmcp\\unicode_example.py",
      "predicted_code_snippet": "def list_emoji_categories() -> list[str]:\n    \"\"\"Returns a list of emoji categories with emoji examples.\"\"\"\n    return [\n        \"\ud83d\ude00 Smileys & Emotion\",\n        \"\ud83d\udc4b People & Body\",\n        \"\ud83d\udc36 Animals & Nature\",\n        \"\ud83c\udf4e Food & Drink\",\n        \"\u26bd Activities\",\n        \"\ud83c\udf0d Travel & Places\",\n        \"\ud83d\udca1 Objects\",\n        \"\u2764\ufe0f Symbols\",\n        \"\ud83d\udea9 Flags\",\n    ]",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `list_emoji_categories` in examples\\fastmcp\\unicode_example.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function list_emoji_categories in examples\\fastmcp\\unicode_example.py",
        "matched template: validate and sanitize user input (sim=0.15)"
      ]
    },
    {
      "name": "multilingual_hello",
      "description": "validate and sanitize user input. Function `multilingual_hello`.",
      "predicted_filename": "examples\\fastmcp\\unicode_example.py",
      "predicted_code_snippet": "def multilingual_hello() -> str:\n    \"\"\"Returns hello in different scripts and writing systems.\"\"\"\n    return \"\\n\".join(\n        [\n            \"English: Hello!\",\n            \"Spanish: \u00a1Hola!\",\n            \"French: Bonjour!\",\n            \"German: Gr\u00fc\u00df Gott!\",\n            \"Russian: \u041f\u0440\u0438\u0432\u0435\u0442!\",\n            \"Greek: \u0393\u03b5\u03b9\u03b1 \u03c3\u03b1\u03c2!\",\n            \"Hebrew: !\u05e9\u05b8\u05c1\u05dc\u05d5\u05b9\u05dd\",\n            \"Arabic: !\u0645\u0631\u062d\u0628\u0627\",\n            \"Hindi: \u0928\u092e\u0938\u094d\u0924\u0947!\",\n            \"Chinese: \u4f60\u597d!\",\n            \"Japanese: \u3053\u3093\u306b\u3061\u306f!\",\n            \"Korean: \uc548\ub155\ud558\uc138\uc694!\",\n            \"Thai: \u0e2a\u0e27\u0e31\u0e2a\u0e14\u0e35!\",\n        ]\n    )",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `multilingual_hello` in examples\\fastmcp\\unicode_example.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function multilingual_hello in examples\\fastmcp\\unicode_example.py",
        "matched template: validate and sanitize user input (sim=0.16)"
      ]
    },
    {
      "name": "get_weather",
      "description": "parse JSON input and validate fields. Function `get_weather`.",
      "predicted_filename": "examples\\fastmcp\\weather_structured.py",
      "predicted_code_snippet": "def get_weather(city: str) -> WeatherData:\n    \"\"\"Get current weather for a city with full structured data\"\"\"\n    # In a real implementation, this would fetch from a weather API\n    return WeatherData(temperature=22.5, humidity=65.0, condition=\"partly cloudy\", wind_speed=12.3, location=city)",
      "input_schema": {
        "type": "object",
        "properties": {
          "city": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "city"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "city": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `get_weather` in examples\\fastmcp\\weather_structured.py",
      "possible_syscalls": [],
      "confidence": 0.25,
      "evidence": [
        "function get_weather in examples\\fastmcp\\weather_structured.py",
        "matched template: parse JSON input and validate fields (sim=0.31)"
      ]
    },
    {
      "name": "get_weather_summary",
      "description": "write data to a file. Function `get_weather_summary`.",
      "predicted_filename": "examples\\fastmcp\\weather_structured.py",
      "predicted_code_snippet": "def get_weather_summary(city: str) -> WeatherSummary:\n    \"\"\"Get a brief weather summary for a city\"\"\"\n    return WeatherSummary(city=city, temp_c=22.5, description=\"Partly cloudy with light breeze\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "city": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "city"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "city": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `get_weather_summary` in examples\\fastmcp\\weather_structured.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function get_weather_summary in examples\\fastmcp\\weather_structured.py",
        "matched template: write data to a file (sim=0.26)"
      ]
    },
    {
      "name": "get_weather_metrics",
      "description": "parse JSON input and validate fields. Function `get_weather_metrics`.",
      "predicted_filename": "examples\\fastmcp\\weather_structured.py",
      "predicted_code_snippet": "def get_weather_metrics(cities: list[str]) -> dict[str, dict[str, float]]:\n    \"\"\"Get weather metrics for multiple cities\n\n    Returns a dictionary mapping city names to their metrics\n    \"\"\"\n    # Returns nested dictionaries with weather metrics\n    return {\n        city: {\"temperature\": 20.0 + i * 2, \"humidity\": 60.0 + i * 5, \"pressure\": 1013.0 + i * 0.5}\n        for i, city in enumerate(cities)\n    }",
      "input_schema": {
        "type": "object",
        "properties": {
          "cities": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "cities"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "cities": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `get_weather_metrics` in examples\\fastmcp\\weather_structured.py",
      "possible_syscalls": [],
      "confidence": 0.26,
      "evidence": [
        "function get_weather_metrics in examples\\fastmcp\\weather_structured.py",
        "matched template: parse JSON input and validate fields (sim=0.32)"
      ]
    },
    {
      "name": "get_weather_alerts",
      "description": "parse JSON input and validate fields. Function `get_weather_alerts`.",
      "predicted_filename": "examples\\fastmcp\\weather_structured.py",
      "predicted_code_snippet": "def get_weather_alerts(region: str) -> list[WeatherAlert]:\n    \"\"\"Get active weather alerts for a region\"\"\"\n    # In production, this would fetch real alerts\n    if region.lower() == \"california\":\n        return [\n            WeatherAlert(\n                severity=\"high\",\n                title=\"Heat Wave Warning\",\n                description=\"Temperatures expected to exceed 40 degrees\",\n                affected_areas=[\"Los Angeles\", \"San Diego\", \"Riverside\"],\n                valid_until=datetime(2024, 7, 15, 18, 0),\n            ),\n            WeatherAlert(\n                severity=\"medium\",\n                title=\"Air Quality Advisory\",\n                description=\"Poor air quality due to wildfire smoke\",\n                affected_areas=[\"San Francisco Bay Area\"],\n                valid_until=datetime(2024, 7, 14, 12, 0),\n            ),\n        ]\n    return []",
      "input_schema": {
        "type": "object",
        "properties": {
          "region": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "region"
        ]
      },
      "output_schema": {
        "type": "array"
      },
      "payload_shape": {
        "request": {
          "region": "string"
        },
        "response": {
          "type": "array"
        }
      },
      "explanation": "Detected Python function `get_weather_alerts` in examples\\fastmcp\\weather_structured.py",
      "possible_syscalls": [],
      "confidence": 0.29,
      "evidence": [
        "function get_weather_alerts in examples\\fastmcp\\weather_structured.py",
        "matched template: parse JSON input and validate fields (sim=0.37)"
      ]
    },
    {
      "name": "get_temperature",
      "description": "parse JSON input and validate fields. Function `get_temperature`.",
      "predicted_filename": "examples\\fastmcp\\weather_structured.py",
      "predicted_code_snippet": "def get_temperature(city: str, unit: str = \"celsius\") -> float:\n    \"\"\"Get just the temperature for a city\n\n    When returning primitives as structured output,\n    the result is wrapped in {\"result\": value}\n    \"\"\"\n    base_temp = 22.5\n    if unit.lower() == \"fahrenheit\":\n        return base_temp * 9 / 5 + 32\n    return base_temp",
      "input_schema": {
        "type": "object",
        "properties": {
          "city": {
            "type": "string",
            "required": true
          },
          "unit": {
            "type": "string",
            "required": false
          }
        },
        "required": [
          "city"
        ]
      },
      "output_schema": {
        "type": "number"
      },
      "payload_shape": {
        "request": {
          "city": "string",
          "unit": "string"
        },
        "response": {
          "type": "number"
        }
      },
      "explanation": "Detected Python function `get_temperature` in examples\\fastmcp\\weather_structured.py",
      "possible_syscalls": [],
      "confidence": 0.25,
      "evidence": [
        "function get_temperature in examples\\fastmcp\\weather_structured.py",
        "matched template: parse JSON input and validate fields (sim=0.30)"
      ]
    },
    {
      "name": "get_weather_stats",
      "description": "write data to a file. Function `get_weather_stats`.",
      "predicted_filename": "examples\\fastmcp\\weather_structured.py",
      "predicted_code_snippet": "def get_weather_stats(city: str, days: int = 7) -> WeatherStats:\n    \"\"\"Get weather statistics for the past N days\"\"\"\n    return WeatherStats(\n        location=city,\n        period_days=days,\n        temperature=DailyStats(high=28.5, low=15.2, mean=21.8),\n        humidity=DailyStats(high=85.0, low=45.0, mean=65.0),\n        precipitation_mm=12.4,\n    )",
      "input_schema": {
        "type": "object",
        "properties": {
          "city": {
            "type": "string",
            "required": true
          },
          "days": {
            "type": "integer",
            "required": false
          }
        },
        "required": [
          "city"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "city": "string",
          "days": "integer"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `get_weather_stats` in examples\\fastmcp\\weather_structured.py",
      "possible_syscalls": [],
      "confidence": 0.25,
      "evidence": [
        "function get_weather_stats in examples\\fastmcp\\weather_structured.py",
        "matched template: write data to a file (sim=0.30)"
      ]
    },
    {
      "name": "test_simple_text",
      "description": "read a file from disk and return its contents. Function `test_simple_text`.",
      "predicted_filename": "examples\\servers\\everything-server\\mcp_everything_server\\server.py",
      "predicted_code_snippet": "def test_simple_text() -> str:\n    \"\"\"Tests simple text content response\"\"\"\n    return \"This is a simple text response for testing.\"",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `test_simple_text` in examples\\servers\\everything-server\\mcp_everything_server\\server.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function test_simple_text in examples\\servers\\everything-server\\mcp_everything_server\\server.py",
        "matched template: read a file from disk and return its contents (sim=0.20)"
      ]
    },
    {
      "name": "test_image_content",
      "description": "process image data (resize, crop, convert). Function `test_image_content`.",
      "predicted_filename": "examples\\servers\\everything-server\\mcp_everything_server\\server.py",
      "predicted_code_snippet": "def test_image_content() -> list[ImageContent]:\n    \"\"\"Tests image content response\"\"\"\n    return [ImageContent(type=\"image\", data=TEST_IMAGE_BASE64, mimeType=\"image/png\")]",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "array"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "array"
        }
      },
      "explanation": "Detected Python function `test_image_content` in examples\\servers\\everything-server\\mcp_everything_server\\server.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function test_image_content in examples\\servers\\everything-server\\mcp_everything_server\\server.py",
        "matched template: process image data (resize, crop, convert) (sim=0.27)"
      ]
    },
    {
      "name": "test_audio_content",
      "description": "stream data over websocket. Function `test_audio_content`.",
      "predicted_filename": "examples\\servers\\everything-server\\mcp_everything_server\\server.py",
      "predicted_code_snippet": "def test_audio_content() -> list[AudioContent]:\n    \"\"\"Tests audio content response\"\"\"\n    return [AudioContent(type=\"audio\", data=TEST_AUDIO_BASE64, mimeType=\"audio/wav\")]",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "array"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "array"
        }
      },
      "explanation": "Detected Python function `test_audio_content` in examples\\servers\\everything-server\\mcp_everything_server\\server.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_audio_content in examples\\servers\\everything-server\\mcp_everything_server\\server.py",
        "matched template: stream data over websocket (sim=0.19)"
      ]
    },
    {
      "name": "test_embedded_resource",
      "description": "make an HTTP request to an external API. Function `test_embedded_resource`.",
      "predicted_filename": "examples\\servers\\everything-server\\mcp_everything_server\\server.py",
      "predicted_code_snippet": "def test_embedded_resource() -> list[EmbeddedResource]:\n    \"\"\"Tests embedded resource content response\"\"\"\n    return [\n        EmbeddedResource(\n            type=\"resource\",\n            resource=TextResourceContents(\n                uri=AnyUrl(\"test://embedded-resource\"),\n                mimeType=\"text/plain\",\n                text=\"This is an embedded resource content.\",\n            ),\n        )\n    ]",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "array"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "array"
        }
      },
      "explanation": "Detected Python function `test_embedded_resource` in examples\\servers\\everything-server\\mcp_everything_server\\server.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function test_embedded_resource in examples\\servers\\everything-server\\mcp_everything_server\\server.py",
        "matched template: make an HTTP request to an external API (sim=0.21)"
      ]
    },
    {
      "name": "test_multiple_content_types",
      "description": "process image data (resize, crop, convert). Function `test_multiple_content_types`.",
      "predicted_filename": "examples\\servers\\everything-server\\mcp_everything_server\\server.py",
      "predicted_code_snippet": "def test_multiple_content_types() -> list[TextContent | ImageContent | EmbeddedResource]:\n    \"\"\"Tests response with multiple content types (text, image, resource)\"\"\"\n    return [\n        TextContent(type=\"text\", text=\"Multiple content types test:\"),\n        ImageContent(type=\"image\", data=TEST_IMAGE_BASE64, mimeType=\"image/png\"),\n        EmbeddedResource(\n            type=\"resource\",\n            resource=TextResourceContents(\n                uri=AnyUrl(\"test://mixed-content-resource\"),\n                mimeType=\"application/json\",\n                text='{\"test\": \"data\", \"value\": 123}',\n            ),\n        ),\n    ]",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "array"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "array"
        }
      },
      "explanation": "Detected Python function `test_multiple_content_types` in examples\\servers\\everything-server\\mcp_everything_server\\server.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function test_multiple_content_types in examples\\servers\\everything-server\\mcp_everything_server\\server.py",
        "matched template: process image data (resize, crop, convert) (sim=0.28)"
      ]
    },
    {
      "name": "test_error_handling",
      "description": "process image data (resize, crop, convert). Function `test_error_handling`.",
      "predicted_filename": "examples\\servers\\everything-server\\mcp_everything_server\\server.py",
      "predicted_code_snippet": "def test_error_handling() -> str:\n    \"\"\"Tests error response handling\"\"\"\n    raise RuntimeError(\"This tool intentionally returns an error for testing\")",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `test_error_handling` in examples\\servers\\everything-server\\mcp_everything_server\\server.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function test_error_handling in examples\\servers\\everything-server\\mcp_everything_server\\server.py",
        "matched template: process image data (resize, crop, convert) (sim=0.14)"
      ]
    },
    {
      "name": "static_text_resource",
      "description": "write data to a file. Function `static_text_resource`.",
      "predicted_filename": "examples\\servers\\everything-server\\mcp_everything_server\\server.py",
      "predicted_code_snippet": "def static_text_resource() -> str:\n    \"\"\"A static text resource for testing\"\"\"\n    return \"This is the content of the static text resource.\"",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `static_text_resource` in examples\\servers\\everything-server\\mcp_everything_server\\server.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function static_text_resource in examples\\servers\\everything-server\\mcp_everything_server\\server.py",
        "matched template: write data to a file (sim=0.18)"
      ]
    },
    {
      "name": "static_binary_resource",
      "description": "process image data (resize, crop, convert). Function `static_binary_resource`.",
      "predicted_filename": "examples\\servers\\everything-server\\mcp_everything_server\\server.py",
      "predicted_code_snippet": "def static_binary_resource() -> bytes:\n    \"\"\"A static binary resource (image) for testing\"\"\"\n    return base64.b64decode(TEST_IMAGE_BASE64)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `static_binary_resource` in examples\\servers\\everything-server\\mcp_everything_server\\server.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function static_binary_resource in examples\\servers\\everything-server\\mcp_everything_server\\server.py",
        "matched template: process image data (resize, crop, convert) (sim=0.20)"
      ]
    },
    {
      "name": "template_resource",
      "description": "stream data over websocket. Function `template_resource`.",
      "predicted_filename": "examples\\servers\\everything-server\\mcp_everything_server\\server.py",
      "predicted_code_snippet": "def template_resource(id: str) -> str:\n    \"\"\"A resource template with parameter substitution\"\"\"\n    return json.dumps({\"id\": id, \"templateTest\": True, \"data\": f\"Data for ID: {id}\"})",
      "input_schema": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "id"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "id": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `template_resource` in examples\\servers\\everything-server\\mcp_everything_server\\server.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function template_resource in examples\\servers\\everything-server\\mcp_everything_server\\server.py",
        "matched template: stream data over websocket (sim=0.16)"
      ]
    },
    {
      "name": "watched_resource",
      "description": "stream data over websocket. Function `watched_resource`.",
      "predicted_filename": "examples\\servers\\everything-server\\mcp_everything_server\\server.py",
      "predicted_code_snippet": "def watched_resource() -> str:\n    \"\"\"A resource that can be subscribed to for updates\"\"\"\n    return watched_resource_content",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `watched_resource` in examples\\servers\\everything-server\\mcp_everything_server\\server.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function watched_resource in examples\\servers\\everything-server\\mcp_everything_server\\server.py",
        "matched template: stream data over websocket (sim=0.22)"
      ]
    },
    {
      "name": "test_simple_prompt",
      "description": "authenticate a user and return a token. Function `test_simple_prompt`.",
      "predicted_filename": "examples\\servers\\everything-server\\mcp_everything_server\\server.py",
      "predicted_code_snippet": "def test_simple_prompt() -> list[UserMessage]:\n    \"\"\"A simple prompt without arguments\"\"\"\n    return [UserMessage(role=\"user\", content=TextContent(type=\"text\", text=\"This is a simple prompt for testing.\"))]",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "array"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "array"
        }
      },
      "explanation": "Detected Python function `test_simple_prompt` in examples\\servers\\everything-server\\mcp_everything_server\\server.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_simple_prompt in examples\\servers\\everything-server\\mcp_everything_server\\server.py",
        "matched template: authenticate a user and return a token (sim=0.20)"
      ]
    },
    {
      "name": "test_prompt_with_arguments",
      "description": "execute a shell command. Function `test_prompt_with_arguments`.",
      "predicted_filename": "examples\\servers\\everything-server\\mcp_everything_server\\server.py",
      "predicted_code_snippet": "def test_prompt_with_arguments(arg1: str, arg2: str) -> list[UserMessage]:\n    \"\"\"A prompt with required arguments\"\"\"\n    return [\n        UserMessage(\n            role=\"user\", content=TextContent(type=\"text\", text=f\"Prompt with arguments: arg1='{arg1}', arg2='{arg2}'\")\n        )\n    ]",
      "input_schema": {
        "type": "object",
        "properties": {
          "arg1": {
            "type": "string",
            "required": true
          },
          "arg2": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "arg1",
          "arg2"
        ]
      },
      "output_schema": {
        "type": "array"
      },
      "payload_shape": {
        "request": {
          "arg1": "string",
          "arg2": "string"
        },
        "response": {
          "type": "array"
        }
      },
      "explanation": "Detected Python function `test_prompt_with_arguments` in examples\\servers\\everything-server\\mcp_everything_server\\server.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_prompt_with_arguments in examples\\servers\\everything-server\\mcp_everything_server\\server.py",
        "matched template: execute a shell command (sim=0.20)"
      ]
    },
    {
      "name": "test_prompt_with_embedded_resource",
      "description": "execute a shell command. Function `test_prompt_with_embedded_resource`.",
      "predicted_filename": "examples\\servers\\everything-server\\mcp_everything_server\\server.py",
      "predicted_code_snippet": "def test_prompt_with_embedded_resource(resourceUri: str) -> list[UserMessage]:\n    \"\"\"A prompt that includes an embedded resource\"\"\"\n    return [\n        UserMessage(\n            role=\"user\",\n            content=EmbeddedResource(\n                type=\"resource\",\n                resource=TextResourceContents(\n                    uri=AnyUrl(resourceUri),\n                    mimeType=\"text/plain\",\n                    text=\"Embedded resource content for testing.\",\n                ),\n            ),\n        ),\n        UserMessage(role=\"user\", content=TextContent(type=\"text\", text=\"Please process the embedded resource above.\")),\n    ]",
      "input_schema": {
        "type": "object",
        "properties": {
          "resourceUri": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "resourceUri"
        ]
      },
      "output_schema": {
        "type": "array"
      },
      "payload_shape": {
        "request": {
          "resourceUri": "string"
        },
        "response": {
          "type": "array"
        }
      },
      "explanation": "Detected Python function `test_prompt_with_embedded_resource` in examples\\servers\\everything-server\\mcp_everything_server\\server.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_prompt_with_embedded_resource in examples\\servers\\everything-server\\mcp_everything_server\\server.py",
        "matched template: execute a shell command (sim=0.18)"
      ]
    },
    {
      "name": "test_prompt_with_image",
      "description": "process image data (resize, crop, convert). Function `test_prompt_with_image`.",
      "predicted_filename": "examples\\servers\\everything-server\\mcp_everything_server\\server.py",
      "predicted_code_snippet": "def test_prompt_with_image() -> list[UserMessage]:\n    \"\"\"A prompt that includes image content\"\"\"\n    return [\n        UserMessage(role=\"user\", content=ImageContent(type=\"image\", data=TEST_IMAGE_BASE64, mimeType=\"image/png\")),\n        UserMessage(role=\"user\", content=TextContent(type=\"text\", text=\"Please analyze the image above.\")),\n    ]",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "array"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "array"
        }
      },
      "explanation": "Detected Python function `test_prompt_with_image` in examples\\servers\\everything-server\\mcp_everything_server\\server.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function test_prompt_with_image in examples\\servers\\everything-server\\mcp_everything_server\\server.py",
        "matched template: process image data (resize, crop, convert) (sim=0.28)"
      ]
    },
    {
      "name": "main",
      "description": "stream data over websocket. Function `main`.",
      "predicted_filename": "examples\\servers\\everything-server\\mcp_everything_server\\server.py",
      "predicted_code_snippet": "def main(port: int, log_level: str) -> int:\n    \"\"\"Run the MCP Everything Server.\"\"\"\n    logging.basicConfig(\n        level=getattr(logging, log_level.upper()),\n        format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n    )\n\n    logger.info(f\"Starting MCP Everything Server on port {port}\")\n    logger.info(f\"Endpoint will be: http://localhost:{port}/mcp\")\n\n    mcp.settings.port = port\n    mcp.run(transport=\"streamable-http\")\n\n    return 0",
      "input_schema": {
        "type": "object",
        "properties": {
          "port": {
            "type": "integer",
            "required": true
          },
          "log_level": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "port",
          "log_level"
        ]
      },
      "output_schema": {
        "type": "integer"
      },
      "payload_shape": {
        "request": {
          "port": "integer",
          "log_level": "string"
        },
        "response": {
          "type": "integer"
        }
      },
      "explanation": "Detected Python function `main` in examples\\servers\\everything-server\\mcp_everything_server\\server.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function main in examples\\servers\\everything-server\\mcp_everything_server\\server.py",
        "matched template: stream data over websocket (sim=0.20)"
      ]
    },
    {
      "name": "create_authorization_server",
      "description": "authenticate a user and return a token. Function `create_authorization_server`.",
      "predicted_filename": "examples\\servers\\simple-auth\\mcp_simple_auth\\auth_server.py",
      "predicted_code_snippet": "def create_authorization_server(server_settings: AuthServerSettings, auth_settings: SimpleAuthSettings) -> Starlette:\n    \"\"\"Create the Authorization Server application.\"\"\"\n    oauth_provider = SimpleAuthProvider(\n        auth_settings, server_settings.auth_callback_path, str(server_settings.server_url)\n    )\n\n    mcp_auth_settings = AuthSettings(\n        issuer_url=server_settings.server_url,\n        client_registration_options=ClientRegistrationOptions(\n            enabled=True,\n            valid_scopes=[auth_settings.mcp_scope],\n            default_scopes=[auth_settings.mcp_scope],\n        ),\n        required_scopes=[auth_settings.mcp_scope],\n        resource_server_url=None,\n    )\n\n    # Create OAuth routes\n    routes = create_auth_routes(\n        provider=oauth_provider,\n        issuer_url=mcp_auth_settings.issuer_url,\n        service_documentation_url=mcp_auth_settings.service_documentation_url,\n        client_registration_options=mcp_auth_settings.client_registration_options,\n        revocation_options=mcp_auth_settings.revocation_options,\n    )\n\n    # Add login page route (GET)\n    async def login_page_handler(request: Request) -> Response:\n        \"\"\"Show login form.\"\"\"\n        state = request.query_params.get(\"state\")\n        if not state:\n            raise HTTPException(400, \"Missing state parameter\")\n        return await oauth_provider.get_login_page(state)\n\n    routes.append(Route(\"/login\", endpoint=login_page_handler, methods=[\"GET\"]))\n\n    # Add login callback route (POST)\n    async def login_callback_handler(request: Request) -> Response:\n        \"\"\"Handle simple authentication callback.\"\"\"\n        return await oauth_provider.handle_login_callback(request)\n\n    routes.append(Route(\"/login/callback\", endpoint=login_callback_handler, methods=[\"POST\"]))\n\n    # Add token introspection endpoint (RFC 7662) for Resource Servers\n    async def introspect_handler(request: Request) -> Response:\n        \"\"\"\n        Token introspection endpoint for Resource Servers.\n\n        Resource Servers call this endpoint to validate tokens without\n        needing direct access to token storage.\n        \"\"\"\n        form = await request.form()\n        token = form.get(\"token\")\n        if not token or not isinstance(token, str):\n            return JSONResponse({\"active\": False}, status_code=400)\n\n        # Look up token in provider\n        access_token = await oauth_provider.load_access_token(token)\n        if not access_token:\n            return JSONResponse({\"active\": False})\n\n        return JSONResponse(\n            {\n                \"active\": True,\n                \"client_id\": access_token.client_id,\n                \"scope\": \" \".join(access_token.scopes),\n                \"exp\": access_token.expires_at,\n                \"iat\": int(time.time()),\n                \"token_type\": \"Bearer\",\n                \"aud\": access_token.resource,  # RFC 8707 audience claim\n            }\n        )\n\n    routes.append(\n        Route(\n            \"/introspect\",\n            endpoint=cors_middleware(introspect_handler, [\"POST\", \"OPTIONS\"]),\n            methods=[\"POST\", \"OPTIONS\"],\n        )\n    )\n\n    return Starlette(routes=routes)",
      "input_schema": {
        "type": "object",
        "properties": {
          "server_settings": {
            "type": "string",
            "required": true
          },
          "auth_settings": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "server_settings",
          "auth_settings"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "server_settings": "string",
          "auth_settings": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `create_authorization_server` in examples\\servers\\simple-auth\\mcp_simple_auth\\auth_server.py",
      "possible_syscalls": [],
      "confidence": 0.27,
      "evidence": [
        "function create_authorization_server in examples\\servers\\simple-auth\\mcp_simple_auth\\auth_server.py",
        "matched template: authenticate a user and return a token (sim=0.35)"
      ]
    },
    {
      "name": "main",
      "description": "authenticate a user and return a token. Function `main`.",
      "predicted_filename": "examples\\servers\\simple-auth\\mcp_simple_auth\\auth_server.py",
      "predicted_code_snippet": "def main(port: int) -> int:\n    \"\"\"\n    Run the MCP Authorization Server.\n\n    This server handles OAuth flows and can be used by multiple Resource Servers.\n\n    Uses simple hardcoded credentials for demo purposes.\n    \"\"\"\n    logging.basicConfig(level=logging.INFO)\n\n    # Load simple auth settings\n    auth_settings = SimpleAuthSettings()\n\n    # Create server settings\n    host = \"localhost\"\n    server_url = f\"http://{host}:{port}\"\n    server_settings = AuthServerSettings(\n        host=host,\n        port=port,\n        server_url=AnyHttpUrl(server_url),\n        auth_callback_path=f\"{server_url}/login\",\n    )\n\n    asyncio.run(run_server(server_settings, auth_settings))\n    return 0",
      "input_schema": {
        "type": "object",
        "properties": {
          "port": {
            "type": "integer",
            "required": true
          }
        },
        "required": [
          "port"
        ]
      },
      "output_schema": {
        "type": "integer"
      },
      "payload_shape": {
        "request": {
          "port": "integer"
        },
        "response": {
          "type": "integer"
        }
      },
      "explanation": "Detected Python function `main` in examples\\servers\\simple-auth\\mcp_simple_auth\\auth_server.py",
      "possible_syscalls": [],
      "confidence": 0.26,
      "evidence": [
        "function main in examples\\servers\\simple-auth\\mcp_simple_auth\\auth_server.py",
        "matched template: authenticate a user and return a token (sim=0.33)"
      ]
    },
    {
      "name": "create_simple_mcp_server",
      "description": "authenticate a user and return a token. Function `create_simple_mcp_server`.",
      "predicted_filename": "examples\\servers\\simple-auth\\mcp_simple_auth\\legacy_as_server.py",
      "predicted_code_snippet": "def create_simple_mcp_server(server_settings: ServerSettings, auth_settings: SimpleAuthSettings) -> FastMCP:\n    \"\"\"Create a simple FastMCP server with simple authentication.\"\"\"\n    oauth_provider = LegacySimpleOAuthProvider(\n        auth_settings, server_settings.auth_callback_path, str(server_settings.server_url)\n    )\n\n    mcp_auth_settings = AuthSettings(\n        issuer_url=server_settings.server_url,\n        client_registration_options=ClientRegistrationOptions(\n            enabled=True,\n            valid_scopes=[auth_settings.mcp_scope],\n            default_scopes=[auth_settings.mcp_scope],\n        ),\n        required_scopes=[auth_settings.mcp_scope],\n        # No resource_server_url parameter in legacy mode\n        resource_server_url=None,\n    )\n\n    app = FastMCP(\n        name=\"Simple Auth MCP Server\",\n        instructions=\"A simple MCP server with simple credential authentication\",\n        auth_server_provider=oauth_provider,\n        host=server_settings.host,\n        port=server_settings.port,\n        debug=True,\n        auth=mcp_auth_settings,\n    )\n\n    @app.custom_route(\"/login\", methods=[\"GET\"])\n    async def login_page_handler(request: Request) -> Response:\n        \"\"\"Show login form.\"\"\"\n        state = request.query_params.get(\"state\")\n        if not state:\n            raise HTTPException(400, \"Missing state parameter\")\n        return await oauth_provider.get_login_page(state)\n\n    @app.custom_route(\"/login/callback\", methods=[\"POST\"])\n    async def login_callback_handler(request: Request) -> Response:\n        \"\"\"Handle simple authentication callback.\"\"\"\n        return await oauth_provider.handle_login_callback(request)\n\n    @app.tool()\n    async def get_time() -> dict[str, Any]:\n        \"\"\"\n        Get the current server time.\n\n        This tool demonstrates that system information can be protected\n        by OAuth authentication. User must be authenticated to access it.\n        \"\"\"\n\n        now = datetime.datetime.now()\n\n        return {\n            \"current_time\": now.isoformat(),\n            \"timezone\": \"UTC\",  # Simplified for demo\n            \"timestamp\": now.timestamp(),\n            \"formatted\": now.strftime(\"%Y-%m-%d %H:%M:%S\"),\n        }\n\n    return app",
      "input_schema": {
        "type": "object",
        "properties": {
          "server_settings": {
            "type": "string",
            "required": true
          },
          "auth_settings": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "server_settings",
          "auth_settings"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "server_settings": "string",
          "auth_settings": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `create_simple_mcp_server` in examples\\servers\\simple-auth\\mcp_simple_auth\\legacy_as_server.py",
      "possible_syscalls": [],
      "confidence": 0.25,
      "evidence": [
        "function create_simple_mcp_server in examples\\servers\\simple-auth\\mcp_simple_auth\\legacy_as_server.py",
        "matched template: authenticate a user and return a token (sim=0.30)"
      ]
    },
    {
      "name": "main",
      "description": "make an HTTP request to an external API. Function `main`.",
      "predicted_filename": "examples\\servers\\simple-auth\\mcp_simple_auth\\legacy_as_server.py",
      "predicted_code_snippet": "def main(port: int, transport: Literal[\"sse\", \"streamable-http\"]) -> int:\n    \"\"\"Run the simple auth MCP server.\"\"\"\n    logging.basicConfig(level=logging.INFO)\n\n    auth_settings = SimpleAuthSettings()\n    # Create server settings\n    host = \"localhost\"\n    server_url = f\"http://{host}:{port}\"\n    server_settings = ServerSettings(\n        host=host,\n        port=port,\n        server_url=AnyHttpUrl(server_url),\n        auth_callback_path=f\"{server_url}/login\",\n    )\n\n    mcp_server = create_simple_mcp_server(server_settings, auth_settings)\n    logger.info(f\"\ud83d\ude80 MCP Legacy Server running on {server_url}\")\n    mcp_server.run(transport=transport)\n    return 0",
      "input_schema": {
        "type": "object",
        "properties": {
          "port": {
            "type": "integer",
            "required": true
          },
          "transport": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "port",
          "transport"
        ]
      },
      "output_schema": {
        "type": "integer"
      },
      "payload_shape": {
        "request": {
          "port": "integer",
          "transport": "string"
        },
        "response": {
          "type": "integer"
        }
      },
      "explanation": "Detected Python function `main` in examples\\servers\\simple-auth\\mcp_simple_auth\\legacy_as_server.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function main in examples\\servers\\simple-auth\\mcp_simple_auth\\legacy_as_server.py",
        "matched template: make an HTTP request to an external API (sim=0.26)"
      ]
    },
    {
      "name": "create_resource_server",
      "description": "authenticate a user and return a token. Function `create_resource_server`.",
      "predicted_filename": "examples\\servers\\simple-auth\\mcp_simple_auth\\server.py",
      "predicted_code_snippet": "def create_resource_server(settings: ResourceServerSettings) -> FastMCP:\n    \"\"\"\n    Create MCP Resource Server with token introspection.\n\n    This server:\n    1. Provides protected resource metadata (RFC 9728)\n    2. Validates tokens via Authorization Server introspection\n    3. Serves MCP tools and resources\n    \"\"\"\n    # Create token verifier for introspection with RFC 8707 resource validation\n    token_verifier = IntrospectionTokenVerifier(\n        introspection_endpoint=settings.auth_server_introspection_endpoint,\n        server_url=str(settings.server_url),\n        validate_resource=settings.oauth_strict,  # Only validate when --oauth-strict is set\n    )\n\n    # Create FastMCP server as a Resource Server\n    app = FastMCP(\n        name=\"MCP Resource Server\",\n        instructions=\"Resource Server that validates tokens via Authorization Server introspection\",\n        host=settings.host,\n        port=settings.port,\n        debug=True,\n        # Auth configuration for RS mode\n        token_verifier=token_verifier,\n        auth=AuthSettings(\n            issuer_url=settings.auth_server_url,\n            required_scopes=[settings.mcp_scope],\n            resource_server_url=settings.server_url,\n        ),\n    )\n\n    @app.tool()\n    async def get_time() -> dict[str, Any]:\n        \"\"\"\n        Get the current server time.\n\n        This tool demonstrates that system information can be protected\n        by OAuth authentication. User must be authenticated to access it.\n        \"\"\"\n\n        now = datetime.datetime.now()\n\n        return {\n            \"current_time\": now.isoformat(),\n            \"timezone\": \"UTC\",  # Simplified for demo\n            \"timestamp\": now.timestamp(),\n            \"formatted\": now.strftime(\"%Y-%m-%d %H:%M:%S\"),\n        }\n\n    return app",
      "input_schema": {
        "type": "object",
        "properties": {
          "settings": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "settings"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "settings": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `create_resource_server` in examples\\servers\\simple-auth\\mcp_simple_auth\\server.py",
      "possible_syscalls": [],
      "confidence": 0.26,
      "evidence": [
        "function create_resource_server in examples\\servers\\simple-auth\\mcp_simple_auth\\server.py",
        "matched template: authenticate a user and return a token (sim=0.32)"
      ]
    },
    {
      "name": "main",
      "description": "make an HTTP request to an external API. Function `main`.",
      "predicted_filename": "examples\\servers\\simple-auth\\mcp_simple_auth\\server.py",
      "predicted_code_snippet": "def main(port: int, auth_server: str, transport: Literal[\"sse\", \"streamable-http\"], oauth_strict: bool) -> int:\n    \"\"\"\n    Run the MCP Resource Server.\n\n    This server:\n    - Provides RFC 9728 Protected Resource Metadata\n    - Validates tokens via Authorization Server introspection\n    - Serves MCP tools requiring authentication\n\n    Must be used with a running Authorization Server.\n    \"\"\"\n    logging.basicConfig(level=logging.INFO)\n\n    try:\n        # Parse auth server URL\n        auth_server_url = AnyHttpUrl(auth_server)\n\n        # Create settings\n        host = \"localhost\"\n        server_url = f\"http://{host}:{port}/mcp\"\n        settings = ResourceServerSettings(\n            host=host,\n            port=port,\n            server_url=AnyHttpUrl(server_url),\n            auth_server_url=auth_server_url,\n            auth_server_introspection_endpoint=f\"{auth_server}/introspect\",\n            oauth_strict=oauth_strict,\n        )\n    except ValueError as e:\n        logger.error(f\"Configuration error: {e}\")\n        logger.error(\"Make sure to provide a valid Authorization Server URL\")\n        return 1\n\n    try:\n        mcp_server = create_resource_server(settings)\n\n        logger.info(f\"\ud83d\ude80 MCP Resource Server running on {settings.server_url}\")\n        logger.info(f\"\ud83d\udd11 Using Authorization Server: {settings.auth_server_url}\")\n\n        # Run the server - this should block and keep running\n        mcp_server.run(transport=transport)\n        logger.info(\"Server stopped\")\n        return 0\n    except Exception:\n        logger.exception(\"Server error\")\n        return 1",
      "input_schema": {
        "type": "object",
        "properties": {
          "port": {
            "type": "integer",
            "required": true
          },
          "auth_server": {
            "type": "string",
            "required": true
          },
          "transport": {
            "type": "string",
            "required": true
          },
          "oauth_strict": {
            "type": "boolean",
            "required": true
          }
        },
        "required": [
          "port",
          "auth_server",
          "transport",
          "oauth_strict"
        ]
      },
      "output_schema": {
        "type": "integer"
      },
      "payload_shape": {
        "request": {
          "port": "integer",
          "auth_server": "string",
          "transport": "string",
          "oauth_strict": "boolean"
        },
        "response": {
          "type": "integer"
        }
      },
      "explanation": "Detected Python function `main` in examples\\servers\\simple-auth\\mcp_simple_auth\\server.py",
      "possible_syscalls": [],
      "confidence": 0.27,
      "evidence": [
        "function main in examples\\servers\\simple-auth\\mcp_simple_auth\\server.py",
        "matched template: make an HTTP request to an external API (sim=0.35)"
      ]
    },
    {
      "name": "main",
      "description": "perform database query and return records. Function `main`.",
      "predicted_filename": "examples\\servers\\simple-pagination\\mcp_simple_pagination\\server.py",
      "predicted_code_snippet": "def main(port: int, transport: str) -> int:\n    app = Server(\"mcp-simple-pagination\")\n\n    # Paginated list_tools - returns 5 tools per page\n    @app.list_tools()\n    async def list_tools_paginated(request: types.ListToolsRequest) -> types.ListToolsResult:\n        page_size = 5\n\n        cursor = request.params.cursor if request.params is not None else None\n        if cursor is None:\n            # First page\n            start_idx = 0\n        else:\n            # Parse cursor to get the start index\n            try:\n                start_idx = int(cursor)\n            except (ValueError, TypeError):\n                # Invalid cursor, return empty\n                return types.ListToolsResult(tools=[], nextCursor=None)\n\n        # Get the page of tools\n        page_tools = SAMPLE_TOOLS[start_idx : start_idx + page_size]\n\n        # Determine if there are more pages\n        next_cursor = None\n        if start_idx + page_size < len(SAMPLE_TOOLS):\n            next_cursor = str(start_idx + page_size)\n\n        return types.ListToolsResult(tools=page_tools, nextCursor=next_cursor)\n\n    # Paginated list_resources - returns 10 resources per page\n    @app.list_resources()\n    async def list_resources_paginated(\n        request: types.ListResourcesRequest,\n    ) -> types.ListResourcesResult:\n        page_size = 10\n\n        cursor = request.params.cursor if request.params is not None else None\n        if cursor is None:\n            # First page\n            start_idx = 0\n        else:\n            # Parse cursor to get the start index\n            try:\n                start_idx = int(cursor)\n            except (ValueError, TypeError):\n                # Invalid cursor, return empty\n                return types.ListResourcesResult(resources=[], nextCursor=None)\n\n        # Get the page of resources\n        page_resources = SAMPLE_RESOURCES[start_idx : start_idx + page_size]\n\n        # Determine if there are more pages\n        next_cursor = None\n        if start_idx + page_size < len(SAMPLE_RESOURCES):\n            next_cursor = str(start_idx + page_size)\n\n        return types.ListResourcesResult(resources=page_resources, nextCursor=next_cursor)\n\n    # Paginated list_prompts - returns 7 prompts per page\n    @app.list_prompts()\n    async def list_prompts_paginated(\n        request: types.ListPromptsRequest,\n    ) -> types.ListPromptsResult:\n        page_size = 7\n\n        cursor = request.params.cursor if request.params is not None else None\n        if cursor is None:\n            # First page\n            start_idx = 0\n        else:\n            # Parse cursor to get the start index\n            try:\n                start_idx = int(cursor)\n            except (ValueError, TypeError):\n                # Invalid cursor, return empty\n                return types.ListPromptsResult(prompts=[], nextCursor=None)\n\n        # Get the page of prompts\n        page_prompts = SAMPLE_PROMPTS[start_idx : start_idx + page_size]\n\n        # Determine if there are more pages\n        next_cursor = None\n        if start_idx + page_size < len(SAMPLE_PROMPTS):\n            next_cursor = str(start_idx + page_size)\n\n        return types.ListPromptsResult(prompts=page_prompts, nextCursor=next_cursor)\n\n    # Implement call_tool handler\n    @app.call_tool()\n    async def call_tool(name: str, arguments: dict[str, Any]) -> list[types.ContentBlock]:\n        # Find the tool in our sample data\n        tool = next((t for t in SAMPLE_TOOLS if t.name == name), None)\n        if not tool:\n            raise ValueError(f\"Unknown tool: {name}\")\n\n        # Simple mock response\n        return [\n            types.TextContent(\n                type=\"text\",\n                text=f\"Called tool '{name}' with arguments: {arguments}\",\n            )\n        ]\n\n    # Implement read_resource handler\n    @app.read_resource()\n    async def read_resource(uri: AnyUrl) -> str:\n        # Find the resource in our sample data\n        resource = next((r for r in SAMPLE_RESOURCES if r.uri == uri), None)\n        if not resource:\n            raise ValueError(f\"Unknown resource: {uri}\")\n\n        # Return a simple string - the decorator will convert it to TextResourceContents\n        return f\"Content of {resource.name}: This is sample content for the resource.\"\n\n    # Implement get_prompt handler\n    @app.get_prompt()\n    async def get_prompt(name: str, arguments: dict[str, str] | None) -> types.GetPromptResult:\n        # Find the prompt in our sample data\n        prompt = next((p for p in SAMPLE_PROMPTS if p.name == name), None)\n        if not prompt:\n            raise ValueError(f\"Unknown prompt: {name}\")\n\n        # Simple mock response\n        message_text = f\"This is the prompt '{name}'\"\n        if arguments:\n            message_text += f\" with arguments: {arguments}\"\n\n        return types.GetPromptResult(\n            description=prompt.description,\n            messages=[\n                types.PromptMessage(\n                    role=\"user\",\n                    content=types.TextContent(type=\"text\", text=message_text),\n                )\n            ],\n        )\n\n    if transport == \"sse\":\n        from mcp.server.sse import SseServerTransport\n        from starlette.applications import Starlette\n        from starlette.responses import Response\n        from starlette.routing import Mount, Route\n\n        sse = SseServerTransport(\"/messages/\")\n\n        async def handle_sse(request: Request):\n            async with sse.connect_sse(request.scope, request.receive, request._send) as streams:  # type: ignore[reportPrivateUsage]\n                await app.run(streams[0], streams[1], app.create_initialization_options())\n            return Response()\n\n        starlette_app = Starlette(\n            debug=True,\n            routes=[\n                Route(\"/sse\", endpoint=handle_sse, methods=[\"GET\"]),\n                Mount(\"/messages/\", app=sse.handle_post_message),\n            ],\n        )\n\n        import uvicorn\n\n        uvicorn.run(starlette_app, host=\"127.0.0.1\", port=port)\n    else:\n        from mcp.server.stdio import stdio_server\n\n        async def arun():\n            async with stdio_server() as streams:\n                await app.run(streams[0], streams[1], app.create_initialization_options())\n\n        anyio.run(arun)\n\n    return 0",
      "input_schema": {
        "type": "object",
        "properties": {
          "port": {
            "type": "integer",
            "required": true
          },
          "transport": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "port",
          "transport"
        ]
      },
      "output_schema": {
        "type": "integer"
      },
      "payload_shape": {
        "request": {
          "port": "integer",
          "transport": "string"
        },
        "response": {
          "type": "integer"
        }
      },
      "explanation": "Detected Python function `main` in examples\\servers\\simple-pagination\\mcp_simple_pagination\\server.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function main in examples\\servers\\simple-pagination\\mcp_simple_pagination\\server.py",
        "matched template: perform database query and return records (sim=0.18)"
      ]
    },
    {
      "name": "create_messages",
      "description": "send an email notification. Function `create_messages`.",
      "predicted_filename": "examples\\servers\\simple-prompt\\mcp_simple_prompt\\server.py",
      "predicted_code_snippet": "def create_messages(context: str | None = None, topic: str | None = None) -> list[types.PromptMessage]:\n    \"\"\"Create the messages for the prompt.\"\"\"\n    messages: list[types.PromptMessage] = []\n\n    # Add context if provided\n    if context:\n        messages.append(\n            types.PromptMessage(\n                role=\"user\",\n                content=types.TextContent(type=\"text\", text=f\"Here is some relevant context: {context}\"),\n            )\n        )\n\n    # Add the main prompt\n    prompt = \"Please help me with \"\n    if topic:\n        prompt += f\"the following topic: {topic}\"\n    else:\n        prompt += \"whatever questions I may have.\"\n\n    messages.append(types.PromptMessage(role=\"user\", content=types.TextContent(type=\"text\", text=prompt)))\n\n    return messages",
      "input_schema": {
        "type": "object",
        "properties": {
          "context": {
            "type": "string",
            "required": false
          },
          "topic": {
            "type": "string",
            "required": false
          }
        },
        "required": []
      },
      "output_schema": {
        "type": "array"
      },
      "payload_shape": {
        "request": {
          "context": "string",
          "topic": "string"
        },
        "response": {
          "type": "array"
        }
      },
      "explanation": "Detected Python function `create_messages` in examples\\servers\\simple-prompt\\mcp_simple_prompt\\server.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function create_messages in examples\\servers\\simple-prompt\\mcp_simple_prompt\\server.py",
        "matched template: send an email notification (sim=0.19)"
      ]
    },
    {
      "name": "main",
      "description": "execute a shell command. Function `main`.",
      "predicted_filename": "examples\\servers\\simple-prompt\\mcp_simple_prompt\\server.py",
      "predicted_code_snippet": "def main(port: int, transport: str) -> int:\n    app = Server(\"mcp-simple-prompt\")\n\n    @app.list_prompts()\n    async def list_prompts() -> list[types.Prompt]:\n        return [\n            types.Prompt(\n                name=\"simple\",\n                title=\"Simple Assistant Prompt\",\n                description=\"A simple prompt that can take optional context and topic arguments\",\n                arguments=[\n                    types.PromptArgument(\n                        name=\"context\",\n                        description=\"Additional context to consider\",\n                        required=False,\n                    ),\n                    types.PromptArgument(\n                        name=\"topic\",\n                        description=\"Specific topic to focus on\",\n                        required=False,\n                    ),\n                ],\n            )\n        ]\n\n    @app.get_prompt()\n    async def get_prompt(name: str, arguments: dict[str, str] | None = None) -> types.GetPromptResult:\n        if name != \"simple\":\n            raise ValueError(f\"Unknown prompt: {name}\")\n\n        if arguments is None:\n            arguments = {}\n\n        return types.GetPromptResult(\n            messages=create_messages(context=arguments.get(\"context\"), topic=arguments.get(\"topic\")),\n            description=\"A simple prompt with optional context and topic arguments\",\n        )\n\n    if transport == \"sse\":\n        from mcp.server.sse import SseServerTransport\n        from starlette.applications import Starlette\n        from starlette.responses import Response\n        from starlette.routing import Mount, Route\n\n        sse = SseServerTransport(\"/messages/\")\n\n        async def handle_sse(request: Request):\n            async with sse.connect_sse(request.scope, request.receive, request._send) as streams:  # type: ignore[reportPrivateUsage]\n                await app.run(streams[0], streams[1], app.create_initialization_options())\n            return Response()\n\n        starlette_app = Starlette(\n            debug=True,\n            routes=[\n                Route(\"/sse\", endpoint=handle_sse),\n                Mount(\"/messages/\", app=sse.handle_post_message),\n            ],\n        )\n\n        import uvicorn\n\n        uvicorn.run(starlette_app, host=\"127.0.0.1\", port=port)\n    else:\n        from mcp.server.stdio import stdio_server\n\n        async def arun():\n            async with stdio_server() as streams:\n                await app.run(streams[0], streams[1], app.create_initialization_options())\n\n        anyio.run(arun)\n\n    return 0",
      "input_schema": {
        "type": "object",
        "properties": {
          "port": {
            "type": "integer",
            "required": true
          },
          "transport": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "port",
          "transport"
        ]
      },
      "output_schema": {
        "type": "integer"
      },
      "payload_shape": {
        "request": {
          "port": "integer",
          "transport": "string"
        },
        "response": {
          "type": "integer"
        }
      },
      "explanation": "Detected Python function `main` in examples\\servers\\simple-prompt\\mcp_simple_prompt\\server.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function main in examples\\servers\\simple-prompt\\mcp_simple_prompt\\server.py",
        "matched template: execute a shell command (sim=0.20)"
      ]
    },
    {
      "name": "main",
      "description": "read a file from disk and return its contents. Function `main`.",
      "predicted_filename": "examples\\servers\\simple-resource\\mcp_simple_resource\\server.py",
      "predicted_code_snippet": "def main(port: int, transport: str) -> int:\n    app = Server(\"mcp-simple-resource\")\n\n    @app.list_resources()\n    async def list_resources() -> list[types.Resource]:\n        return [\n            types.Resource(\n                uri=FileUrl(f\"file:///{name}.txt\"),\n                name=name,\n                title=SAMPLE_RESOURCES[name][\"title\"],\n                description=f\"A sample text resource named {name}\",\n                mimeType=\"text/plain\",\n            )\n            for name in SAMPLE_RESOURCES.keys()\n        ]\n\n    @app.read_resource()\n    async def read_resource(uri: AnyUrl):\n        if uri.path is None:\n            raise ValueError(f\"Invalid resource path: {uri}\")\n        name = uri.path.replace(\".txt\", \"\").lstrip(\"/\")\n\n        if name not in SAMPLE_RESOURCES:\n            raise ValueError(f\"Unknown resource: {uri}\")\n\n        return [ReadResourceContents(content=SAMPLE_RESOURCES[name][\"content\"], mime_type=\"text/plain\")]\n\n    if transport == \"sse\":\n        from mcp.server.sse import SseServerTransport\n        from starlette.applications import Starlette\n        from starlette.responses import Response\n        from starlette.routing import Mount, Route\n\n        sse = SseServerTransport(\"/messages/\")\n\n        async def handle_sse(request: Request):\n            async with sse.connect_sse(request.scope, request.receive, request._send) as streams:  # type: ignore[reportPrivateUsage]\n                await app.run(streams[0], streams[1], app.create_initialization_options())\n            return Response()\n\n        starlette_app = Starlette(\n            debug=True,\n            routes=[\n                Route(\"/sse\", endpoint=handle_sse, methods=[\"GET\"]),\n                Mount(\"/messages/\", app=sse.handle_post_message),\n            ],\n        )\n\n        import uvicorn\n\n        uvicorn.run(starlette_app, host=\"127.0.0.1\", port=port)\n    else:\n        from mcp.server.stdio import stdio_server\n\n        async def arun():\n            async with stdio_server() as streams:\n                await app.run(streams[0], streams[1], app.create_initialization_options())\n\n        anyio.run(arun)\n\n    return 0",
      "input_schema": {
        "type": "object",
        "properties": {
          "port": {
            "type": "integer",
            "required": true
          },
          "transport": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "port",
          "transport"
        ]
      },
      "output_schema": {
        "type": "integer"
      },
      "payload_shape": {
        "request": {
          "port": "integer",
          "transport": "string"
        },
        "response": {
          "type": "integer"
        }
      },
      "explanation": "Detected Python function `main` in examples\\servers\\simple-resource\\mcp_simple_resource\\server.py",
      "possible_syscalls": [],
      "confidence": 0.26,
      "evidence": [
        "function main in examples\\servers\\simple-resource\\mcp_simple_resource\\server.py",
        "matched template: read a file from disk and return its contents (sim=0.33)"
      ]
    },
    {
      "name": "main",
      "description": "stream data over websocket. Function `main`.",
      "predicted_filename": "examples\\servers\\simple-streamablehttp\\mcp_simple_streamablehttp\\server.py",
      "predicted_code_snippet": "def main(\n    port: int,\n    log_level: str,\n    json_response: bool,\n) -> int:\n    # Configure logging\n    logging.basicConfig(\n        level=getattr(logging, log_level.upper()),\n        format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n    )\n\n    app = Server(\"mcp-streamable-http-demo\")\n\n    @app.call_tool()\n    async def call_tool(name: str, arguments: dict[str, Any]) -> list[types.ContentBlock]:\n        ctx = app.request_context\n        interval = arguments.get(\"interval\", 1.0)\n        count = arguments.get(\"count\", 5)\n        caller = arguments.get(\"caller\", \"unknown\")\n\n        # Send the specified number of notifications with the given interval\n        for i in range(count):\n            # Include more detailed message for resumability demonstration\n            notification_msg = f\"[{i + 1}/{count}] Event from '{caller}' - Use Last-Event-ID to resume if disconnected\"\n            await ctx.session.send_log_message(\n                level=\"info\",\n                data=notification_msg,\n                logger=\"notification_stream\",\n                # Associates this notification with the original request\n                # Ensures notifications are sent to the correct response stream\n                # Without this, notifications will either go to:\n                # - a standalone SSE stream (if GET request is supported)\n                # - nowhere (if GET request isn't supported)\n                related_request_id=ctx.request_id,\n            )\n            logger.debug(f\"Sent notification {i + 1}/{count} for caller: {caller}\")\n            if i < count - 1:  # Don't wait after the last notification\n                await anyio.sleep(interval)\n\n        # This will send a resource notificaiton though standalone SSE\n        # established by GET request\n        await ctx.session.send_resource_updated(uri=AnyUrl(\"http:///test_resource\"))\n        return [\n            types.TextContent(\n                type=\"text\",\n                text=(f\"Sent {count} notifications with {interval}s interval for caller: {caller}\"),\n            )\n        ]\n\n    @app.list_tools()\n    async def list_tools() -> list[types.Tool]:\n        return [\n            types.Tool(\n                name=\"start-notification-stream\",\n                description=(\"Sends a stream of notifications with configurable count and interval\"),\n                inputSchema={\n                    \"type\": \"object\",\n                    \"required\": [\"interval\", \"count\", \"caller\"],\n                    \"properties\": {\n                        \"interval\": {\n                            \"type\": \"number\",\n                            \"description\": \"Interval between notifications in seconds\",\n                        },\n                        \"count\": {\n                            \"type\": \"number\",\n                            \"description\": \"Number of notifications to send\",\n                        },\n                        \"caller\": {\n                            \"type\": \"string\",\n                            \"description\": (\"Identifier of the caller to include in notifications\"),\n                        },\n                    },\n                },\n            )\n        ]\n\n    # Create event store for resumability\n    # The InMemoryEventStore enables resumability support for StreamableHTTP transport.\n    # It stores SSE events with unique IDs, allowing clients to:\n    #   1. Receive event IDs for each SSE message\n    #   2. Resume streams by sending Last-Event-ID in GET requests\n    #   3. Replay missed events after reconnection\n    # Note: This in-memory implementation is for demonstration ONLY.\n    # For production, use a persistent storage solution.\n    event_store = InMemoryEventStore()\n\n    # Create the session manager with our app and event store\n    session_manager = StreamableHTTPSessionManager(\n        app=app,\n        event_store=event_store,  # Enable resumability\n        json_response=json_response,\n    )\n\n    # ASGI handler for streamable HTTP connections\n    async def handle_streamable_http(scope: Scope, receive: Receive, send: Send) -> None:\n        await session_manager.handle_request(scope, receive, send)\n\n    @contextlib.asynccontextmanager\n    async def lifespan(app: Starlette) -> AsyncIterator[None]:\n        \"\"\"Context manager for managing session manager lifecycle.\"\"\"\n        async with session_manager.run():\n            logger.info(\"Application started with StreamableHTTP session manager!\")\n            try:\n                yield\n            finally:\n                logger.info(\"Application shutting down...\")\n\n    # Create an ASGI application using the transport\n    starlette_app = Starlette(\n        debug=True,\n        routes=[\n            Mount(\"/mcp\", app=handle_streamable_http),\n        ],\n        lifespan=lifespan,\n    )\n\n    # Wrap ASGI application with CORS middleware to expose Mcp-Session-Id header\n    # for browser-based clients (ensures 500 errors get proper CORS headers)\n    starlette_app = CORSMiddleware(\n        starlette_app,\n        allow_origins=[\"*\"],  # Allow all origins - adjust as needed for production\n        allow_methods=[\"GET\", \"POST\", \"DELETE\"],  # MCP streamable HTTP methods\n        expose_headers=[\"Mcp-Session-Id\"],\n    )\n\n    import uvicorn\n\n    uvicorn.run(starlette_app, host=\"127.0.0.1\", port=port)\n\n    return 0",
      "input_schema": {
        "type": "object",
        "properties": {
          "port": {
            "type": "integer",
            "required": true
          },
          "log_level": {
            "type": "string",
            "required": true
          },
          "json_response": {
            "type": "boolean",
            "required": true
          }
        },
        "required": [
          "port",
          "log_level",
          "json_response"
        ]
      },
      "output_schema": {
        "type": "integer"
      },
      "payload_shape": {
        "request": {
          "port": "integer",
          "log_level": "string",
          "json_response": "boolean"
        },
        "response": {
          "type": "integer"
        }
      },
      "explanation": "Detected Python function `main` in examples\\servers\\simple-streamablehttp\\mcp_simple_streamablehttp\\server.py",
      "possible_syscalls": [],
      "confidence": 0.26,
      "evidence": [
        "function main in examples\\servers\\simple-streamablehttp\\mcp_simple_streamablehttp\\server.py",
        "matched template: stream data over websocket (sim=0.33)"
      ]
    },
    {
      "name": "main",
      "description": "stream data over websocket. Function `main`.",
      "predicted_filename": "examples\\servers\\simple-streamablehttp-stateless\\mcp_simple_streamablehttp_stateless\\server.py",
      "predicted_code_snippet": "def main(\n    port: int,\n    log_level: str,\n    json_response: bool,\n) -> int:\n    # Configure logging\n    logging.basicConfig(\n        level=getattr(logging, log_level.upper()),\n        format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n    )\n\n    app = Server(\"mcp-streamable-http-stateless-demo\")\n\n    @app.call_tool()\n    async def call_tool(name: str, arguments: dict[str, Any]) -> list[types.ContentBlock]:\n        ctx = app.request_context\n        interval = arguments.get(\"interval\", 1.0)\n        count = arguments.get(\"count\", 5)\n        caller = arguments.get(\"caller\", \"unknown\")\n\n        # Send the specified number of notifications with the given interval\n        for i in range(count):\n            await ctx.session.send_log_message(\n                level=\"info\",\n                data=f\"Notification {i + 1}/{count} from caller: {caller}\",\n                logger=\"notification_stream\",\n                related_request_id=ctx.request_id,\n            )\n            if i < count - 1:  # Don't wait after the last notification\n                await anyio.sleep(interval)\n\n        return [\n            types.TextContent(\n                type=\"text\",\n                text=(f\"Sent {count} notifications with {interval}s interval for caller: {caller}\"),\n            )\n        ]\n\n    @app.list_tools()\n    async def list_tools() -> list[types.Tool]:\n        return [\n            types.Tool(\n                name=\"start-notification-stream\",\n                description=(\"Sends a stream of notifications with configurable count and interval\"),\n                inputSchema={\n                    \"type\": \"object\",\n                    \"required\": [\"interval\", \"count\", \"caller\"],\n                    \"properties\": {\n                        \"interval\": {\n                            \"type\": \"number\",\n                            \"description\": \"Interval between notifications in seconds\",\n                        },\n                        \"count\": {\n                            \"type\": \"number\",\n                            \"description\": \"Number of notifications to send\",\n                        },\n                        \"caller\": {\n                            \"type\": \"string\",\n                            \"description\": (\"Identifier of the caller to include in notifications\"),\n                        },\n                    },\n                },\n            )\n        ]\n\n    # Create the session manager with true stateless mode\n    session_manager = StreamableHTTPSessionManager(\n        app=app,\n        event_store=None,\n        json_response=json_response,\n        stateless=True,\n    )\n\n    async def handle_streamable_http(scope: Scope, receive: Receive, send: Send) -> None:\n        await session_manager.handle_request(scope, receive, send)\n\n    @contextlib.asynccontextmanager\n    async def lifespan(app: Starlette) -> AsyncIterator[None]:\n        \"\"\"Context manager for session manager.\"\"\"\n        async with session_manager.run():\n            logger.info(\"Application started with StreamableHTTP session manager!\")\n            try:\n                yield\n            finally:\n                logger.info(\"Application shutting down...\")\n\n    # Create an ASGI application using the transport\n    starlette_app = Starlette(\n        debug=True,\n        routes=[\n            Mount(\"/mcp\", app=handle_streamable_http),\n        ],\n        lifespan=lifespan,\n    )\n\n    # Wrap ASGI application with CORS middleware to expose Mcp-Session-Id header\n    # for browser-based clients (ensures 500 errors get proper CORS headers)\n    starlette_app = CORSMiddleware(\n        starlette_app,\n        allow_origins=[\"*\"],  # Allow all origins - adjust as needed for production\n        allow_methods=[\"GET\", \"POST\", \"DELETE\"],  # MCP streamable HTTP methods\n        expose_headers=[\"Mcp-Session-Id\"],\n    )\n\n    import uvicorn\n\n    uvicorn.run(starlette_app, host=\"127.0.0.1\", port=port)\n\n    return 0",
      "input_schema": {
        "type": "object",
        "properties": {
          "port": {
            "type": "integer",
            "required": true
          },
          "log_level": {
            "type": "string",
            "required": true
          },
          "json_response": {
            "type": "boolean",
            "required": true
          }
        },
        "required": [
          "port",
          "log_level",
          "json_response"
        ]
      },
      "output_schema": {
        "type": "integer"
      },
      "payload_shape": {
        "request": {
          "port": "integer",
          "log_level": "string",
          "json_response": "boolean"
        },
        "response": {
          "type": "integer"
        }
      },
      "explanation": "Detected Python function `main` in examples\\servers\\simple-streamablehttp-stateless\\mcp_simple_streamablehttp_stateless\\server.py",
      "possible_syscalls": [],
      "confidence": 0.28,
      "evidence": [
        "function main in examples\\servers\\simple-streamablehttp-stateless\\mcp_simple_streamablehttp_stateless\\server.py",
        "matched template: stream data over websocket (sim=0.36)"
      ]
    },
    {
      "name": "main",
      "description": "handle a HTTP route request and return response. Function `main`.",
      "predicted_filename": "examples\\servers\\simple-tool\\mcp_simple_tool\\server.py",
      "predicted_code_snippet": "def main(port: int, transport: str) -> int:\n    app = Server(\"mcp-website-fetcher\")\n\n    @app.call_tool()\n    async def fetch_tool(name: str, arguments: dict[str, Any]) -> list[types.ContentBlock]:\n        if name != \"fetch\":\n            raise ValueError(f\"Unknown tool: {name}\")\n        if \"url\" not in arguments:\n            raise ValueError(\"Missing required argument 'url'\")\n        return await fetch_website(arguments[\"url\"])\n\n    @app.list_tools()\n    async def list_tools() -> list[types.Tool]:\n        return [\n            types.Tool(\n                name=\"fetch\",\n                title=\"Website Fetcher\",\n                description=\"Fetches a website and returns its content\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"required\": [\"url\"],\n                    \"properties\": {\n                        \"url\": {\n                            \"type\": \"string\",\n                            \"description\": \"URL to fetch\",\n                        }\n                    },\n                },\n            )\n        ]\n\n    if transport == \"sse\":\n        from mcp.server.sse import SseServerTransport\n        from starlette.applications import Starlette\n        from starlette.responses import Response\n        from starlette.routing import Mount, Route\n\n        sse = SseServerTransport(\"/messages/\")\n\n        async def handle_sse(request: Request):\n            async with sse.connect_sse(request.scope, request.receive, request._send) as streams:  # type: ignore[reportPrivateUsage]\n                await app.run(streams[0], streams[1], app.create_initialization_options())\n            return Response()\n\n        starlette_app = Starlette(\n            debug=True,\n            routes=[\n                Route(\"/sse\", endpoint=handle_sse, methods=[\"GET\"]),\n                Mount(\"/messages/\", app=sse.handle_post_message),\n            ],\n        )\n\n        import uvicorn\n\n        uvicorn.run(starlette_app, host=\"127.0.0.1\", port=port)\n    else:\n        from mcp.server.stdio import stdio_server\n\n        async def arun():\n            async with stdio_server() as streams:\n                await app.run(streams[0], streams[1], app.create_initialization_options())\n\n        anyio.run(arun)\n\n    return 0",
      "input_schema": {
        "type": "object",
        "properties": {
          "port": {
            "type": "integer",
            "required": true
          },
          "transport": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "port",
          "transport"
        ]
      },
      "output_schema": {
        "type": "integer"
      },
      "payload_shape": {
        "request": {
          "port": "integer",
          "transport": "string"
        },
        "response": {
          "type": "integer"
        }
      },
      "explanation": "Detected Python function `main` in examples\\servers\\simple-tool\\mcp_simple_tool\\server.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function main in examples\\servers\\simple-tool\\mcp_simple_tool\\server.py",
        "matched template: handle a HTTP route request and return response (sim=0.28)"
      ]
    },
    {
      "name": "main",
      "description": "execute a shell command. Function `main`.",
      "predicted_filename": "examples\\snippets\\clients\\completion_client.py",
      "predicted_code_snippet": "def main():\n    \"\"\"Entry point for the completion client.\"\"\"\n    asyncio.run(run())",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `main` in examples\\snippets\\clients\\completion_client.py",
      "possible_syscalls": [],
      "confidence": 0.24,
      "evidence": [
        "function main in examples\\snippets\\clients\\completion_client.py",
        "matched template: execute a shell command (sim=0.28)"
      ]
    },
    {
      "name": "main",
      "description": "execute a shell command. Function `main`.",
      "predicted_filename": "examples\\snippets\\clients\\display_utilities.py",
      "predicted_code_snippet": "def main():\n    \"\"\"Entry point for the display utilities client.\"\"\"\n    asyncio.run(run())",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `main` in examples\\snippets\\clients\\display_utilities.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function main in examples\\snippets\\clients\\display_utilities.py",
        "matched template: execute a shell command (sim=0.20)"
      ]
    },
    {
      "name": "run",
      "description": "authenticate a user and return a token. Function `run`.",
      "predicted_filename": "examples\\snippets\\clients\\oauth_client.py",
      "predicted_code_snippet": "def run():\n    asyncio.run(main())",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `run` in examples\\snippets\\clients\\oauth_client.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.26,
      "evidence": [
        "function run in examples\\snippets\\clients\\oauth_client.py",
        "matched template: authenticate a user and return a token (sim=0.32)"
      ]
    },
    {
      "name": "main",
      "description": "make an HTTP request to an external API. Function `main`.",
      "predicted_filename": "examples\\snippets\\clients\\stdio_client.py",
      "predicted_code_snippet": "def main():\n    \"\"\"Entry point for the client script.\"\"\"\n    asyncio.run(run())",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `main` in examples\\snippets\\clients\\stdio_client.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function main in examples\\snippets\\clients\\stdio_client.py",
        "matched template: make an HTTP request to an external API (sim=0.22)"
      ]
    },
    {
      "name": "review_code",
      "description": "write data to a file. Function `review_code`.",
      "predicted_filename": "examples\\snippets\\servers\\basic_prompt.py",
      "predicted_code_snippet": "def review_code(code: str) -> str:\n    return f\"Please review this code:\\n\\n{code}\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "code": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "code"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "code": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `review_code` in examples\\snippets\\servers\\basic_prompt.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function review_code in examples\\snippets\\servers\\basic_prompt.py",
        "matched template: write data to a file (sim=0.19)"
      ]
    },
    {
      "name": "debug_error",
      "description": "write data to a file. Function `debug_error`.",
      "predicted_filename": "examples\\snippets\\servers\\basic_prompt.py",
      "predicted_code_snippet": "def debug_error(error: str) -> list[base.Message]:\n    return [\n        base.UserMessage(\"I'm seeing this error:\"),\n        base.UserMessage(error),\n        base.AssistantMessage(\"I'll help debug that. What have you tried so far?\"),\n    ]",
      "input_schema": {
        "type": "object",
        "properties": {
          "error": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "error"
        ]
      },
      "output_schema": {
        "type": "array"
      },
      "payload_shape": {
        "request": {
          "error": "string"
        },
        "response": {
          "type": "array"
        }
      },
      "explanation": "Detected Python function `debug_error` in examples\\snippets\\servers\\basic_prompt.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function debug_error in examples\\snippets\\servers\\basic_prompt.py",
        "matched template: write data to a file (sim=0.16)"
      ]
    },
    {
      "name": "read_document",
      "description": "read a file from disk and return its contents. Function `read_document`.",
      "predicted_filename": "examples\\snippets\\servers\\basic_resource.py",
      "predicted_code_snippet": "def read_document(name: str) -> str:\n    \"\"\"Read a document by name.\"\"\"\n    # This would normally read from disk\n    return f\"Content of {name}\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "name"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "name": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `read_document` in examples\\snippets\\servers\\basic_resource.py",
      "possible_syscalls": [],
      "confidence": 0.3,
      "evidence": [
        "function read_document in examples\\snippets\\servers\\basic_resource.py",
        "matched template: read a file from disk and return its contents (sim=0.38)"
      ]
    },
    {
      "name": "get_settings",
      "description": "read a file from disk and return its contents. Function `get_settings`.",
      "predicted_filename": "examples\\snippets\\servers\\basic_resource.py",
      "predicted_code_snippet": "def get_settings() -> str:\n    \"\"\"Get application settings.\"\"\"\n    return \"\"\"{\n  \"theme\": \"dark\",\n  \"language\": \"en\",\n  \"debug\": false\n}\"\"\"",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `get_settings` in examples\\snippets\\servers\\basic_resource.py",
      "possible_syscalls": [],
      "confidence": 0.26,
      "evidence": [
        "function get_settings in examples\\snippets\\servers\\basic_resource.py",
        "matched template: read a file from disk and return its contents (sim=0.33)"
      ]
    },
    {
      "name": "sum",
      "description": "compute statistics (mean, median, stddev) on numeric data. Function `sum`.",
      "predicted_filename": "examples\\snippets\\servers\\basic_tool.py",
      "predicted_code_snippet": "def sum(a: int, b: int) -> int:\n    \"\"\"Add two numbers together.\"\"\"\n    return a + b",
      "input_schema": {
        "type": "object",
        "properties": {
          "a": {
            "type": "integer",
            "required": true
          },
          "b": {
            "type": "integer",
            "required": true
          }
        },
        "required": [
          "a",
          "b"
        ]
      },
      "output_schema": {
        "type": "integer"
      },
      "payload_shape": {
        "request": {
          "a": "integer",
          "b": "integer"
        },
        "response": {
          "type": "integer"
        }
      },
      "explanation": "Detected Python function `sum` in examples\\snippets\\servers\\basic_tool.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function sum in examples\\snippets\\servers\\basic_tool.py",
        "matched template: compute statistics (mean, median, stddev) on numeric data (sim=0.25)"
      ]
    },
    {
      "name": "get_weather",
      "description": "compute statistics (mean, median, stddev) on numeric data. Function `get_weather`.",
      "predicted_filename": "examples\\snippets\\servers\\basic_tool.py",
      "predicted_code_snippet": "def get_weather(city: str, unit: str = \"celsius\") -> str:\n    \"\"\"Get weather for a city.\"\"\"\n    # This would normally call a weather API\n    return f\"Weather in {city}: 22degrees{unit[0].upper()}\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "city": {
            "type": "string",
            "required": true
          },
          "unit": {
            "type": "string",
            "required": false
          }
        },
        "required": [
          "city"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "city": "string",
          "unit": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `get_weather` in examples\\snippets\\servers\\basic_tool.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function get_weather in examples\\snippets\\servers\\basic_tool.py",
        "matched template: compute statistics (mean, median, stddev) on numeric data (sim=0.21)"
      ]
    },
    {
      "name": "github_repo",
      "description": "execute a shell command. Function `github_repo`.",
      "predicted_filename": "examples\\snippets\\servers\\completion.py",
      "predicted_code_snippet": "def github_repo(owner: str, repo: str) -> str:\n    \"\"\"GitHub repository resource.\"\"\"\n    return f\"Repository: {owner}/{repo}\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "owner": {
            "type": "string",
            "required": true
          },
          "repo": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "owner",
          "repo"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "owner": "string",
          "repo": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `github_repo` in examples\\snippets\\servers\\completion.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function github_repo in examples\\snippets\\servers\\completion.py",
        "matched template: execute a shell command (sim=0.22)"
      ]
    },
    {
      "name": "review_code",
      "description": "execute a shell command. Function `review_code`.",
      "predicted_filename": "examples\\snippets\\servers\\completion.py",
      "predicted_code_snippet": "def review_code(language: str, code: str) -> str:\n    \"\"\"Generate a code review.\"\"\"\n    return f\"Review this {language} code:\\n{code}\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "language": {
            "type": "string",
            "required": true
          },
          "code": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "language",
          "code"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "language": "string",
          "code": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `review_code` in examples\\snippets\\servers\\completion.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function review_code in examples\\snippets\\servers\\completion.py",
        "matched template: execute a shell command (sim=0.21)"
      ]
    },
    {
      "name": "advanced_tool",
      "description": "parse JSON input and validate fields. Function `advanced_tool`.",
      "predicted_filename": "examples\\snippets\\servers\\direct_call_tool_result.py",
      "predicted_code_snippet": "def advanced_tool() -> CallToolResult:\n    \"\"\"Return CallToolResult directly for full control including _meta field.\"\"\"\n    return CallToolResult(\n        content=[TextContent(type=\"text\", text=\"Response visible to the model\")],\n        _meta={\"hidden\": \"data for client applications only\"},\n    )",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `advanced_tool` in examples\\snippets\\servers\\direct_call_tool_result.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function advanced_tool in examples\\snippets\\servers\\direct_call_tool_result.py",
        "matched template: parse JSON input and validate fields (sim=0.22)"
      ]
    },
    {
      "name": "validated_tool",
      "description": "parse JSON input and validate fields. Function `validated_tool`.",
      "predicted_filename": "examples\\snippets\\servers\\direct_call_tool_result.py",
      "predicted_code_snippet": "def validated_tool() -> Annotated[CallToolResult, ValidationModel]:\n    \"\"\"Return CallToolResult with structured output validation.\"\"\"\n    return CallToolResult(\n        content=[TextContent(type=\"text\", text=\"Validated response\")],\n        structuredContent={\"status\": \"success\", \"data\": {\"result\": 42}},\n        _meta={\"internal\": \"metadata\"},\n    )",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `validated_tool` in examples\\snippets\\servers\\direct_call_tool_result.py",
      "possible_syscalls": [],
      "confidence": 0.26,
      "evidence": [
        "function validated_tool in examples\\snippets\\servers\\direct_call_tool_result.py",
        "matched template: parse JSON input and validate fields (sim=0.32)"
      ]
    },
    {
      "name": "empty_result_tool",
      "description": "parse JSON input and validate fields. Function `empty_result_tool`.",
      "predicted_filename": "examples\\snippets\\servers\\direct_call_tool_result.py",
      "predicted_code_snippet": "def empty_result_tool() -> CallToolResult:\n    \"\"\"For empty results, return CallToolResult with empty content.\"\"\"\n    return CallToolResult(content=[])",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `empty_result_tool` in examples\\snippets\\servers\\direct_call_tool_result.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function empty_result_tool in examples\\snippets\\servers\\direct_call_tool_result.py",
        "matched template: parse JSON input and validate fields (sim=0.26)"
      ]
    },
    {
      "name": "hello",
      "description": "execute a shell command. Function `hello`.",
      "predicted_filename": "examples\\snippets\\servers\\direct_execution.py",
      "predicted_code_snippet": "def hello(name: str = \"World\") -> str:\n    \"\"\"Say hello to someone.\"\"\"\n    return f\"Hello, {name}!\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "required": false
          }
        },
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "name": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `hello` in examples\\snippets\\servers\\direct_execution.py",
      "possible_syscalls": [],
      "confidence": 0.27,
      "evidence": [
        "function hello in examples\\snippets\\servers\\direct_execution.py",
        "matched template: execute a shell command (sim=0.33)"
      ]
    },
    {
      "name": "main",
      "description": "execute a shell command. Function `main`.",
      "predicted_filename": "examples\\snippets\\servers\\direct_execution.py",
      "predicted_code_snippet": "def main():\n    \"\"\"Entry point for the direct execution server.\"\"\"\n    mcp.run()",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `main` in examples\\snippets\\servers\\direct_execution.py",
      "possible_syscalls": [],
      "confidence": 0.28,
      "evidence": [
        "function main in examples\\snippets\\servers\\direct_execution.py",
        "matched template: execute a shell command (sim=0.36)"
      ]
    },
    {
      "name": "add",
      "description": "execute a shell command. Function `add`.",
      "predicted_filename": "examples\\snippets\\servers\\fastmcp_quickstart.py",
      "predicted_code_snippet": "def add(a: int, b: int) -> int:\n    \"\"\"Add two numbers\"\"\"\n    return a + b",
      "input_schema": {
        "type": "object",
        "properties": {
          "a": {
            "type": "integer",
            "required": true
          },
          "b": {
            "type": "integer",
            "required": true
          }
        },
        "required": [
          "a",
          "b"
        ]
      },
      "output_schema": {
        "type": "integer"
      },
      "payload_shape": {
        "request": {
          "a": "integer",
          "b": "integer"
        },
        "response": {
          "type": "integer"
        }
      },
      "explanation": "Detected Python function `add` in examples\\snippets\\servers\\fastmcp_quickstart.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function add in examples\\snippets\\servers\\fastmcp_quickstart.py",
        "matched template: execute a shell command (sim=0.23)"
      ]
    },
    {
      "name": "get_greeting",
      "description": "execute a shell command. Function `get_greeting`.",
      "predicted_filename": "examples\\snippets\\servers\\fastmcp_quickstart.py",
      "predicted_code_snippet": "def get_greeting(name: str) -> str:\n    \"\"\"Get a personalized greeting\"\"\"\n    return f\"Hello, {name}!\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "name"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "name": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `get_greeting` in examples\\snippets\\servers\\fastmcp_quickstart.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function get_greeting in examples\\snippets\\servers\\fastmcp_quickstart.py",
        "matched template: execute a shell command (sim=0.23)"
      ]
    },
    {
      "name": "greet_user",
      "description": "execute a shell command. Function `greet_user`.",
      "predicted_filename": "examples\\snippets\\servers\\fastmcp_quickstart.py",
      "predicted_code_snippet": "def greet_user(name: str, style: str = \"friendly\") -> str:\n    \"\"\"Generate a greeting prompt\"\"\"\n    styles = {\n        \"friendly\": \"Please write a warm, friendly greeting\",\n        \"formal\": \"Please write a formal, professional greeting\",\n        \"casual\": \"Please write a casual, relaxed greeting\",\n    }\n\n    return f\"{styles.get(style, styles['friendly'])} for someone named {name}.\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "required": true
          },
          "style": {
            "type": "string",
            "required": false
          }
        },
        "required": [
          "name"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "name": "string",
          "style": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `greet_user` in examples\\snippets\\servers\\fastmcp_quickstart.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function greet_user in examples\\snippets\\servers\\fastmcp_quickstart.py",
        "matched template: execute a shell command (sim=0.19)"
      ]
    },
    {
      "name": "create_thumbnail",
      "description": "process image data (resize, crop, convert). Function `create_thumbnail`.",
      "predicted_filename": "examples\\snippets\\servers\\images.py",
      "predicted_code_snippet": "def create_thumbnail(image_path: str) -> Image:\n    \"\"\"Create a thumbnail from an image\"\"\"\n    img = PILImage.open(image_path)\n    img.thumbnail((100, 100))\n    return Image(data=img.tobytes(), format=\"png\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "image_path": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "image_path"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "image_path": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `create_thumbnail` in examples\\snippets\\servers\\images.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.34,
      "evidence": [
        "function create_thumbnail in examples\\snippets\\servers\\images.py",
        "matched template: process image data (resize, crop, convert) (sim=0.44)"
      ]
    },
    {
      "name": "query_db",
      "description": "perform database query and return records. Function `query_db`.",
      "predicted_filename": "examples\\snippets\\servers\\lifespan_example.py",
      "predicted_code_snippet": "def query_db(ctx: Context[ServerSession, AppContext]) -> str:\n    \"\"\"Tool that uses initialized resources.\"\"\"\n    db = ctx.request_context.lifespan_context.db\n    return db.query()",
      "input_schema": {
        "type": "object",
        "properties": {
          "ctx": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "ctx"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "ctx": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `query_db` in examples\\snippets\\servers\\lifespan_example.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function query_db in examples\\snippets\\servers\\lifespan_example.py",
        "matched template: perform database query and return records (sim=0.24)"
      ]
    },
    {
      "name": "greet",
      "description": "stream data over websocket. Function `greet`.",
      "predicted_filename": "examples\\snippets\\servers\\streamable_config.py",
      "predicted_code_snippet": "def greet(name: str = \"World\") -> str:\n    \"\"\"Greet someone by name.\"\"\"\n    return f\"Hello, {name}!\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "required": false
          }
        },
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "name": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `greet` in examples\\snippets\\servers\\streamable_config.py",
      "possible_syscalls": [],
      "confidence": 0.28,
      "evidence": [
        "function greet in examples\\snippets\\servers\\streamable_config.py",
        "matched template: stream data over websocket (sim=0.35)"
      ]
    },
    {
      "name": "hello",
      "description": "stream data over websocket. Function `hello`.",
      "predicted_filename": "examples\\snippets\\servers\\streamable_http_basic_mounting.py",
      "predicted_code_snippet": "def hello() -> str:\n    \"\"\"A simple hello tool\"\"\"\n    return \"Hello from MCP!\"",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `hello` in examples\\snippets\\servers\\streamable_http_basic_mounting.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function hello in examples\\snippets\\servers\\streamable_http_basic_mounting.py",
        "matched template: stream data over websocket (sim=0.26)"
      ]
    },
    {
      "name": "domain_info",
      "description": "make an HTTP request to an external API. Function `domain_info`.",
      "predicted_filename": "examples\\snippets\\servers\\streamable_http_host_mounting.py",
      "predicted_code_snippet": "def domain_info() -> str:\n    \"\"\"Get domain-specific information\"\"\"\n    return \"This is served from mcp.acme.corp\"",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `domain_info` in examples\\snippets\\servers\\streamable_http_host_mounting.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function domain_info in examples\\snippets\\servers\\streamable_http_host_mounting.py",
        "matched template: make an HTTP request to an external API (sim=0.23)"
      ]
    },
    {
      "name": "api_status",
      "description": "stream data over websocket. Function `api_status`.",
      "predicted_filename": "examples\\snippets\\servers\\streamable_http_multiple_servers.py",
      "predicted_code_snippet": "def api_status() -> str:\n    \"\"\"Get API status\"\"\"\n    return \"API is running\"",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `api_status` in examples\\snippets\\servers\\streamable_http_multiple_servers.py",
      "possible_syscalls": [],
      "confidence": 0.26,
      "evidence": [
        "function api_status in examples\\snippets\\servers\\streamable_http_multiple_servers.py",
        "matched template: stream data over websocket (sim=0.32)"
      ]
    },
    {
      "name": "send_message",
      "description": "stream data over websocket. Function `send_message`.",
      "predicted_filename": "examples\\snippets\\servers\\streamable_http_multiple_servers.py",
      "predicted_code_snippet": "def send_message(message: str) -> str:\n    \"\"\"Send a chat message\"\"\"\n    return f\"Message sent: {message}\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "message"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "message": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `send_message` in examples\\snippets\\servers\\streamable_http_multiple_servers.py",
      "possible_syscalls": [],
      "confidence": 0.28,
      "evidence": [
        "function send_message in examples\\snippets\\servers\\streamable_http_multiple_servers.py",
        "matched template: stream data over websocket (sim=0.36)"
      ]
    },
    {
      "name": "process_data",
      "description": "stream data over websocket. Function `process_data`.",
      "predicted_filename": "examples\\snippets\\servers\\streamable_http_path_config.py",
      "predicted_code_snippet": "def process_data(data: str) -> str:\n    \"\"\"Process some data\"\"\"\n    return f\"Processed: {data}\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "data": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "data"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "data": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `process_data` in examples\\snippets\\servers\\streamable_http_path_config.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function process_data in examples\\snippets\\servers\\streamable_http_path_config.py",
        "matched template: stream data over websocket (sim=0.26)"
      ]
    },
    {
      "name": "echo",
      "description": "execute a shell command. Function `echo`.",
      "predicted_filename": "examples\\snippets\\servers\\streamable_starlette_mount.py",
      "predicted_code_snippet": "def echo(message: str) -> str:\n    \"\"\"A simple echo tool\"\"\"\n    return f\"Echo: {message}\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "message"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "message": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `echo` in examples\\snippets\\servers\\streamable_starlette_mount.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function echo in examples\\snippets\\servers\\streamable_starlette_mount.py",
        "matched template: execute a shell command (sim=0.27)"
      ]
    },
    {
      "name": "add_two",
      "description": "execute a shell command. Function `add_two`.",
      "predicted_filename": "examples\\snippets\\servers\\streamable_starlette_mount.py",
      "predicted_code_snippet": "def add_two(n: int) -> int:\n    \"\"\"Tool to add two to the input\"\"\"\n    return n + 2",
      "input_schema": {
        "type": "object",
        "properties": {
          "n": {
            "type": "integer",
            "required": true
          }
        },
        "required": [
          "n"
        ]
      },
      "output_schema": {
        "type": "integer"
      },
      "payload_shape": {
        "request": {
          "n": "integer"
        },
        "response": {
          "type": "integer"
        }
      },
      "explanation": "Detected Python function `add_two` in examples\\snippets\\servers\\streamable_starlette_mount.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function add_two in examples\\snippets\\servers\\streamable_starlette_mount.py",
        "matched template: execute a shell command (sim=0.24)"
      ]
    },
    {
      "name": "get_weather",
      "description": "write data to a file. Function `get_weather`.",
      "predicted_filename": "examples\\snippets\\servers\\structured_output.py",
      "predicted_code_snippet": "def get_weather(city: str) -> WeatherData:\n    \"\"\"Get weather for a city - returns structured data.\"\"\"\n    # Simulated weather data\n    return WeatherData(\n        temperature=22.5,\n        humidity=45.0,\n        condition=\"sunny\",\n        wind_speed=5.2,\n    )",
      "input_schema": {
        "type": "object",
        "properties": {
          "city": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "city"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "city": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `get_weather` in examples\\snippets\\servers\\structured_output.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function get_weather in examples\\snippets\\servers\\structured_output.py",
        "matched template: write data to a file (sim=0.25)"
      ]
    },
    {
      "name": "get_location",
      "description": "write data to a file. Function `get_location`.",
      "predicted_filename": "examples\\snippets\\servers\\structured_output.py",
      "predicted_code_snippet": "def get_location(address: str) -> LocationInfo:\n    \"\"\"Get location coordinates\"\"\"\n    return LocationInfo(latitude=51.5074, longitude=-0.1278, name=\"London, UK\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "address": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "address"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "address": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `get_location` in examples\\snippets\\servers\\structured_output.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function get_location in examples\\snippets\\servers\\structured_output.py",
        "matched template: write data to a file (sim=0.25)"
      ]
    },
    {
      "name": "get_statistics",
      "description": "compute statistics (mean, median, stddev) on numeric data. Function `get_statistics`.",
      "predicted_filename": "examples\\snippets\\servers\\structured_output.py",
      "predicted_code_snippet": "def get_statistics(data_type: str) -> dict[str, float]:\n    \"\"\"Get various statistics\"\"\"\n    return {\"mean\": 42.5, \"median\": 40.0, \"std_dev\": 5.2}",
      "input_schema": {
        "type": "object",
        "properties": {
          "data_type": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "data_type"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "data_type": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `get_statistics` in examples\\snippets\\servers\\structured_output.py",
      "possible_syscalls": [],
      "confidence": 0.28,
      "evidence": [
        "function get_statistics in examples\\snippets\\servers\\structured_output.py",
        "matched template: compute statistics (mean, median, stddev) on numeric data (sim=0.36)"
      ]
    },
    {
      "name": "get_user",
      "description": "write data to a file. Function `get_user`.",
      "predicted_filename": "examples\\snippets\\servers\\structured_output.py",
      "predicted_code_snippet": "def get_user(user_id: str) -> UserProfile:\n    \"\"\"Get user profile - returns structured data\"\"\"\n    return UserProfile(name=\"Alice\", age=30, email=\"alice@example.com\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "user_id": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "user_id"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "user_id": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `get_user` in examples\\snippets\\servers\\structured_output.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function get_user in examples\\snippets\\servers\\structured_output.py",
        "matched template: write data to a file (sim=0.26)"
      ]
    },
    {
      "name": "get_config",
      "description": "write data to a file. Function `get_config`.",
      "predicted_filename": "examples\\snippets\\servers\\structured_output.py",
      "predicted_code_snippet": "def get_config() -> UntypedConfig:\n    \"\"\"This returns unstructured output - no schema generated\"\"\"\n    return UntypedConfig(\"value1\", \"value2\")",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `get_config` in examples\\snippets\\servers\\structured_output.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function get_config in examples\\snippets\\servers\\structured_output.py",
        "matched template: write data to a file (sim=0.23)"
      ]
    },
    {
      "name": "list_cities",
      "description": "write data to a file. Function `list_cities`.",
      "predicted_filename": "examples\\snippets\\servers\\structured_output.py",
      "predicted_code_snippet": "def list_cities() -> list[str]:\n    \"\"\"Get a list of cities\"\"\"\n    return [\"London\", \"Paris\", \"Tokyo\"]",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `list_cities` in examples\\snippets\\servers\\structured_output.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function list_cities in examples\\snippets\\servers\\structured_output.py",
        "matched template: write data to a file (sim=0.25)"
      ]
    },
    {
      "name": "get_temperature",
      "description": "write data to a file. Function `get_temperature`.",
      "predicted_filename": "examples\\snippets\\servers\\structured_output.py",
      "predicted_code_snippet": "def get_temperature(city: str) -> float:\n    \"\"\"Get temperature as a simple float\"\"\"\n    return 22.5",
      "input_schema": {
        "type": "object",
        "properties": {
          "city": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "city"
        ]
      },
      "output_schema": {
        "type": "number"
      },
      "payload_shape": {
        "request": {
          "city": "string"
        },
        "response": {
          "type": "number"
        }
      },
      "explanation": "Detected Python function `get_temperature` in examples\\snippets\\servers\\structured_output.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function get_temperature in examples\\snippets\\servers\\structured_output.py",
        "matched template: write data to a file (sim=0.24)"
      ]
    },
    {
      "name": "run_server",
      "description": "stream data over websocket. Function `run_server`.",
      "predicted_filename": "examples\\snippets\\servers\\__init__.py",
      "predicted_code_snippet": "def run_server():\n    \"\"\"Run a server by name with optional transport.\n\n    Usage: server <server-name> [transport]\n    Example: server basic_tool sse\n    \"\"\"\n    if len(sys.argv) < 2:\n        print(\"Usage: server <server-name> [transport]\")\n        print(\"Available servers: basic_tool, basic_resource, basic_prompt, tool_progress,\")\n        print(\"                   sampling, elicitation, completion, notifications,\")\n        print(\"                   fastmcp_quickstart, structured_output, images\")\n        print(\"Available transports: stdio (default), sse, streamable-http\")\n        sys.exit(1)\n\n    server_name = sys.argv[1]\n    transport = sys.argv[2] if len(sys.argv) > 2 else \"stdio\"\n\n    try:\n        module = importlib.import_module(f\".{server_name}\", package=__name__)\n        module.mcp.run(cast(Literal[\"stdio\", \"sse\", \"streamable-http\"], transport))\n    except ImportError:\n        print(f\"Error: Server '{server_name}' not found\")\n        sys.exit(1)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `run_server` in examples\\snippets\\servers\\__init__.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function run_server in examples\\snippets\\servers\\__init__.py",
        "matched template: stream data over websocket (sim=0.22)"
      ]
    },
    {
      "name": "get_github_url",
      "description": "read a file from disk and return its contents. Function `get_github_url`.",
      "predicted_filename": "scripts\\update_readme_snippets.py",
      "predicted_code_snippet": "def get_github_url(file_path: str) -> str:\n    \"\"\"Generate a GitHub URL for the file.\n\n    Args:\n        file_path: Path to the file relative to repo root\n\n    Returns:\n        GitHub URL\n    \"\"\"\n    base_url = \"https://github.com/modelcontextprotocol/python-sdk/blob/main\"\n    return f\"{base_url}/{file_path}\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "file_path": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "file_path"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "file_path": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `get_github_url` in scripts\\update_readme_snippets.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function get_github_url in scripts\\update_readme_snippets.py",
        "matched template: read a file from disk and return its contents (sim=0.12)"
      ]
    },
    {
      "name": "process_snippet_block",
      "description": "write data to a file. Function `process_snippet_block`.",
      "predicted_filename": "scripts\\update_readme_snippets.py",
      "predicted_code_snippet": "def process_snippet_block(match: re.Match[str], check_mode: bool = False) -> str:\n    \"\"\"Process a single snippet-source block.\n\n    Args:\n        match: The regex match object\n        check_mode: If True, return original if no changes needed\n\n    Returns:\n        The updated block content\n    \"\"\"\n    full_match = match.group(0)\n    indent = match.group(1)\n    file_path = match.group(2)\n\n    try:\n        # Read the entire file\n        file = Path(file_path)\n        if not file.exists():\n            print(f\"Warning: File not found: {file_path}\")\n            return full_match\n\n        code = file.read_text().rstrip()\n        github_url = get_github_url(file_path)\n\n        # Build the replacement block\n        indented_code = code.replace(\"\\n\", f\"\\n{indent}\")\n        replacement = f\"\"\"{indent}<!-- snippet-source {file_path} -->\n{indent}```python\n{indent}{indented_code}\n{indent}```\n\n{indent}_Full example: [{file_path}]({github_url})_\n{indent}<!-- /snippet-source -->\"\"\"\n\n        # In check mode, only check if code has changed\n        if check_mode:\n            # Extract existing code from the match\n            existing_content = match.group(3)\n            if existing_content is not None:\n                existing_lines = existing_content.strip().split(\"\\n\")\n                # Find code between ```python and ```\n                code_lines = []\n                in_code = False\n                for line in existing_lines:\n                    if line.strip() == \"```python\":\n                        in_code = True\n                    elif line.strip() == \"```\":\n                        break\n                    elif in_code:\n                        code_lines.append(line)\n                existing_code = \"\\n\".join(code_lines).strip()\n                # Compare with the indented version we would generate\n                expected_code = code.replace(\"\\n\", f\"\\n{indent}\").strip()\n                if existing_code == expected_code:\n                    return full_match\n\n        return replacement\n\n    except Exception as e:\n        print(f\"Error processing {file_path}: {e}\")\n        return full_match",
      "input_schema": {
        "type": "object",
        "properties": {
          "match": {
            "type": "string",
            "required": true
          },
          "check_mode": {
            "type": "boolean",
            "required": false
          }
        },
        "required": [
          "match"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "match": "string",
          "check_mode": "boolean"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `process_snippet_block` in scripts\\update_readme_snippets.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function process_snippet_block in scripts\\update_readme_snippets.py",
        "matched template: write data to a file (sim=0.23)"
      ]
    },
    {
      "name": "update_readme_snippets",
      "description": "write data to a file. Function `update_readme_snippets`.",
      "predicted_filename": "scripts\\update_readme_snippets.py",
      "predicted_code_snippet": "def update_readme_snippets(readme_path: Path = Path(\"README.md\"), check_mode: bool = False) -> bool:\n    \"\"\"Update code snippets in README.md with live code from source files.\n\n    Args:\n        readme_path: Path to the README file\n        check_mode: If True, only check if updates are needed without modifying\n\n    Returns:\n        True if file is up to date or was updated, False if check failed\n    \"\"\"\n    if not readme_path.exists():\n        print(f\"Error: README file not found: {readme_path}\")\n        return False\n\n    content = readme_path.read_text()\n    original_content = content\n\n    # Pattern to match snippet-source blocks\n    # Matches: <!-- snippet-source path/to/file.py -->\n    #          ... any content ...\n    #          <!-- /snippet-source -->\n    pattern = r\"^(\\s*)<!-- snippet-source ([^\\s]+) -->\\n\" r\"(.*?)\" r\"^\\1<!-- /snippet-source -->\"\n\n    # Process all snippet-source blocks\n    updated_content = re.sub(\n        pattern, lambda m: process_snippet_block(m, check_mode), content, flags=re.MULTILINE | re.DOTALL\n    )\n\n    if check_mode:\n        if updated_content != original_content:\n            print(\n                f\"Error: {readme_path} has outdated code snippets. \"\n                \"Run 'python scripts/update_readme_snippets.py' to update.\"\n            )\n            return False\n        else:\n            print(f\"\u2713 {readme_path} code snippets are up to date\")\n            return True\n    else:\n        if updated_content != original_content:\n            readme_path.write_text(updated_content)\n            print(f\"\u2713 Updated {readme_path}\")\n        else:\n            print(f\"\u2713 {readme_path} already up to date\")\n        return True",
      "input_schema": {
        "type": "object",
        "properties": {
          "readme_path": {
            "type": "string",
            "required": false
          },
          "check_mode": {
            "type": "boolean",
            "required": false
          }
        },
        "required": []
      },
      "output_schema": {
        "type": "boolean"
      },
      "payload_shape": {
        "request": {
          "readme_path": "string",
          "check_mode": "boolean"
        },
        "response": {
          "type": "boolean"
        }
      },
      "explanation": "Detected Python function `update_readme_snippets` in scripts\\update_readme_snippets.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function update_readme_snippets in scripts\\update_readme_snippets.py",
        "matched template: write data to a file (sim=0.22)"
      ]
    },
    {
      "name": "main",
      "description": "validate and sanitize user input. Function `main`.",
      "predicted_filename": "scripts\\update_readme_snippets.py",
      "predicted_code_snippet": "def main():\n    \"\"\"Main entry point.\"\"\"\n    parser = argparse.ArgumentParser(description=\"Update README code snippets from source files\")\n    parser.add_argument(\n        \"--check\", action=\"store_true\", help=\"Check mode - verify snippets are up to date without modifying\"\n    )\n    parser.add_argument(\"--readme\", default=\"README.md\", help=\"Path to README file (default: README.md)\")\n\n    args = parser.parse_args()\n\n    success = update_readme_snippets(Path(args.readme), check_mode=args.check)\n\n    if not success:\n        sys.exit(1)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `main` in scripts\\update_readme_snippets.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function main in scripts\\update_readme_snippets.py",
        "matched template: validate and sanitize user input (sim=0.24)"
      ]
    },
    {
      "name": "get_claude_config_path",
      "description": "list files in a directory. Function `get_claude_config_path`.",
      "predicted_filename": "src\\mcp\\cli\\claude.py",
      "predicted_code_snippet": "def get_claude_config_path() -> Path | None:  # pragma: no cover\n    \"\"\"Get the Claude config directory based on platform.\"\"\"\n    if sys.platform == \"win32\":\n        path = Path(Path.home(), \"AppData\", \"Roaming\", \"Claude\")\n    elif sys.platform == \"darwin\":\n        path = Path(Path.home(), \"Library\", \"Application Support\", \"Claude\")\n    elif sys.platform.startswith(\"linux\"):\n        path = Path(os.environ.get(\"XDG_CONFIG_HOME\", Path.home() / \".config\"), \"Claude\")\n    else:\n        return None\n\n    if path.exists():\n        return path\n    return None",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `get_claude_config_path` in src\\mcp\\cli\\claude.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function get_claude_config_path in src\\mcp\\cli\\claude.py",
        "matched template: list files in a directory (sim=0.24)"
      ]
    },
    {
      "name": "get_uv_path",
      "description": "execute a shell command. Function `get_uv_path`.",
      "predicted_filename": "src\\mcp\\cli\\claude.py",
      "predicted_code_snippet": "def get_uv_path() -> str:\n    \"\"\"Get the full path to the uv executable.\"\"\"\n    uv_path = shutil.which(\"uv\")\n    if not uv_path:  # pragma: no cover\n        logger.error(\n            \"uv executable not found in PATH, falling back to 'uv'. Please ensure uv is installed and in your PATH\"\n        )\n        return \"uv\"  # Fall back to just \"uv\" if not found\n    return uv_path",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `get_uv_path` in src\\mcp\\cli\\claude.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function get_uv_path in src\\mcp\\cli\\claude.py",
        "matched template: execute a shell command (sim=0.18)"
      ]
    },
    {
      "name": "update_claude_config",
      "description": "execute a shell command. Function `update_claude_config`.",
      "predicted_filename": "src\\mcp\\cli\\claude.py",
      "predicted_code_snippet": "def update_claude_config(\n    file_spec: str,\n    server_name: str,\n    *,\n    with_editable: Path | None = None,\n    with_packages: list[str] | None = None,\n    env_vars: dict[str, str] | None = None,\n) -> bool:\n    \"\"\"Add or update a FastMCP server in Claude's configuration.\n\n    Args:\n        file_spec: Path to the server file, optionally with :object suffix\n        server_name: Name for the server in Claude's config\n        with_editable: Optional directory to install in editable mode\n        with_packages: Optional list of additional packages to install\n        env_vars: Optional dictionary of environment variables. These are merged with\n            any existing variables, with new values taking precedence.\n\n    Raises:\n        RuntimeError: If Claude Desktop's config directory is not found, indicating\n            Claude Desktop may not be installed or properly set up.\n    \"\"\"\n    config_dir = get_claude_config_path()\n    uv_path = get_uv_path()\n    if not config_dir:  # pragma: no cover\n        raise RuntimeError(\n            \"Claude Desktop config directory not found. Please ensure Claude Desktop\"\n            \" is installed and has been run at least once to initialize its config.\"\n        )\n\n    config_file = config_dir / \"claude_desktop_config.json\"\n    if not config_file.exists():  # pragma: no cover\n        try:\n            config_file.write_text(\"{}\")\n        except Exception:\n            logger.exception(\n                \"Failed to create Claude config file\",\n                extra={\n                    \"config_file\": str(config_file),\n                },\n            )\n            return False\n\n    try:\n        config = json.loads(config_file.read_text())\n        if \"mcpServers\" not in config:\n            config[\"mcpServers\"] = {}\n\n        # Always preserve existing env vars and merge with new ones\n        if server_name in config[\"mcpServers\"] and \"env\" in config[\"mcpServers\"][server_name]:  # pragma: no cover\n            existing_env = config[\"mcpServers\"][server_name][\"env\"]\n            if env_vars:\n                # New vars take precedence over existing ones\n                env_vars = {**existing_env, **env_vars}\n            else:\n                env_vars = existing_env\n\n        # Build uv run command\n        args = [\"run\", \"--frozen\"]\n\n        # Collect all packages in a set to deduplicate\n        packages = {MCP_PACKAGE}\n        if with_packages:  # pragma: no cover\n            packages.update(pkg for pkg in with_packages if pkg)\n\n        # Add all packages with --with\n        for pkg in sorted(packages):\n            args.extend([\"--with\", pkg])\n\n        if with_editable:  # pragma: no cover\n            args.extend([\"--with-editable\", str(with_editable)])\n\n        # Convert file path to absolute before adding to command\n        # Split off any :object suffix first\n        if \":\" in file_spec:\n            file_path, server_object = file_spec.rsplit(\":\", 1)\n            file_spec = f\"{Path(file_path).resolve()}:{server_object}\"\n        else:  # pragma: no cover\n            file_spec = str(Path(file_spec).resolve())\n\n        # Add fastmcp run command\n        args.extend([\"mcp\", \"run\", file_spec])\n\n        server_config: dict[str, Any] = {\"command\": uv_path, \"args\": args}\n\n        # Add environment variables if specified\n        if env_vars:  # pragma: no cover\n            server_config[\"env\"] = env_vars\n\n        config[\"mcpServers\"][server_name] = server_config\n\n        config_file.write_text(json.dumps(config, indent=2))\n        logger.info(\n            f\"Added server '{server_name}' to Claude config\",\n            extra={\"config_file\": str(config_file)},\n        )\n        return True\n    except Exception:  # pragma: no cover\n        logger.exception(\n            \"Failed to update Claude config\",\n            extra={\n                \"config_file\": str(config_file),\n            },\n        )\n        return False",
      "input_schema": {
        "type": "object",
        "properties": {
          "file_spec": {
            "type": "string",
            "required": true
          },
          "server_name": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "file_spec",
          "server_name"
        ]
      },
      "output_schema": {
        "type": "boolean"
      },
      "payload_shape": {
        "request": {
          "file_spec": "string",
          "server_name": "string"
        },
        "response": {
          "type": "boolean"
        }
      },
      "explanation": "Detected Python function `update_claude_config` in src\\mcp\\cli\\claude.py",
      "possible_syscalls": [],
      "confidence": 0.16,
      "evidence": [
        "function update_claude_config in src\\mcp\\cli\\claude.py",
        "matched template: execute a shell command (sim=0.08)"
      ]
    },
    {
      "name": "_get_npx_command",
      "description": "execute a shell command. Function `_get_npx_command`.",
      "predicted_filename": "src\\mcp\\cli\\cli.py",
      "predicted_code_snippet": "def _get_npx_command():\n    \"\"\"Get the correct npx command for the current platform.\"\"\"\n    if sys.platform == \"win32\":\n        # Try both npx.cmd and npx.exe on Windows\n        for cmd in [\"npx.cmd\", \"npx.exe\", \"npx\"]:\n            try:\n                subprocess.run([cmd, \"--version\"], check=True, capture_output=True, shell=True)\n                return cmd\n            except subprocess.CalledProcessError:\n                continue\n        return None\n    return \"npx\"",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `_get_npx_command` in src\\mcp\\cli\\cli.py",
      "possible_syscalls": [
        {
          "syscall": "execve/system",
          "reason": "calls to subprocess or os.system"
        }
      ],
      "confidence": 0.24,
      "evidence": [
        "function _get_npx_command in src\\mcp\\cli\\cli.py",
        "matched template: execute a shell command (sim=0.30)"
      ]
    },
    {
      "name": "_parse_env_var",
      "description": "execute a shell command. Function `_parse_env_var`.",
      "predicted_filename": "src\\mcp\\cli\\cli.py",
      "predicted_code_snippet": "def _parse_env_var(env_var: str) -> tuple[str, str]:  # pragma: no cover\n    \"\"\"Parse environment variable string in format KEY=VALUE.\"\"\"\n    if \"=\" not in env_var:\n        logger.error(f\"Invalid environment variable format: {env_var}. Must be KEY=VALUE\")\n        sys.exit(1)\n    key, value = env_var.split(\"=\", 1)\n    return key.strip(), value.strip()",
      "input_schema": {
        "type": "object",
        "properties": {
          "env_var": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "env_var"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "env_var": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `_parse_env_var` in src\\mcp\\cli\\cli.py",
      "possible_syscalls": [
        {
          "syscall": "execve/system",
          "reason": "calls to subprocess or os.system"
        }
      ],
      "confidence": 0.2,
      "evidence": [
        "function _parse_env_var in src\\mcp\\cli\\cli.py",
        "matched template: execute a shell command (sim=0.21)"
      ]
    },
    {
      "name": "_build_uv_command",
      "description": "execute a shell command. Function `_build_uv_command`.",
      "predicted_filename": "src\\mcp\\cli\\cli.py",
      "predicted_code_snippet": "def _build_uv_command(\n    file_spec: str,\n    with_editable: Path | None = None,\n    with_packages: list[str] | None = None,\n) -> list[str]:\n    \"\"\"Build the uv run command that runs an MCP server through mcp run.\"\"\"\n    cmd = [\"uv\"]\n\n    cmd.extend([\"run\", \"--with\", \"mcp\"])\n\n    if with_editable:\n        cmd.extend([\"--with-editable\", str(with_editable)])\n\n    if with_packages:\n        for pkg in with_packages:\n            if pkg:  # pragma: no cover\n                cmd.extend([\"--with\", pkg])\n\n    # Add mcp run command\n    cmd.extend([\"mcp\", \"run\", file_spec])\n    return cmd",
      "input_schema": {
        "type": "object",
        "properties": {
          "file_spec": {
            "type": "string",
            "required": true
          },
          "with_editable": {
            "type": "string",
            "required": false
          },
          "with_packages": {
            "type": "string",
            "required": false
          }
        },
        "required": [
          "file_spec"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "file_spec": "string",
          "with_editable": "string",
          "with_packages": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `_build_uv_command` in src\\mcp\\cli\\cli.py",
      "possible_syscalls": [
        {
          "syscall": "execve/system",
          "reason": "calls to subprocess or os.system"
        }
      ],
      "confidence": 0.24,
      "evidence": [
        "function _build_uv_command in src\\mcp\\cli\\cli.py",
        "matched template: execute a shell command (sim=0.29)"
      ]
    },
    {
      "name": "_parse_file_path",
      "description": "read a file from disk and return its contents. Function `_parse_file_path`.",
      "predicted_filename": "src\\mcp\\cli\\cli.py",
      "predicted_code_snippet": "def _parse_file_path(file_spec: str) -> tuple[Path, str | None]:\n    \"\"\"Parse a file path that may include a server object specification.\n\n    Args:\n        file_spec: Path to file, optionally with :object suffix\n\n    Returns:\n        Tuple of (file_path, server_object)\n    \"\"\"\n    # First check if we have a Windows path (e.g., C:\\...)\n    has_windows_drive = len(file_spec) > 1 and file_spec[1] == \":\"\n\n    # Split on the last colon, but only if it's not part of the Windows drive letter\n    # and there's actually another colon in the string after the drive letter\n    if \":\" in (file_spec[2:] if has_windows_drive else file_spec):\n        file_str, server_object = file_spec.rsplit(\":\", 1)\n    else:\n        file_str, server_object = file_spec, None\n\n    # Resolve the file path\n    file_path = Path(file_str).expanduser().resolve()\n    if not file_path.exists():\n        logger.error(f\"File not found: {file_path}\")\n        sys.exit(1)\n    if not file_path.is_file():\n        logger.error(f\"Not a file: {file_path}\")\n        sys.exit(1)\n\n    return file_path, server_object",
      "input_schema": {
        "type": "object",
        "properties": {
          "file_spec": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "file_spec"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "file_spec": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `_parse_file_path` in src\\mcp\\cli\\cli.py",
      "possible_syscalls": [
        {
          "syscall": "execve/system",
          "reason": "calls to subprocess or os.system"
        }
      ],
      "confidence": 0.23,
      "evidence": [
        "function _parse_file_path in src\\mcp\\cli\\cli.py",
        "matched template: read a file from disk and return its contents (sim=0.28)"
      ]
    },
    {
      "name": "_import_server",
      "description": "list files in a directory. Function `_import_server`.",
      "predicted_filename": "src\\mcp\\cli\\cli.py",
      "predicted_code_snippet": "def _import_server(file: Path, server_object: str | None = None):  # pragma: no cover\n    \"\"\"Import an MCP server from a file.\n\n    Args:\n        file: Path to the file\n        server_object: Optional object name in format \"module:object\" or just \"object\"\n\n    Returns:\n        The server object\n    \"\"\"\n    # Add parent directory to Python path so imports can be resolved\n    file_dir = str(file.parent)\n    if file_dir not in sys.path:\n        sys.path.insert(0, file_dir)\n\n    # Import the module\n    spec = importlib.util.spec_from_file_location(\"server_module\", file)\n    if not spec or not spec.loader:\n        logger.error(\"Could not load module\", extra={\"file\": str(file)})\n        sys.exit(1)\n\n    module = importlib.util.module_from_spec(spec)\n    spec.loader.exec_module(module)\n\n    def _check_server_object(server_object: Any, object_name: str):\n        \"\"\"Helper function to check that the server object is supported\n\n        Args:\n            server_object: The server object to check.\n\n        Returns:\n            True if it's supported.\n        \"\"\"\n        if not isinstance(server_object, FastMCP):\n            logger.error(f\"The server object {object_name} is of type {type(server_object)} (expecting {FastMCP}).\")\n            if isinstance(server_object, LowLevelServer):\n                logger.warning(\n                    \"Note that only FastMCP server is supported. Low level Server class is not yet supported.\"\n                )\n            return False\n        return True\n\n    # If no object specified, try common server names\n    if not server_object:\n        # Look for the most common server object names\n        for name in [\"mcp\", \"server\", \"app\"]:\n            if hasattr(module, name):\n                if not _check_server_object(getattr(module, name), f\"{file}:{name}\"):\n                    logger.error(f\"Ignoring object '{file}:{name}' as it's not a valid server object\")\n                    continue\n                return getattr(module, name)\n\n        logger.error(\n            f\"No server object found in {file}. Please either:\\n\"\n            \"1. Use a standard variable name (mcp, server, or app)\\n\"\n            \"2. Specify the object name with file:object syntax\"\n            \"3. If the server creates the FastMCP object within main() \"\n            \"   or another function, refactor the FastMCP object to be a \"\n            \"   global variable named mcp, server, or app.\",\n            extra={\"file\": str(file)},\n        )\n        sys.exit(1)\n\n    # Handle module:object syntax\n    if \":\" in server_object:\n        module_name, object_name = server_object.split(\":\", 1)\n        try:\n            server_module = importlib.import_module(module_name)\n            server = getattr(server_module, object_name, None)\n        except ImportError:\n            logger.error(\n                f\"Could not import module '{module_name}'\",\n                extra={\"file\": str(file)},\n            )\n            sys.exit(1)\n    else:\n        # Just object name\n        server = getattr(module, server_object, None)\n\n    if server is None:\n        logger.error(\n            f\"Server object '{server_object}' not found\",\n            extra={\"file\": str(file)},\n        )\n        sys.exit(1)\n\n    if not _check_server_object(server, server_object):\n        sys.exit(1)\n\n    return server",
      "input_schema": {
        "type": "object",
        "properties": {
          "file": {
            "type": "string",
            "required": true
          },
          "server_object": {
            "type": "string",
            "required": false
          }
        },
        "required": [
          "file"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "file": "string",
          "server_object": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `_import_server` in src\\mcp\\cli\\cli.py",
      "possible_syscalls": [
        {
          "syscall": "execve/system",
          "reason": "calls to subprocess or os.system"
        }
      ],
      "confidence": 0.19,
      "evidence": [
        "function _import_server in src\\mcp\\cli\\cli.py",
        "matched template: list files in a directory (sim=0.19)"
      ]
    },
    {
      "name": "version",
      "description": "execute a shell command. Function `version`.",
      "predicted_filename": "src\\mcp\\cli\\cli.py",
      "predicted_code_snippet": "def version() -> None:  # pragma: no cover\n    \"\"\"Show the MCP version.\"\"\"\n    try:\n        version = importlib.metadata.version(\"mcp\")\n        print(f\"MCP version {version}\")\n    except importlib.metadata.PackageNotFoundError:\n        print(\"MCP version unknown (package not installed)\")\n        sys.exit(1)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `version` in src\\mcp\\cli\\cli.py",
      "possible_syscalls": [
        {
          "syscall": "execve/system",
          "reason": "calls to subprocess or os.system"
        }
      ],
      "confidence": 0.17,
      "evidence": [
        "function version in src\\mcp\\cli\\cli.py",
        "matched template: execute a shell command (sim=0.13)"
      ]
    },
    {
      "name": "dev",
      "description": "execute a shell command. Function `dev`.",
      "predicted_filename": "src\\mcp\\cli\\cli.py",
      "predicted_code_snippet": "def dev(\n    file_spec: str = typer.Argument(\n        ...,\n        help=\"Python file to run, optionally with :object suffix\",\n    ),\n    with_editable: Annotated[\n        Path | None,\n        typer.Option(\n            \"--with-editable\",\n            \"-e\",\n            help=\"Directory containing pyproject.toml to install in editable mode\",\n            exists=True,\n            file_okay=False,\n            resolve_path=True,\n        ),\n    ] = None,\n    with_packages: Annotated[\n        list[str],\n        typer.Option(\n            \"--with\",\n            help=\"Additional packages to install\",\n        ),\n    ] = [],\n) -> None:  # pragma: no cover\n    \"\"\"Run an MCP server with the MCP Inspector.\"\"\"\n    file, server_object = _parse_file_path(file_spec)\n\n    logger.debug(\n        \"Starting dev server\",\n        extra={\n            \"file\": str(file),\n            \"server_object\": server_object,\n            \"with_editable\": str(with_editable) if with_editable else None,\n            \"with_packages\": with_packages,\n        },\n    )\n\n    try:\n        # Import server to get dependencies\n        server = _import_server(file, server_object)\n        if hasattr(server, \"dependencies\"):\n            with_packages = list(set(with_packages + server.dependencies))\n\n        uv_cmd = _build_uv_command(file_spec, with_editable, with_packages)\n\n        # Get the correct npx command\n        npx_cmd = _get_npx_command()\n        if not npx_cmd:\n            logger.error(\n                \"npx not found. Please ensure Node.js and npm are properly installed and added to your system PATH.\"\n            )\n            sys.exit(1)\n\n        # Run the MCP Inspector command with shell=True on Windows\n        shell = sys.platform == \"win32\"\n        process = subprocess.run(\n            [npx_cmd, \"@modelcontextprotocol/inspector\"] + uv_cmd,\n            check=True,\n            shell=shell,\n            env=dict(os.environ.items()),  # Convert to list of tuples for env update\n        )\n        sys.exit(process.returncode)\n    except subprocess.CalledProcessError as e:\n        logger.error(\n            \"Dev server failed\",\n            extra={\n                \"file\": str(file),\n                \"error\": str(e),\n                \"returncode\": e.returncode,\n            },\n        )\n        sys.exit(e.returncode)\n    except FileNotFoundError:\n        logger.error(\n            \"npx not found. Please ensure Node.js and npm are properly installed \"\n            \"and added to your system PATH. You may need to restart your terminal \"\n            \"after installation.\",\n            extra={\"file\": str(file)},\n        )\n        sys.exit(1)",
      "input_schema": {
        "type": "object",
        "properties": {
          "file_spec": {
            "type": "string",
            "required": false
          },
          "with_editable": {
            "type": "string",
            "required": false
          },
          "with_packages": {
            "type": "string",
            "required": false
          }
        },
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "file_spec": "string",
          "with_editable": "string",
          "with_packages": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `dev` in src\\mcp\\cli\\cli.py",
      "possible_syscalls": [
        {
          "syscall": "execve/system",
          "reason": "calls to subprocess or os.system"
        }
      ],
      "confidence": 0.18,
      "evidence": [
        "function dev in src\\mcp\\cli\\cli.py",
        "matched template: execute a shell command (sim=0.15)"
      ]
    },
    {
      "name": "run",
      "description": "write data to a file. Function `run`.",
      "predicted_filename": "src\\mcp\\cli\\cli.py",
      "predicted_code_snippet": "def run(\n    file_spec: str = typer.Argument(\n        ...,\n        help=\"Python file to run, optionally with :object suffix\",\n    ),\n    transport: Annotated[\n        str | None,\n        typer.Option(\n            \"--transport\",\n            \"-t\",\n            help=\"Transport protocol to use (stdio or sse)\",\n        ),\n    ] = None,\n) -> None:  # pragma: no cover\n    \"\"\"Run an MCP server.\n\n    The server can be specified in two ways:\\n\n    1. Module approach: server.py - runs the module directly, expecting a server.run() call.\\n\n    2. Import approach: server.py:app - imports and runs the specified server object.\\n\\n\n\n    Note: This command runs the server directly. You are responsible for ensuring\n    all dependencies are available.\\n\n    For dependency management, use `mcp install` or `mcp dev` instead.\n    \"\"\"  # noqa: E501\n    file, server_object = _parse_file_path(file_spec)\n\n    logger.debug(\n        \"Running server\",\n        extra={\n            \"file\": str(file),\n            \"server_object\": server_object,\n            \"transport\": transport,\n        },\n    )\n\n    try:\n        # Import and get server object\n        server = _import_server(file, server_object)\n\n        # Run the server\n        kwargs = {}\n        if transport:\n            kwargs[\"transport\"] = transport\n\n        server.run(**kwargs)\n\n    except Exception:\n        logger.exception(\n            \"Failed to run server\",\n            extra={\n                \"file\": str(file),\n            },\n        )\n        sys.exit(1)",
      "input_schema": {
        "type": "object",
        "properties": {
          "file_spec": {
            "type": "string",
            "required": false
          },
          "transport": {
            "type": "string",
            "required": false
          }
        },
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "file_spec": "string",
          "transport": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `run` in src\\mcp\\cli\\cli.py",
      "possible_syscalls": [
        {
          "syscall": "execve/system",
          "reason": "calls to subprocess or os.system"
        }
      ],
      "confidence": 0.21,
      "evidence": [
        "function run in src\\mcp\\cli\\cli.py",
        "matched template: write data to a file (sim=0.23)"
      ]
    },
    {
      "name": "install",
      "description": "execute a shell command. Function `install`.",
      "predicted_filename": "src\\mcp\\cli\\cli.py",
      "predicted_code_snippet": "def install(\n    file_spec: str = typer.Argument(\n        ...,\n        help=\"Python file to run, optionally with :object suffix\",\n    ),\n    server_name: Annotated[\n        str | None,\n        typer.Option(\n            \"--name\",\n            \"-n\",\n            help=\"Custom name for the server (defaults to server's name attribute or file name)\",\n        ),\n    ] = None,\n    with_editable: Annotated[\n        Path | None,\n        typer.Option(\n            \"--with-editable\",\n            \"-e\",\n            help=\"Directory containing pyproject.toml to install in editable mode\",\n            exists=True,\n            file_okay=False,\n            resolve_path=True,\n        ),\n    ] = None,\n    with_packages: Annotated[\n        list[str],\n        typer.Option(\n            \"--with\",\n            help=\"Additional packages to install\",\n        ),\n    ] = [],\n    env_vars: Annotated[\n        list[str],\n        typer.Option(\n            \"--env-var\",\n            \"-v\",\n            help=\"Environment variables in KEY=VALUE format\",\n        ),\n    ] = [],\n    env_file: Annotated[\n        Path | None,\n        typer.Option(\n            \"--env-file\",\n            \"-f\",\n            help=\"Load environment variables from a .env file\",\n            exists=True,\n            file_okay=True,\n            dir_okay=False,\n            resolve_path=True,\n        ),\n    ] = None,\n) -> None:  # pragma: no cover\n    \"\"\"Install an MCP server in the Claude desktop app.\n\n    Environment variables are preserved once added and only updated if new values\n    are explicitly provided.\n    \"\"\"\n    file, server_object = _parse_file_path(file_spec)\n\n    logger.debug(\n        \"Installing server\",\n        extra={\n            \"file\": str(file),\n            \"server_name\": server_name,\n            \"server_object\": server_object,\n            \"with_editable\": str(with_editable) if with_editable else None,\n            \"with_packages\": with_packages,\n        },\n    )\n\n    if not claude.get_claude_config_path():\n        logger.error(\"Claude app not found\")\n        sys.exit(1)\n\n    # Try to import server to get its name, but fall back to file name if dependencies\n    # missing\n    name = server_name\n    server = None\n    if not name:\n        try:\n            server = _import_server(file, server_object)\n            name = server.name\n        except (ImportError, ModuleNotFoundError) as e:\n            logger.debug(\n                \"Could not import server (likely missing dependencies), using file name\",\n                extra={\"error\": str(e)},\n            )\n            name = file.stem\n\n    # Get server dependencies if available\n    server_dependencies = getattr(server, \"dependencies\", []) if server else []\n    if server_dependencies:\n        with_packages = list(set(with_packages + server_dependencies))\n\n    # Process environment variables if provided\n    env_dict: dict[str, str] | None = None\n    if env_file or env_vars:\n        env_dict = {}\n        # Load from .env file if specified\n        if env_file:\n            if dotenv:\n                try:\n                    env_dict |= {k: v for k, v in dotenv.dotenv_values(env_file).items() if v is not None}\n                except (OSError, ValueError):\n                    logger.exception(\"Failed to load .env file\")\n                    sys.exit(1)\n            else:\n                logger.error(\"python-dotenv is not installed. Cannot load .env file.\")\n                sys.exit(1)\n\n        # Add command line environment variables\n        for env_var in env_vars:\n            key, value = _parse_env_var(env_var)\n            env_dict[key] = value\n\n    if claude.update_claude_config(\n        file_spec,\n        name,\n        with_editable=with_editable,\n        with_packages=with_packages,\n        env_vars=env_dict,\n    ):\n        logger.info(f\"Successfully installed {name} in Claude app\")\n    else:\n        logger.error(f\"Failed to install {name} in Claude app\")\n        sys.exit(1)",
      "input_schema": {
        "type": "object",
        "properties": {
          "file_spec": {
            "type": "string",
            "required": false
          },
          "server_name": {
            "type": "string",
            "required": false
          },
          "with_editable": {
            "type": "string",
            "required": false
          },
          "with_packages": {
            "type": "string",
            "required": false
          },
          "env_vars": {
            "type": "string",
            "required": false
          },
          "env_file": {
            "type": "string",
            "required": false
          }
        },
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "file_spec": "string",
          "server_name": "string",
          "with_editable": "string",
          "with_packages": "string",
          "env_vars": "string",
          "env_file": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `install` in src\\mcp\\cli\\cli.py",
      "possible_syscalls": [
        {
          "syscall": "execve/system",
          "reason": "calls to subprocess or os.system"
        }
      ],
      "confidence": 0.18,
      "evidence": [
        "function install in src\\mcp\\cli\\cli.py",
        "matched template: execute a shell command (sim=0.15)"
      ]
    },
    {
      "name": "remove_request_params",
      "description": "make an HTTP request to an external API. Function `remove_request_params`.",
      "predicted_filename": "src\\mcp\\client\\sse.py",
      "predicted_code_snippet": "def remove_request_params(url: str) -> str:\n    return urljoin(url, urlparse(url).path)",
      "input_schema": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "url"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "url": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `remove_request_params` in src\\mcp\\client\\sse.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.23,
      "evidence": [
        "function remove_request_params in src\\mcp\\client\\sse.py",
        "matched template: make an HTTP request to an external API (sim=0.27)"
      ]
    },
    {
      "name": "cli",
      "description": "execute a shell command. Function `cli`.",
      "predicted_filename": "src\\mcp\\client\\__main__.py",
      "predicted_code_snippet": "def cli():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\"command_or_url\", help=\"Command or URL to connect to\")\n    parser.add_argument(\"args\", nargs=\"*\", help=\"Additional arguments\")\n    parser.add_argument(\n        \"-e\",\n        \"--env\",\n        nargs=2,\n        action=\"append\",\n        metavar=(\"KEY\", \"VALUE\"),\n        help=\"Environment variables to set. Can be used multiple times.\",\n        default=[],\n    )\n\n    args = parser.parse_args()\n    anyio.run(partial(main, args.command_or_url, args.args, args.env), backend=\"trio\")",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `cli` in src\\mcp\\client\\__main__.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.26,
      "evidence": [
        "function cli in src\\mcp\\client\\__main__.py",
        "matched template: execute a shell command (sim=0.32)"
      ]
    },
    {
      "name": "extract_field_from_www_auth",
      "description": "parse JSON input and validate fields. Function `extract_field_from_www_auth`.",
      "predicted_filename": "src\\mcp\\client\\auth\\utils.py",
      "predicted_code_snippet": "def extract_field_from_www_auth(response: Response, field_name: str) -> str | None:\n    \"\"\"\n    Extract field from WWW-Authenticate header.\n\n    Returns:\n        Field value if found in WWW-Authenticate header, None otherwise\n    \"\"\"\n    www_auth_header = response.headers.get(\"WWW-Authenticate\")\n    if not www_auth_header:\n        return None\n\n    # Pattern matches: field_name=\"value\" or field_name=value (unquoted)\n    pattern = rf'{field_name}=(?:\"([^\"]+)\"|([^\\s,]+))'\n    match = re.search(pattern, www_auth_header)\n\n    if match:\n        # Return quoted value if present, otherwise unquoted value\n        return match.group(1) or match.group(2)\n\n    return None",
      "input_schema": {
        "type": "object",
        "properties": {
          "response": {
            "type": "string",
            "required": true
          },
          "field_name": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "response",
          "field_name"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "response": "string",
          "field_name": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `extract_field_from_www_auth` in src\\mcp\\client\\auth\\utils.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.29,
      "evidence": [
        "function extract_field_from_www_auth in src\\mcp\\client\\auth\\utils.py",
        "matched template: parse JSON input and validate fields (sim=0.37)"
      ]
    },
    {
      "name": "extract_scope_from_www_auth",
      "description": "make an HTTP request to an external API. Function `extract_scope_from_www_auth`.",
      "predicted_filename": "src\\mcp\\client\\auth\\utils.py",
      "predicted_code_snippet": "def extract_scope_from_www_auth(response: Response) -> str | None:\n    \"\"\"\n    Extract scope parameter from WWW-Authenticate header as per RFC6750.\n\n    Returns:\n        Scope string if found in WWW-Authenticate header, None otherwise\n    \"\"\"\n    return extract_field_from_www_auth(response, \"scope\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "response": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "response"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "response": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `extract_scope_from_www_auth` in src\\mcp\\client\\auth\\utils.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.24,
      "evidence": [
        "function extract_scope_from_www_auth in src\\mcp\\client\\auth\\utils.py",
        "matched template: make an HTTP request to an external API (sim=0.29)"
      ]
    },
    {
      "name": "extract_resource_metadata_from_www_auth",
      "description": "make an HTTP request to an external API. Function `extract_resource_metadata_from_www_auth`.",
      "predicted_filename": "src\\mcp\\client\\auth\\utils.py",
      "predicted_code_snippet": "def extract_resource_metadata_from_www_auth(response: Response) -> str | None:\n    \"\"\"\n    Extract protected resource metadata URL from WWW-Authenticate header as per RFC9728.\n\n    Returns:\n        Resource metadata URL if found in WWW-Authenticate header, None otherwise\n    \"\"\"\n    if not response or response.status_code != 401:\n        return None  # pragma: no cover\n\n    return extract_field_from_www_auth(response, \"resource_metadata\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "response": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "response"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "response": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `extract_resource_metadata_from_www_auth` in src\\mcp\\client\\auth\\utils.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.27,
      "evidence": [
        "function extract_resource_metadata_from_www_auth in src\\mcp\\client\\auth\\utils.py",
        "matched template: make an HTTP request to an external API (sim=0.34)"
      ]
    },
    {
      "name": "build_protected_resource_metadata_discovery_urls",
      "description": "make an HTTP request to an external API. Function `build_protected_resource_metadata_discovery_urls`.",
      "predicted_filename": "src\\mcp\\client\\auth\\utils.py",
      "predicted_code_snippet": "def build_protected_resource_metadata_discovery_urls(www_auth_url: str | None, server_url: str) -> list[str]:\n    \"\"\"\n    Build ordered list of URLs to try for protected resource metadata discovery.\n\n    Per SEP-985, the client MUST:\n    1. Try resource_metadata from WWW-Authenticate header (if present)\n    2. Fall back to path-based well-known URI: /.well-known/oauth-protected-resource/{path}\n    3. Fall back to root-based well-known URI: /.well-known/oauth-protected-resource\n\n    Args:\n        www_auth_url: optional resource_metadata url extracted from the WWW-Authenticate header\n        server_url: server url\n\n    Returns:\n        Ordered list of URLs to try for discovery\n    \"\"\"\n    urls: list[str] = []\n\n    # Priority 1: WWW-Authenticate header with resource_metadata parameter\n    if www_auth_url:\n        urls.append(www_auth_url)\n\n    # Priority 2-3: Well-known URIs (RFC 9728)\n    parsed = urlparse(server_url)\n    base_url = f\"{parsed.scheme}://{parsed.netloc}\"\n\n    # Priority 2: Path-based well-known URI (if server has a path component)\n    if parsed.path and parsed.path != \"/\":\n        path_based_url = urljoin(base_url, f\"/.well-known/oauth-protected-resource{parsed.path}\")\n        urls.append(path_based_url)\n\n    # Priority 3: Root-based well-known URI\n    root_based_url = urljoin(base_url, \"/.well-known/oauth-protected-resource\")\n    urls.append(root_based_url)\n\n    return urls",
      "input_schema": {
        "type": "object",
        "properties": {
          "www_auth_url": {
            "type": "string",
            "required": true
          },
          "server_url": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "www_auth_url",
          "server_url"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "www_auth_url": "string",
          "server_url": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `build_protected_resource_metadata_discovery_urls` in src\\mcp\\client\\auth\\utils.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.28,
      "evidence": [
        "function build_protected_resource_metadata_discovery_urls in src\\mcp\\client\\auth\\utils.py",
        "matched template: make an HTTP request to an external API (sim=0.36)"
      ]
    },
    {
      "name": "get_client_metadata_scopes",
      "description": "authenticate a user and return a token. Function `get_client_metadata_scopes`.",
      "predicted_filename": "src\\mcp\\client\\auth\\utils.py",
      "predicted_code_snippet": "def get_client_metadata_scopes(\n    www_authenticate_scope: str | None,\n    protected_resource_metadata: ProtectedResourceMetadata | None,\n    authorization_server_metadata: OAuthMetadata | None = None,\n) -> str | None:\n    \"\"\"Select scopes as outlined in the 'Scope Selection Strategy' in the MCP spec.\"\"\"\n    # Per MCP spec, scope selection priority order:\n    # 1. Use scope from WWW-Authenticate header (if provided)\n    # 2. Use all scopes from PRM scopes_supported (if available)\n    # 3. Omit scope parameter if neither is available\n\n    if www_authenticate_scope is not None:\n        # Priority 1: WWW-Authenticate header scope\n        return www_authenticate_scope\n    elif protected_resource_metadata is not None and protected_resource_metadata.scopes_supported is not None:\n        # Priority 2: PRM scopes_supported\n        return \" \".join(protected_resource_metadata.scopes_supported)\n    elif authorization_server_metadata is not None and authorization_server_metadata.scopes_supported is not None:\n        return \" \".join(authorization_server_metadata.scopes_supported)  # pragma: no cover\n    else:\n        # Priority 3: Omit scope parameter\n        return None",
      "input_schema": {
        "type": "object",
        "properties": {
          "www_authenticate_scope": {
            "type": "string",
            "required": true
          },
          "protected_resource_metadata": {
            "type": "string",
            "required": true
          },
          "authorization_server_metadata": {
            "type": "string",
            "required": false
          }
        },
        "required": [
          "www_authenticate_scope",
          "protected_resource_metadata"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "www_authenticate_scope": "string",
          "protected_resource_metadata": "string",
          "authorization_server_metadata": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `get_client_metadata_scopes` in src\\mcp\\client\\auth\\utils.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.2,
      "evidence": [
        "function get_client_metadata_scopes in src\\mcp\\client\\auth\\utils.py",
        "matched template: authenticate a user and return a token (sim=0.21)"
      ]
    },
    {
      "name": "build_oauth_authorization_server_metadata_discovery_urls",
      "description": "authenticate a user and return a token. Function `build_oauth_authorization_server_metadata_discovery_urls`.",
      "predicted_filename": "src\\mcp\\client\\auth\\utils.py",
      "predicted_code_snippet": "def build_oauth_authorization_server_metadata_discovery_urls(auth_server_url: str | None, server_url: str) -> list[str]:\n    \"\"\"\n    Generate ordered list of (url, type) tuples for discovery attempts.\n\n    Args:\n        auth_server_url: URL for the OAuth Authorization Metadata URL if found, otherwise None\n        server_url: URL for the MCP server, used as a fallback if auth_server_url is None\n    \"\"\"\n\n    if not auth_server_url:\n        # Legacy path using the 2025-03-26 spec:\n        # link: https://modelcontextprotocol.io/specification/2025-03-26/basic/authorization\n        parsed = urlparse(server_url)\n        return [f\"{parsed.scheme}://{parsed.netloc}/.well-known/oauth-authorization-server\"]\n\n    urls: list[str] = []\n    parsed = urlparse(auth_server_url)\n    base_url = f\"{parsed.scheme}://{parsed.netloc}\"\n\n    # RFC 8414: Path-aware OAuth discovery\n    if parsed.path and parsed.path != \"/\":\n        oauth_path = f\"/.well-known/oauth-authorization-server{parsed.path.rstrip('/')}\"\n        urls.append(urljoin(base_url, oauth_path))\n\n        # RFC 8414 section 5: Path-aware OIDC discovery\n        # See https://www.rfc-editor.org/rfc/rfc8414.html#section-5\n        oidc_path = f\"/.well-known/openid-configuration{parsed.path.rstrip('/')}\"\n        urls.append(urljoin(base_url, oidc_path))\n\n        # https://openid.net/specs/openid-connect-discovery-1_0.html\n        oidc_path = f\"{parsed.path.rstrip('/')}/.well-known/openid-configuration\"\n        urls.append(urljoin(base_url, oidc_path))\n        return urls\n\n    # OAuth root\n    urls.append(urljoin(base_url, \"/.well-known/oauth-authorization-server\"))\n\n    # OIDC 1.0 fallback (appends to full URL per OIDC spec)\n    # https://openid.net/specs/openid-connect-discovery-1_0.html\n    urls.append(urljoin(base_url, \"/.well-known/openid-configuration\"))\n\n    return urls",
      "input_schema": {
        "type": "object",
        "properties": {
          "auth_server_url": {
            "type": "string",
            "required": true
          },
          "server_url": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "auth_server_url",
          "server_url"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "auth_server_url": "string",
          "server_url": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `build_oauth_authorization_server_metadata_discovery_urls` in src\\mcp\\client\\auth\\utils.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.21,
      "evidence": [
        "function build_oauth_authorization_server_metadata_discovery_urls in src\\mcp\\client\\auth\\utils.py",
        "matched template: authenticate a user and return a token (sim=0.24)"
      ]
    },
    {
      "name": "create_oauth_metadata_request",
      "description": "make an HTTP request to an external API. Function `create_oauth_metadata_request`.",
      "predicted_filename": "src\\mcp\\client\\auth\\utils.py",
      "predicted_code_snippet": "def create_oauth_metadata_request(url: str) -> Request:\n    return Request(\"GET\", url, headers={MCP_PROTOCOL_VERSION: LATEST_PROTOCOL_VERSION})",
      "input_schema": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "url"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "url": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `create_oauth_metadata_request` in src\\mcp\\client\\auth\\utils.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.25,
      "evidence": [
        "function create_oauth_metadata_request in src\\mcp\\client\\auth\\utils.py",
        "matched template: make an HTTP request to an external API (sim=0.31)"
      ]
    },
    {
      "name": "create_client_registration_request",
      "description": "make an HTTP request to an external API. Function `create_client_registration_request`.",
      "predicted_filename": "src\\mcp\\client\\auth\\utils.py",
      "predicted_code_snippet": "def create_client_registration_request(\n    auth_server_metadata: OAuthMetadata | None, client_metadata: OAuthClientMetadata, auth_base_url: str\n) -> Request:\n    \"\"\"Build registration request or skip if already registered.\"\"\"\n\n    if auth_server_metadata and auth_server_metadata.registration_endpoint:\n        registration_url = str(auth_server_metadata.registration_endpoint)\n    else:\n        registration_url = urljoin(auth_base_url, \"/register\")\n\n    registration_data = client_metadata.model_dump(by_alias=True, mode=\"json\", exclude_none=True)\n\n    return Request(\"POST\", registration_url, json=registration_data, headers={\"Content-Type\": \"application/json\"})",
      "input_schema": {
        "type": "object",
        "properties": {
          "auth_server_metadata": {
            "type": "string",
            "required": true
          },
          "client_metadata": {
            "type": "string",
            "required": true
          },
          "auth_base_url": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "auth_server_metadata",
          "client_metadata",
          "auth_base_url"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "auth_server_metadata": "string",
          "client_metadata": "string",
          "auth_base_url": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `create_client_registration_request` in src\\mcp\\client\\auth\\utils.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.3,
      "evidence": [
        "function create_client_registration_request in src\\mcp\\client\\auth\\utils.py",
        "matched template: make an HTTP request to an external API (sim=0.39)"
      ]
    },
    {
      "name": "get_default_environment",
      "description": "execute a shell command. Function `get_default_environment`.",
      "predicted_filename": "src\\mcp\\client\\stdio\\__init__.py",
      "predicted_code_snippet": "def get_default_environment() -> dict[str, str]:\n    \"\"\"\n    Returns a default environment object including only environment variables deemed\n    safe to inherit.\n    \"\"\"\n    env: dict[str, str] = {}\n\n    for key in DEFAULT_INHERITED_ENV_VARS:\n        value = os.environ.get(key)\n        if value is None:\n            continue  # pragma: no cover\n\n        if value.startswith(\"()\"):  # pragma: no cover\n            # Skip functions, which are a security risk\n            continue  # pragma: no cover\n\n        env[key] = value\n\n    return env",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `get_default_environment` in src\\mcp\\client\\stdio\\__init__.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function get_default_environment in src\\mcp\\client\\stdio\\__init__.py",
        "matched template: execute a shell command (sim=0.20)"
      ]
    },
    {
      "name": "_get_executable_command",
      "description": "execute a shell command. Function `_get_executable_command`.",
      "predicted_filename": "src\\mcp\\client\\stdio\\__init__.py",
      "predicted_code_snippet": "def _get_executable_command(command: str) -> str:\n    \"\"\"\n    Get the correct executable command normalized for the current platform.\n\n    Args:\n        command: Base command (e.g., 'uvx', 'npx')\n\n    Returns:\n        str: Platform-appropriate command\n    \"\"\"\n    if sys.platform == \"win32\":  # pragma: no cover\n        return get_windows_executable_command(command)\n    else:\n        return command",
      "input_schema": {
        "type": "object",
        "properties": {
          "command": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "command"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "command": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `_get_executable_command` in src\\mcp\\client\\stdio\\__init__.py",
      "possible_syscalls": [],
      "confidence": 0.33,
      "evidence": [
        "function _get_executable_command in src\\mcp\\client\\stdio\\__init__.py",
        "matched template: execute a shell command (sim=0.42)"
      ]
    },
    {
      "name": "get_windows_executable_command",
      "description": "execute a shell command. Function `get_windows_executable_command`.",
      "predicted_filename": "src\\mcp\\os\\win32\\utilities.py",
      "predicted_code_snippet": "def get_windows_executable_command(command: str) -> str:\n    \"\"\"\n    Get the correct executable command normalized for Windows.\n\n    On Windows, commands might exist with specific extensions (.exe, .cmd, etc.)\n    that need to be located for proper execution.\n\n    Args:\n        command: Base command (e.g., 'uvx', 'npx')\n\n    Returns:\n        str: Windows-appropriate command path\n    \"\"\"\n    try:\n        # First check if command exists in PATH as-is\n        if command_path := shutil.which(command):\n            return command_path\n\n        # Check for Windows-specific extensions\n        for ext in [\".cmd\", \".bat\", \".exe\", \".ps1\"]:\n            ext_version = f\"{command}{ext}\"\n            if ext_path := shutil.which(ext_version):\n                return ext_path\n\n        # For regular commands or if we couldn't find special versions\n        return command\n    except OSError:\n        # Handle file system errors during path resolution\n        # (permissions, broken symlinks, etc.)\n        return command",
      "input_schema": {
        "type": "object",
        "properties": {
          "command": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "command"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "command": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `get_windows_executable_command` in src\\mcp\\os\\win32\\utilities.py",
      "possible_syscalls": [
        {
          "syscall": "execve/system",
          "reason": "calls to subprocess or os.system"
        }
      ],
      "confidence": 0.3,
      "evidence": [
        "function get_windows_executable_command in src\\mcp\\os\\win32\\utilities.py",
        "matched template: execute a shell command (sim=0.39)"
      ]
    },
    {
      "name": "_create_job_object",
      "description": "execute a shell command. Function `_create_job_object`.",
      "predicted_filename": "src\\mcp\\os\\win32\\utilities.py",
      "predicted_code_snippet": "def _create_job_object() -> int | None:\n    \"\"\"\n    Create a Windows Job Object configured to terminate all processes when closed.\n    \"\"\"\n    if sys.platform != \"win32\" or not win32job:\n        return None\n\n    try:\n        job = win32job.CreateJobObject(None, \"\")\n        extended_info = win32job.QueryInformationJobObject(job, win32job.JobObjectExtendedLimitInformation)\n\n        extended_info[\"BasicLimitInformation\"][\"LimitFlags\"] |= win32job.JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE\n        win32job.SetInformationJobObject(job, win32job.JobObjectExtendedLimitInformation, extended_info)\n        return job\n    except Exception as e:\n        logger.warning(f\"Failed to create Job Object for process tree management: {e}\")\n        return None",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "integer"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "integer"
        }
      },
      "explanation": "Detected Python function `_create_job_object` in src\\mcp\\os\\win32\\utilities.py",
      "possible_syscalls": [
        {
          "syscall": "execve/system",
          "reason": "calls to subprocess or os.system"
        }
      ],
      "confidence": 0.19,
      "evidence": [
        "function _create_job_object in src\\mcp\\os\\win32\\utilities.py",
        "matched template: execute a shell command (sim=0.20)"
      ]
    },
    {
      "name": "_maybe_assign_process_to_job",
      "description": "execute a shell command. Function `_maybe_assign_process_to_job`.",
      "predicted_filename": "src\\mcp\\os\\win32\\utilities.py",
      "predicted_code_snippet": "def _maybe_assign_process_to_job(process: Process | FallbackProcess, job: JobHandle | None) -> None:\n    \"\"\"\n    Try to assign a process to a job object. If assignment fails\n    for any reason, the job handle is closed.\n    \"\"\"\n    if not job:\n        return\n\n    if sys.platform != \"win32\" or not win32api or not win32con or not win32job:\n        return\n\n    try:\n        process_handle = win32api.OpenProcess(\n            win32con.PROCESS_SET_QUOTA | win32con.PROCESS_TERMINATE, False, process.pid\n        )\n        if not process_handle:\n            raise Exception(\"Failed to open process handle\")\n\n        try:\n            win32job.AssignProcessToJobObject(job, process_handle)\n            process._job_object = job\n        finally:\n            win32api.CloseHandle(process_handle)\n    except Exception as e:\n        logger.warning(f\"Failed to assign process {process.pid} to Job Object: {e}\")\n        if win32api:\n            win32api.CloseHandle(job)",
      "input_schema": {
        "type": "object",
        "properties": {
          "process": {
            "type": "string",
            "required": true
          },
          "job": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "process",
          "job"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "process": "string",
          "job": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `_maybe_assign_process_to_job` in src\\mcp\\os\\win32\\utilities.py",
      "possible_syscalls": [
        {
          "syscall": "execve/system",
          "reason": "calls to subprocess or os.system"
        }
      ],
      "confidence": 0.21,
      "evidence": [
        "function _maybe_assign_process_to_job in src\\mcp\\os\\win32\\utilities.py",
        "matched template: execute a shell command (sim=0.22)"
      ]
    },
    {
      "name": "_validate_elicitation_schema",
      "description": "parse JSON input and validate fields. Function `_validate_elicitation_schema`.",
      "predicted_filename": "src\\mcp\\server\\elicitation.py",
      "predicted_code_snippet": "def _validate_elicitation_schema(schema: type[BaseModel]) -> None:\n    \"\"\"Validate that a Pydantic model only contains primitive field types.\"\"\"\n    for field_name, field_info in schema.model_fields.items():\n        if not _is_primitive_field(field_info):\n            raise TypeError(\n                f\"Elicitation schema field '{field_name}' must be a primitive type \"\n                f\"{_ELICITATION_PRIMITIVE_TYPES} or Optional of these types. \"\n                f\"Complex types like lists, dicts, or nested models are not allowed.\"\n            )",
      "input_schema": {
        "type": "object",
        "properties": {
          "schema": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "schema"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "schema": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `_validate_elicitation_schema` in src\\mcp\\server\\elicitation.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function _validate_elicitation_schema in src\\mcp\\server\\elicitation.py",
        "matched template: parse JSON input and validate fields (sim=0.25)"
      ]
    },
    {
      "name": "_is_primitive_field",
      "description": "parse JSON input and validate fields. Function `_is_primitive_field`.",
      "predicted_filename": "src\\mcp\\server\\elicitation.py",
      "predicted_code_snippet": "def _is_primitive_field(field_info: FieldInfo) -> bool:\n    \"\"\"Check if a field is a primitive type allowed in elicitation schemas.\"\"\"\n    annotation = field_info.annotation\n\n    # Handle None type\n    if annotation is types.NoneType:  # pragma: no cover\n        return True\n\n    # Handle basic primitive types\n    if annotation in _ELICITATION_PRIMITIVE_TYPES:\n        return True\n\n    # Handle Union types\n    origin = get_origin(annotation)\n    if origin is Union or origin is types.UnionType:\n        args = get_args(annotation)\n        # All args must be primitive types or None\n        return all(arg is types.NoneType or arg in _ELICITATION_PRIMITIVE_TYPES for arg in args)\n\n    return False",
      "input_schema": {
        "type": "object",
        "properties": {
          "field_info": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "field_info"
        ]
      },
      "output_schema": {
        "type": "boolean"
      },
      "payload_shape": {
        "request": {
          "field_info": "string"
        },
        "response": {
          "type": "boolean"
        }
      },
      "explanation": "Detected Python function `_is_primitive_field` in src\\mcp\\server\\elicitation.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function _is_primitive_field in src\\mcp\\server\\elicitation.py",
        "matched template: parse JSON input and validate fields (sim=0.13)"
      ]
    },
    {
      "name": "stringify_pydantic_error",
      "description": "validate and sanitize user input. Function `stringify_pydantic_error`.",
      "predicted_filename": "src\\mcp\\server\\auth\\errors.py",
      "predicted_code_snippet": "def stringify_pydantic_error(validation_error: ValidationError) -> str:\n    return \"\\n\".join(f\"{'.'.join(str(loc) for loc in e['loc'])}: {e['msg']}\" for e in validation_error.errors())",
      "input_schema": {
        "type": "object",
        "properties": {
          "validation_error": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "validation_error"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "validation_error": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `stringify_pydantic_error` in src\\mcp\\server\\auth\\errors.py",
      "possible_syscalls": [],
      "confidence": 0.26,
      "evidence": [
        "function stringify_pydantic_error in src\\mcp\\server\\auth\\errors.py",
        "matched template: validate and sanitize user input (sim=0.32)"
      ]
    },
    {
      "name": "construct_redirect_uri",
      "description": "handle a HTTP route request and return response. Function `construct_redirect_uri`.",
      "predicted_filename": "src\\mcp\\server\\auth\\provider.py",
      "predicted_code_snippet": "def construct_redirect_uri(redirect_uri_base: str, **params: str | None) -> str:\n    parsed_uri = urlparse(redirect_uri_base)\n    query_params = [(k, v) for k, vs in parse_qs(parsed_uri.query).items() for v in vs]\n    for k, v in params.items():\n        if v is not None:\n            query_params.append((k, v))\n\n    redirect_uri = urlunparse(parsed_uri._replace(query=urlencode(query_params)))\n    return redirect_uri",
      "input_schema": {
        "type": "object",
        "properties": {
          "redirect_uri_base": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "redirect_uri_base"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "redirect_uri_base": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `construct_redirect_uri` in src\\mcp\\server\\auth\\provider.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.23,
      "evidence": [
        "function construct_redirect_uri in src\\mcp\\server\\auth\\provider.py",
        "matched template: handle a HTTP route request and return response (sim=0.26)"
      ]
    },
    {
      "name": "validate_issuer_url",
      "description": "make an HTTP request to an external API. Function `validate_issuer_url`.",
      "predicted_filename": "src\\mcp\\server\\auth\\routes.py",
      "predicted_code_snippet": "def validate_issuer_url(url: AnyHttpUrl):\n    \"\"\"\n    Validate that the issuer URL meets OAuth 2.0 requirements.\n\n    Args:\n        url: The issuer URL to validate\n\n    Raises:\n        ValueError: If the issuer URL is invalid\n    \"\"\"\n\n    # RFC 8414 requires HTTPS, but we allow localhost HTTP for testing\n    if (\n        url.scheme != \"https\"\n        and url.host != \"localhost\"\n        and (url.host is not None and not url.host.startswith(\"127.0.0.1\"))\n    ):\n        raise ValueError(\"Issuer URL must be HTTPS\")  # pragma: no cover\n\n    # No fragments or query parameters allowed\n    if url.fragment:\n        raise ValueError(\"Issuer URL must not have a fragment\")  # pragma: no cover\n    if url.query:\n        raise ValueError(\"Issuer URL must not have a query string\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "url"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "url": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `validate_issuer_url` in src\\mcp\\server\\auth\\routes.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.3,
      "evidence": [
        "function validate_issuer_url in src\\mcp\\server\\auth\\routes.py",
        "matched template: make an HTTP request to an external API (sim=0.38)"
      ]
    },
    {
      "name": "cors_middleware",
      "description": "make an HTTP request to an external API. Function `cors_middleware`.",
      "predicted_filename": "src\\mcp\\server\\auth\\routes.py",
      "predicted_code_snippet": "def cors_middleware(\n    handler: Callable[[Request], Response | Awaitable[Response]],\n    allow_methods: list[str],\n) -> ASGIApp:\n    cors_app = CORSMiddleware(\n        app=request_response(handler),\n        allow_origins=\"*\",\n        allow_methods=allow_methods,\n        allow_headers=[MCP_PROTOCOL_VERSION_HEADER],\n    )\n    return cors_app",
      "input_schema": {
        "type": "object",
        "properties": {
          "handler": {
            "type": "string",
            "required": true
          },
          "allow_methods": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "handler",
          "allow_methods"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "handler": "string",
          "allow_methods": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `cors_middleware` in src\\mcp\\server\\auth\\routes.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.32,
      "evidence": [
        "function cors_middleware in src\\mcp\\server\\auth\\routes.py",
        "matched template: make an HTTP request to an external API (sim=0.41)"
      ]
    },
    {
      "name": "create_auth_routes",
      "description": "make an HTTP request to an external API. Function `create_auth_routes`.",
      "predicted_filename": "src\\mcp\\server\\auth\\routes.py",
      "predicted_code_snippet": "def create_auth_routes(\n    provider: OAuthAuthorizationServerProvider[Any, Any, Any],\n    issuer_url: AnyHttpUrl,\n    service_documentation_url: AnyHttpUrl | None = None,\n    client_registration_options: ClientRegistrationOptions | None = None,\n    revocation_options: RevocationOptions | None = None,\n) -> list[Route]:\n    validate_issuer_url(issuer_url)\n\n    client_registration_options = client_registration_options or ClientRegistrationOptions()\n    revocation_options = revocation_options or RevocationOptions()\n    metadata = build_metadata(\n        issuer_url,\n        service_documentation_url,\n        client_registration_options,\n        revocation_options,\n    )\n    client_authenticator = ClientAuthenticator(provider)\n\n    # Create routes\n    # Allow CORS requests for endpoints meant to be hit by the OAuth client\n    # (with the client secret). This is intended to support things like MCP Inspector,\n    # where the client runs in a web browser.\n    routes = [\n        Route(\n            \"/.well-known/oauth-authorization-server\",\n            endpoint=cors_middleware(\n                MetadataHandler(metadata).handle,\n                [\"GET\", \"OPTIONS\"],\n            ),\n            methods=[\"GET\", \"OPTIONS\"],\n        ),\n        Route(\n            AUTHORIZATION_PATH,\n            # do not allow CORS for authorization endpoint;\n            # clients should just redirect to this\n            endpoint=AuthorizationHandler(provider).handle,\n            methods=[\"GET\", \"POST\"],\n        ),\n        Route(\n            TOKEN_PATH,\n            endpoint=cors_middleware(\n                TokenHandler(provider, client_authenticator).handle,\n                [\"POST\", \"OPTIONS\"],\n            ),\n            methods=[\"POST\", \"OPTIONS\"],\n        ),\n    ]\n\n    if client_registration_options.enabled:  # pragma: no branch\n        registration_handler = RegistrationHandler(\n            provider,\n            options=client_registration_options,\n        )\n        routes.append(\n            Route(\n                REGISTRATION_PATH,\n                endpoint=cors_middleware(\n                    registration_handler.handle,\n                    [\"POST\", \"OPTIONS\"],\n                ),\n                methods=[\"POST\", \"OPTIONS\"],\n            )\n        )\n\n    if revocation_options.enabled:  # pragma: no branch\n        revocation_handler = RevocationHandler(provider, client_authenticator)\n        routes.append(\n            Route(\n                REVOCATION_PATH,\n                endpoint=cors_middleware(\n                    revocation_handler.handle,\n                    [\"POST\", \"OPTIONS\"],\n                ),\n                methods=[\"POST\", \"OPTIONS\"],\n            )\n        )\n\n    return routes",
      "input_schema": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "required": true
          },
          "issuer_url": {
            "type": "string",
            "required": true
          },
          "service_documentation_url": {
            "type": "string",
            "required": false
          },
          "client_registration_options": {
            "type": "string",
            "required": false
          },
          "revocation_options": {
            "type": "string",
            "required": false
          }
        },
        "required": [
          "provider",
          "issuer_url"
        ]
      },
      "output_schema": {
        "type": "array"
      },
      "payload_shape": {
        "request": {
          "provider": "string",
          "issuer_url": "string",
          "service_documentation_url": "string",
          "client_registration_options": "string",
          "revocation_options": "string"
        },
        "response": {
          "type": "array"
        }
      },
      "explanation": "Detected Python function `create_auth_routes` in src\\mcp\\server\\auth\\routes.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.26,
      "evidence": [
        "function create_auth_routes in src\\mcp\\server\\auth\\routes.py",
        "matched template: make an HTTP request to an external API (sim=0.33)"
      ]
    },
    {
      "name": "build_metadata",
      "description": "make an HTTP request to an external API. Function `build_metadata`.",
      "predicted_filename": "src\\mcp\\server\\auth\\routes.py",
      "predicted_code_snippet": "def build_metadata(\n    issuer_url: AnyHttpUrl,\n    service_documentation_url: AnyHttpUrl | None,\n    client_registration_options: ClientRegistrationOptions,\n    revocation_options: RevocationOptions,\n) -> OAuthMetadata:\n    authorization_url = AnyHttpUrl(str(issuer_url).rstrip(\"/\") + AUTHORIZATION_PATH)\n    token_url = AnyHttpUrl(str(issuer_url).rstrip(\"/\") + TOKEN_PATH)\n\n    # Create metadata\n    metadata = OAuthMetadata(\n        issuer=issuer_url,\n        authorization_endpoint=authorization_url,\n        token_endpoint=token_url,\n        scopes_supported=client_registration_options.valid_scopes,\n        response_types_supported=[\"code\"],\n        response_modes_supported=None,\n        grant_types_supported=[\"authorization_code\", \"refresh_token\"],\n        token_endpoint_auth_methods_supported=[\"client_secret_post\"],\n        token_endpoint_auth_signing_alg_values_supported=None,\n        service_documentation=service_documentation_url,\n        ui_locales_supported=None,\n        op_policy_uri=None,\n        op_tos_uri=None,\n        introspection_endpoint=None,\n        code_challenge_methods_supported=[\"S256\"],\n    )\n\n    # Add registration endpoint if supported\n    if client_registration_options.enabled:  # pragma: no branch\n        metadata.registration_endpoint = AnyHttpUrl(str(issuer_url).rstrip(\"/\") + REGISTRATION_PATH)\n\n    # Add revocation endpoint if supported\n    if revocation_options.enabled:  # pragma: no branch\n        metadata.revocation_endpoint = AnyHttpUrl(str(issuer_url).rstrip(\"/\") + REVOCATION_PATH)\n        metadata.revocation_endpoint_auth_methods_supported = [\"client_secret_post\"]\n\n    return metadata",
      "input_schema": {
        "type": "object",
        "properties": {
          "issuer_url": {
            "type": "string",
            "required": true
          },
          "service_documentation_url": {
            "type": "string",
            "required": true
          },
          "client_registration_options": {
            "type": "string",
            "required": true
          },
          "revocation_options": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "issuer_url",
          "service_documentation_url",
          "client_registration_options",
          "revocation_options"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "issuer_url": "string",
          "service_documentation_url": "string",
          "client_registration_options": "string",
          "revocation_options": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `build_metadata` in src\\mcp\\server\\auth\\routes.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.29,
      "evidence": [
        "function build_metadata in src\\mcp\\server\\auth\\routes.py",
        "matched template: make an HTTP request to an external API (sim=0.37)"
      ]
    },
    {
      "name": "build_resource_metadata_url",
      "description": "make an HTTP request to an external API. Function `build_resource_metadata_url`.",
      "predicted_filename": "src\\mcp\\server\\auth\\routes.py",
      "predicted_code_snippet": "def build_resource_metadata_url(resource_server_url: AnyHttpUrl) -> AnyHttpUrl:\n    \"\"\"\n    Build RFC 9728 compliant protected resource metadata URL.\n\n    Inserts /.well-known/oauth-protected-resource between host and resource path\n    as specified in RFC 9728 \u00a73.1.\n\n    Args:\n        resource_server_url: The resource server URL (e.g., https://example.com/mcp)\n\n    Returns:\n        The metadata URL (e.g., https://example.com/.well-known/oauth-protected-resource/mcp)\n    \"\"\"\n    parsed = urlparse(str(resource_server_url))\n    # Handle trailing slash: if path is just \"/\", treat as empty\n    resource_path = parsed.path if parsed.path != \"/\" else \"\"\n    return AnyHttpUrl(f\"{parsed.scheme}://{parsed.netloc}/.well-known/oauth-protected-resource{resource_path}\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "resource_server_url": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "resource_server_url"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "resource_server_url": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `build_resource_metadata_url` in src\\mcp\\server\\auth\\routes.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.27,
      "evidence": [
        "function build_resource_metadata_url in src\\mcp\\server\\auth\\routes.py",
        "matched template: make an HTTP request to an external API (sim=0.33)"
      ]
    },
    {
      "name": "create_protected_resource_routes",
      "description": "make an HTTP request to an external API. Function `create_protected_resource_routes`.",
      "predicted_filename": "src\\mcp\\server\\auth\\routes.py",
      "predicted_code_snippet": "def create_protected_resource_routes(\n    resource_url: AnyHttpUrl,\n    authorization_servers: list[AnyHttpUrl],\n    scopes_supported: list[str] | None = None,\n    resource_name: str | None = None,\n    resource_documentation: AnyHttpUrl | None = None,\n) -> list[Route]:\n    \"\"\"\n    Create routes for OAuth 2.0 Protected Resource Metadata (RFC 9728).\n\n    Args:\n        resource_url: The URL of this resource server\n        authorization_servers: List of authorization servers that can issue tokens\n        scopes_supported: Optional list of scopes supported by this resource\n\n    Returns:\n        List of Starlette routes for protected resource metadata\n    \"\"\"\n    from mcp.server.auth.handlers.metadata import ProtectedResourceMetadataHandler\n    from mcp.shared.auth import ProtectedResourceMetadata\n\n    metadata = ProtectedResourceMetadata(\n        resource=resource_url,\n        authorization_servers=authorization_servers,\n        scopes_supported=scopes_supported,\n        resource_name=resource_name,\n        resource_documentation=resource_documentation,\n        # bearer_methods_supported defaults to [\"header\"] in the model\n    )\n\n    handler = ProtectedResourceMetadataHandler(metadata)\n\n    # RFC 9728 \u00a73.1: Register route at /.well-known/oauth-protected-resource + resource path\n    metadata_url = build_resource_metadata_url(resource_url)\n    # Extract just the path part for route registration\n    parsed = urlparse(str(metadata_url))\n    well_known_path = parsed.path\n\n    return [\n        Route(\n            well_known_path,\n            endpoint=cors_middleware(handler.handle, [\"GET\", \"OPTIONS\"]),\n            methods=[\"GET\", \"OPTIONS\"],\n        )\n    ]",
      "input_schema": {
        "type": "object",
        "properties": {
          "resource_url": {
            "type": "string",
            "required": true
          },
          "authorization_servers": {
            "type": "array",
            "required": true
          },
          "scopes_supported": {
            "type": "string",
            "required": false
          },
          "resource_name": {
            "type": "string",
            "required": false
          },
          "resource_documentation": {
            "type": "string",
            "required": false
          }
        },
        "required": [
          "resource_url",
          "authorization_servers"
        ]
      },
      "output_schema": {
        "type": "array"
      },
      "payload_shape": {
        "request": {
          "resource_url": "string",
          "authorization_servers": "array",
          "scopes_supported": "string",
          "resource_name": "string",
          "resource_documentation": "string"
        },
        "response": {
          "type": "array"
        }
      },
      "explanation": "Detected Python function `create_protected_resource_routes` in src\\mcp\\server\\auth\\routes.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.26,
      "evidence": [
        "function create_protected_resource_routes in src\\mcp\\server\\auth\\routes.py",
        "matched template: make an HTTP request to an external API (sim=0.33)"
      ]
    },
    {
      "name": "best_effort_extract_string",
      "description": "parse JSON input and validate fields. Function `best_effort_extract_string`.",
      "predicted_filename": "src\\mcp\\server\\auth\\handlers\\authorize.py",
      "predicted_code_snippet": "def best_effort_extract_string(key: str, params: None | FormData | QueryParams) -> str | None:\n    if params is None:  # pragma: no cover\n        return None\n    value = params.get(key)\n    if isinstance(value, str):\n        return value\n    return None",
      "input_schema": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string",
            "required": true
          },
          "params": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "key",
          "params"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "key": "string",
          "params": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `best_effort_extract_string` in src\\mcp\\server\\auth\\handlers\\authorize.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function best_effort_extract_string in src\\mcp\\server\\auth\\handlers\\authorize.py",
        "matched template: parse JSON input and validate fields (sim=0.23)"
      ]
    },
    {
      "name": "get_access_token",
      "description": "authenticate a user and return a token. Function `get_access_token`.",
      "predicted_filename": "src\\mcp\\server\\auth\\middleware\\auth_context.py",
      "predicted_code_snippet": "def get_access_token() -> AccessToken | None:\n    \"\"\"\n    Get the access token from the current context.\n\n    Returns:\n        The access token if an authenticated user is available, None otherwise.\n    \"\"\"\n    auth_user = auth_context_var.get()\n    return auth_user.access_token if auth_user else None",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `get_access_token` in src\\mcp\\server\\auth\\middleware\\auth_context.py",
      "possible_syscalls": [],
      "confidence": 0.47,
      "evidence": [
        "function get_access_token in src\\mcp\\server\\auth\\middleware\\auth_context.py",
        "matched template: authenticate a user and return a token (sim=0.59)"
      ]
    },
    {
      "name": "lifespan_wrapper",
      "description": "cache results to disk or memory. Function `lifespan_wrapper`.",
      "predicted_filename": "src\\mcp\\server\\fastmcp\\server.py",
      "predicted_code_snippet": "def lifespan_wrapper(\n    app: FastMCP[LifespanResultT],\n    lifespan: Callable[[FastMCP[LifespanResultT]], AbstractAsyncContextManager[LifespanResultT]],\n) -> Callable[[MCPServer[LifespanResultT, Request]], AbstractAsyncContextManager[LifespanResultT]]:\n    @asynccontextmanager\n    async def wrap(\n        _: MCPServer[LifespanResultT, Request],\n    ) -> AsyncIterator[LifespanResultT]:\n        async with lifespan(app) as context:\n            yield context\n\n    return wrap",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "lifespan": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "lifespan"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "lifespan": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `lifespan_wrapper` in src\\mcp\\server\\fastmcp\\server.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function lifespan_wrapper in src\\mcp\\server\\fastmcp\\server.py",
        "matched template: cache results to disk or memory (sim=0.17)"
      ]
    },
    {
      "name": "_is_async_callable",
      "description": "cache results to disk or memory. Function `_is_async_callable`.",
      "predicted_filename": "src\\mcp\\server\\fastmcp\\tools\\base.py",
      "predicted_code_snippet": "def _is_async_callable(obj: Any) -> bool:\n    while isinstance(obj, functools.partial):  # pragma: no cover\n        obj = obj.func\n\n    return inspect.iscoroutinefunction(obj) or (\n        callable(obj) and inspect.iscoroutinefunction(getattr(obj, \"__call__\", None))\n    )",
      "input_schema": {
        "type": "object",
        "properties": {
          "obj": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "obj"
        ]
      },
      "output_schema": {
        "type": "boolean"
      },
      "payload_shape": {
        "request": {
          "obj": "string"
        },
        "response": {
          "type": "boolean"
        }
      },
      "explanation": "Detected Python function `_is_async_callable` in src\\mcp\\server\\fastmcp\\tools\\base.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function _is_async_callable in src\\mcp\\server\\fastmcp\\tools\\base.py",
        "matched template: cache results to disk or memory (sim=0.21)"
      ]
    },
    {
      "name": "find_context_parameter",
      "description": "validate and sanitize user input. Function `find_context_parameter`.",
      "predicted_filename": "src\\mcp\\server\\fastmcp\\utilities\\context_injection.py",
      "predicted_code_snippet": "def find_context_parameter(fn: Callable[..., Any]) -> str | None:\n    \"\"\"Find the parameter that should receive the Context object.\n\n    Searches through the function's signature to find a parameter\n    with a Context type annotation.\n\n    Args:\n        fn: The function to inspect\n\n    Returns:\n        The name of the context parameter, or None if not found\n    \"\"\"\n    from mcp.server.fastmcp.server import Context\n\n    # Get type hints to properly resolve string annotations\n    try:\n        hints = typing.get_type_hints(fn)\n    except Exception:\n        # If we can't resolve type hints, we can't find the context parameter\n        return None\n\n    # Check each parameter's type hint\n    for param_name, annotation in hints.items():\n        # Handle direct Context type\n        if inspect.isclass(annotation) and issubclass(annotation, Context):\n            return param_name\n\n        # Handle generic types like Optional[Context]\n        origin = typing.get_origin(annotation)\n        if origin is not None:\n            args = typing.get_args(annotation)\n            for arg in args:\n                if inspect.isclass(arg) and issubclass(arg, Context):\n                    return param_name\n\n    return None",
      "input_schema": {
        "type": "object",
        "properties": {
          "fn": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "fn"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "fn": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `find_context_parameter` in src\\mcp\\server\\fastmcp\\utilities\\context_injection.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function find_context_parameter in src\\mcp\\server\\fastmcp\\utilities\\context_injection.py",
        "matched template: validate and sanitize user input (sim=0.13)"
      ]
    },
    {
      "name": "inject_context",
      "description": "validate and sanitize user input. Function `inject_context`.",
      "predicted_filename": "src\\mcp\\server\\fastmcp\\utilities\\context_injection.py",
      "predicted_code_snippet": "def inject_context(\n    fn: Callable[..., Any],\n    kwargs: dict[str, Any],\n    context: Any | None,\n    context_kwarg: str | None,\n) -> dict[str, Any]:\n    \"\"\"Inject context into function kwargs if needed.\n\n    Args:\n        fn: The function that will be called\n        kwargs: The current keyword arguments\n        context: The context object to inject (if any)\n        context_kwarg: The name of the parameter to inject into\n\n    Returns:\n        Updated kwargs with context injected if applicable\n    \"\"\"\n    if context_kwarg is not None and context is not None:\n        return {**kwargs, context_kwarg: context}\n    return kwargs",
      "input_schema": {
        "type": "object",
        "properties": {
          "fn": {
            "type": "string",
            "required": true
          },
          "kwargs": {
            "type": "string",
            "required": true
          },
          "context": {
            "type": "string",
            "required": true
          },
          "context_kwarg": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "fn",
          "kwargs",
          "context",
          "context_kwarg"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "fn": "string",
          "kwargs": "string",
          "context": "string",
          "context_kwarg": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `inject_context` in src\\mcp\\server\\fastmcp\\utilities\\context_injection.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function inject_context in src\\mcp\\server\\fastmcp\\utilities\\context_injection.py",
        "matched template: validate and sanitize user input (sim=0.18)"
      ]
    },
    {
      "name": "func_metadata",
      "description": "parse JSON input and validate fields. Function `func_metadata`.",
      "predicted_filename": "src\\mcp\\server\\fastmcp\\utilities\\func_metadata.py",
      "predicted_code_snippet": "def func_metadata(\n    func: Callable[..., Any],\n    skip_names: Sequence[str] = (),\n    structured_output: bool | None = None,\n) -> FuncMetadata:\n    \"\"\"Given a function, return metadata including a pydantic model representing its\n    signature.\n\n    The use case for this is\n    ```\n    meta = func_metadata(func)\n    validated_args = meta.arg_model.model_validate(some_raw_data_dict)\n    return func(**validated_args.model_dump_one_level())\n    ```\n\n    **critically** it also provides pre-parse helper to attempt to parse things from\n    JSON.\n\n    Args:\n        func: The function to convert to a pydantic model\n        skip_names: A list of parameter names to skip. These will not be included in\n            the model.\n        structured_output: Controls whether the tool's output is structured or unstructured\n            - If None, auto-detects based on the function's return type annotation\n            - If True, creates a structured tool (return type annotation permitting)\n            - If False, unconditionally creates an unstructured tool\n\n        If structured, creates a Pydantic model for the function's result based on its annotation.\n        Supports various return types:\n            - BaseModel subclasses (used directly)\n            - Primitive types (str, int, float, bool, bytes, None) - wrapped in a\n                model with a 'result' field\n            - TypedDict - converted to a Pydantic model with same fields\n            - Dataclasses and other annotated classes - converted to Pydantic models\n            - Generic types (list, dict, Union, etc.) - wrapped in a model with a 'result' field\n\n    Returns:\n        A FuncMetadata object containing:\n        - arg_model: A pydantic model representing the function's arguments\n        - output_model: A pydantic model for the return type if output is structured\n        - output_conversion: Records how function output should be converted before returning.\n    \"\"\"\n    try:\n        sig = inspect.signature(func, eval_str=True)\n    except NameError as e:  # pragma: no cover\n        # This raise could perhaps be skipped, and we (FastMCP) just call\n        # model_rebuild right before using it \ud83e\udd37\n        raise InvalidSignature(f\"Unable to evaluate type annotations for callable {func.__name__!r}\") from e\n    params = sig.parameters\n    dynamic_pydantic_model_params: dict[str, Any] = {}\n    for param in params.values():\n        if param.name.startswith(\"_\"):  # pragma: no cover\n            raise InvalidSignature(f\"Parameter {param.name} of {func.__name__} cannot start with '_'\")\n        if param.name in skip_names:\n            continue\n\n        annotation = param.annotation if param.annotation is not inspect.Parameter.empty else Any\n        field_name = param.name\n        field_kwargs: dict[str, Any] = {}\n        field_metadata: list[Any] = []\n\n        if param.annotation is inspect.Parameter.empty:\n            field_metadata.append(WithJsonSchema({\"title\": param.name, \"type\": \"string\"}))\n        # Check if the parameter name conflicts with BaseModel attributes\n        # This is necessary because Pydantic warns about shadowing parent attributes\n        if hasattr(BaseModel, field_name) and callable(getattr(BaseModel, field_name)):\n            # Use an alias to avoid the shadowing warning\n            field_kwargs[\"alias\"] = field_name\n            # Use a prefixed field name\n            field_name = f\"field_{field_name}\"\n\n        if param.default is not inspect.Parameter.empty:\n            dynamic_pydantic_model_params[field_name] = (\n                Annotated[(annotation, *field_metadata, Field(**field_kwargs))],\n                param.default,\n            )\n        else:\n            dynamic_pydantic_model_params[field_name] = Annotated[(annotation, *field_metadata, Field(**field_kwargs))]\n\n    arguments_model = create_model(\n        f\"{func.__name__}Arguments\",\n        __base__=ArgModelBase,\n        **dynamic_pydantic_model_params,\n    )\n\n    if structured_output is False:\n        return FuncMetadata(arg_model=arguments_model)\n\n    # set up structured output support based on return type annotation\n\n    if sig.return_annotation is inspect.Parameter.empty and structured_output is True:\n        raise InvalidSignature(f\"Function {func.__name__}: return annotation required for structured output\")\n\n    try:\n        inspected_return_ann = inspect_annotation(sig.return_annotation, annotation_source=AnnotationSource.FUNCTION)\n    except ForbiddenQualifier as e:\n        raise InvalidSignature(f\"Function {func.__name__}: return annotation contains an invalid type qualifier\") from e\n\n    return_type_expr = inspected_return_ann.type\n\n    # `AnnotationSource.FUNCTION` allows no type qualifier to be used, so `return_type_expr` is guaranteed to *not* be\n    # unknown (i.e. a bare `Final`).\n    assert return_type_expr is not UNKNOWN\n\n    if is_union_origin(get_origin(return_type_expr)):\n        args = get_args(return_type_expr)\n        # Check if CallToolResult appears in the union (excluding None for Optional check)\n        if any(isinstance(arg, type) and issubclass(arg, CallToolResult) for arg in args if arg is not type(None)):\n            raise InvalidSignature(\n                f\"Function {func.__name__}: CallToolResult cannot be used in Union or Optional types. \"\n                \"To return empty results, use: CallToolResult(content=[])\"\n            )\n\n    original_annotation: Any\n    # if the typehint is CallToolResult, the user either intends to return without validation\n    # or they provided validation as Annotated metadata\n    if isinstance(return_type_expr, type) and issubclass(return_type_expr, CallToolResult):\n        if inspected_return_ann.metadata:\n            return_type_expr = inspected_return_ann.metadata[0]\n            if len(inspected_return_ann.metadata) >= 2:\n                # Reconstruct the original annotation, by preserving the remaining metadata,\n                # i.e. from `Annotated[CallToolResult, ReturnType, Gt(1)]` to\n                # `Annotated[ReturnType, Gt(1)]`:\n                original_annotation = Annotated[\n                    (return_type_expr, *inspected_return_ann.metadata[1:])\n                ]  # pragma: no cover\n            else:\n                # We only had `Annotated[CallToolResult, ReturnType]`, treat the original annotation\n                # as beging `ReturnType`:\n                original_annotation = return_type_expr\n        else:\n            return FuncMetadata(arg_model=arguments_model)\n    else:\n        original_annotation = sig.return_annotation\n\n    output_model, output_schema, wrap_output = _try_create_model_and_schema(\n        original_annotation, return_type_expr, func.__name__\n    )\n\n    if output_model is None and structured_output is True:\n        # Model creation failed or produced warnings - no structured output\n        raise InvalidSignature(\n            f\"Function {func.__name__}: return type {return_type_expr} is not serializable for structured output\"\n        )\n\n    return FuncMetadata(\n        arg_model=arguments_model,\n        output_schema=output_schema,\n        output_model=output_model,\n        wrap_output=wrap_output,\n    )",
      "input_schema": {
        "type": "object",
        "properties": {
          "func": {
            "type": "string",
            "required": true
          },
          "skip_names": {
            "type": "string",
            "required": false
          },
          "structured_output": {
            "type": "boolean",
            "required": false
          }
        },
        "required": [
          "func"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "func": "string",
          "skip_names": "string",
          "structured_output": "boolean"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `func_metadata` in src\\mcp\\server\\fastmcp\\utilities\\func_metadata.py",
      "possible_syscalls": [],
      "confidence": 0.24,
      "evidence": [
        "function func_metadata in src\\mcp\\server\\fastmcp\\utilities\\func_metadata.py",
        "matched template: parse JSON input and validate fields (sim=0.30)"
      ]
    },
    {
      "name": "_try_create_model_and_schema",
      "description": "validate and sanitize user input. Function `_try_create_model_and_schema`.",
      "predicted_filename": "src\\mcp\\server\\fastmcp\\utilities\\func_metadata.py",
      "predicted_code_snippet": "def _try_create_model_and_schema(\n    original_annotation: Any,\n    type_expr: Any,\n    func_name: str,\n) -> tuple[type[BaseModel] | None, dict[str, Any] | None, bool]:\n    \"\"\"Try to create a model and schema for the given annotation without warnings.\n\n    Args:\n        original_annotation: The original return annotation (may be wrapped in `Annotated`).\n        type_expr: The underlying type expression derived from the return annotation\n            (`Annotated` and type qualifiers were stripped).\n        func_name: The name of the function.\n\n    Returns:\n        tuple of (model or None, schema or None, wrap_output)\n        Model and schema are None if warnings occur or creation fails.\n        wrap_output is True if the result needs to be wrapped in {\"result\": ...}\n    \"\"\"\n    model = None\n    wrap_output = False\n\n    # First handle special case: None\n    if type_expr is None:\n        model = _create_wrapped_model(func_name, original_annotation)\n        wrap_output = True\n\n    # Handle GenericAlias types (list[str], dict[str, int], Union[str, int], etc.)\n    elif isinstance(type_expr, GenericAlias):\n        origin = get_origin(type_expr)\n\n        # Special case: dict with string keys can use RootModel\n        if origin is dict:\n            args = get_args(type_expr)\n            if len(args) == 2 and args[0] is str:\n                # TODO: should we use the original annotation? We are loosing any potential `Annotated`\n                # metadata for Pydantic here:\n                model = _create_dict_model(func_name, type_expr)\n            else:\n                # dict with non-str keys needs wrapping\n                model = _create_wrapped_model(func_name, original_annotation)\n                wrap_output = True\n        else:\n            # All other generic types need wrapping (list, tuple, Union, Optional, etc.)\n            model = _create_wrapped_model(func_name, original_annotation)\n            wrap_output = True\n\n    # Handle regular type objects\n    elif isinstance(type_expr, type):\n        type_annotation = cast(type[Any], type_expr)\n\n        # Case 1: BaseModel subclasses (can be used directly)\n        if issubclass(type_annotation, BaseModel):\n            model = type_annotation\n\n        # Case 2: TypedDicts:\n        elif is_typeddict(type_annotation):\n            model = _create_model_from_typeddict(type_annotation)\n\n        # Case 3: Primitive types that need wrapping\n        elif type_annotation in (str, int, float, bool, bytes, type(None)):\n            model = _create_wrapped_model(func_name, original_annotation)\n            wrap_output = True\n\n        # Case 4: Other class types (dataclasses, regular classes with annotations)\n        else:\n            type_hints = get_type_hints(type_annotation)\n            if type_hints:\n                # Classes with type hints can be converted to Pydantic models\n                model = _create_model_from_class(type_annotation, type_hints)\n            # Classes without type hints are not serializable - model remains None\n\n    # Handle any other types not covered above\n    else:\n        # This includes typing constructs that aren't GenericAlias in Python 3.10\n        # (e.g., Union, Optional in some Python versions)\n        model = _create_wrapped_model(func_name, original_annotation)\n        wrap_output = True\n\n    if model:\n        # If we successfully created a model, try to get its schema\n        # Use StrictJsonSchema to raise exceptions instead of warnings\n        try:\n            schema = model.model_json_schema(schema_generator=StrictJsonSchema)\n        except (TypeError, ValueError, pydantic_core.SchemaError, pydantic_core.ValidationError) as e:\n            # These are expected errors when a type can't be converted to a Pydantic schema\n            # TypeError: When Pydantic can't handle the type\n            # ValueError: When there are issues with the type definition (including our custom warnings)\n            # SchemaError: When Pydantic can't build a schema\n            # ValidationError: When validation fails\n            logger.info(f\"Cannot create schema for type {type_expr} in {func_name}: {type(e).__name__}: {e}\")\n            return None, None, False\n\n        return model, schema, wrap_output\n\n    return None, None, False",
      "input_schema": {
        "type": "object",
        "properties": {
          "original_annotation": {
            "type": "string",
            "required": true
          },
          "type_expr": {
            "type": "string",
            "required": true
          },
          "func_name": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "original_annotation",
          "type_expr",
          "func_name"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "original_annotation": "string",
          "type_expr": "string",
          "func_name": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `_try_create_model_and_schema` in src\\mcp\\server\\fastmcp\\utilities\\func_metadata.py",
      "possible_syscalls": [],
      "confidence": 0.16,
      "evidence": [
        "function _try_create_model_and_schema in src\\mcp\\server\\fastmcp\\utilities\\func_metadata.py",
        "matched template: validate and sanitize user input (sim=0.10)"
      ]
    },
    {
      "name": "_create_model_from_class",
      "description": "parse JSON input and validate fields. Function `_create_model_from_class`.",
      "predicted_filename": "src\\mcp\\server\\fastmcp\\utilities\\func_metadata.py",
      "predicted_code_snippet": "def _create_model_from_class(cls: type[Any], type_hints: dict[str, Any]) -> type[BaseModel]:\n    \"\"\"Create a Pydantic model from an ordinary class.\n\n    The created model will:\n    - Have the same name as the class\n    - Have fields with the same names and types as the class's fields\n    - Include all fields whose type does not include None in the set of required fields\n\n    Precondition: cls must have type hints (i.e., `type_hints` is non-empty)\n    \"\"\"\n    model_fields: dict[str, Any] = {}\n    for field_name, field_type in type_hints.items():\n        if field_name.startswith(\"_\"):  # pragma: no cover\n            continue\n\n        default = getattr(cls, field_name, _no_default)\n        if default is _no_default:\n            model_fields[field_name] = field_type\n        else:\n            model_fields[field_name] = (field_type, default)\n\n    return create_model(cls.__name__, __config__=ConfigDict(from_attributes=True), **model_fields)",
      "input_schema": {
        "type": "object",
        "properties": {
          "cls": {
            "type": "string",
            "required": true
          },
          "type_hints": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "cls",
          "type_hints"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "cls": "string",
          "type_hints": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `_create_model_from_class` in src\\mcp\\server\\fastmcp\\utilities\\func_metadata.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function _create_model_from_class in src\\mcp\\server\\fastmcp\\utilities\\func_metadata.py",
        "matched template: parse JSON input and validate fields (sim=0.16)"
      ]
    },
    {
      "name": "_create_model_from_typeddict",
      "description": "parse JSON input and validate fields. Function `_create_model_from_typeddict`.",
      "predicted_filename": "src\\mcp\\server\\fastmcp\\utilities\\func_metadata.py",
      "predicted_code_snippet": "def _create_model_from_typeddict(td_type: type[Any]) -> type[BaseModel]:\n    \"\"\"Create a Pydantic model from a TypedDict.\n\n    The created model will have the same name and fields as the TypedDict.\n    \"\"\"\n    type_hints = get_type_hints(td_type)\n    required_keys = getattr(td_type, \"__required_keys__\", set(type_hints.keys()))\n\n    model_fields: dict[str, Any] = {}\n    for field_name, field_type in type_hints.items():\n        if field_name not in required_keys:\n            # For optional TypedDict fields, set default=None\n            # This makes them not required in the Pydantic model\n            # The model should use exclude_unset=True when dumping to get TypedDict semantics\n            model_fields[field_name] = (field_type, None)\n        else:\n            model_fields[field_name] = field_type\n\n    return create_model(td_type.__name__, **model_fields)",
      "input_schema": {
        "type": "object",
        "properties": {
          "td_type": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "td_type"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "td_type": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `_create_model_from_typeddict` in src\\mcp\\server\\fastmcp\\utilities\\func_metadata.py",
      "possible_syscalls": [],
      "confidence": 0.25,
      "evidence": [
        "function _create_model_from_typeddict in src\\mcp\\server\\fastmcp\\utilities\\func_metadata.py",
        "matched template: parse JSON input and validate fields (sim=0.31)"
      ]
    },
    {
      "name": "_create_wrapped_model",
      "description": "serialize object to JSON. Function `_create_wrapped_model`.",
      "predicted_filename": "src\\mcp\\server\\fastmcp\\utilities\\func_metadata.py",
      "predicted_code_snippet": "def _create_wrapped_model(func_name: str, annotation: Any) -> type[BaseModel]:\n    \"\"\"Create a model that wraps a type in a 'result' field.\n\n    This is used for primitive types, generic types like list/dict, etc.\n    \"\"\"\n    model_name = f\"{func_name}Output\"\n\n    return create_model(model_name, result=annotation)",
      "input_schema": {
        "type": "object",
        "properties": {
          "func_name": {
            "type": "string",
            "required": true
          },
          "annotation": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "func_name",
          "annotation"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "func_name": "string",
          "annotation": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `_create_wrapped_model` in src\\mcp\\server\\fastmcp\\utilities\\func_metadata.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function _create_wrapped_model in src\\mcp\\server\\fastmcp\\utilities\\func_metadata.py",
        "matched template: serialize object to JSON (sim=0.24)"
      ]
    },
    {
      "name": "_create_dict_model",
      "description": "serialize object to JSON. Function `_create_dict_model`.",
      "predicted_filename": "src\\mcp\\server\\fastmcp\\utilities\\func_metadata.py",
      "predicted_code_snippet": "def _create_dict_model(func_name: str, dict_annotation: Any) -> type[BaseModel]:\n    \"\"\"Create a RootModel for dict[str, T] types.\"\"\"\n\n    class DictModel(RootModel[dict_annotation]):\n        pass\n\n    # Give it a meaningful name\n    DictModel.__name__ = f\"{func_name}DictOutput\"\n    DictModel.__qualname__ = f\"{func_name}DictOutput\"\n\n    return DictModel",
      "input_schema": {
        "type": "object",
        "properties": {
          "func_name": {
            "type": "string",
            "required": true
          },
          "dict_annotation": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "func_name",
          "dict_annotation"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "func_name": "string",
          "dict_annotation": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `_create_dict_model` in src\\mcp\\server\\fastmcp\\utilities\\func_metadata.py",
      "possible_syscalls": [],
      "confidence": 0.24,
      "evidence": [
        "function _create_dict_model in src\\mcp\\server\\fastmcp\\utilities\\func_metadata.py",
        "matched template: serialize object to JSON (sim=0.30)"
      ]
    },
    {
      "name": "_convert_to_content",
      "description": "process image data (resize, crop, convert). Function `_convert_to_content`.",
      "predicted_filename": "src\\mcp\\server\\fastmcp\\utilities\\func_metadata.py",
      "predicted_code_snippet": "def _convert_to_content(\n    result: Any,\n) -> Sequence[ContentBlock]:\n    \"\"\"\n    Convert a result to a sequence of content objects.\n\n    Note: This conversion logic comes from previous versions of FastMCP and is being\n    retained for purposes of backwards compatibility. It produces different unstructured\n    output than the lowlevel server tool call handler, which just serializes structured\n    content verbatim.\n    \"\"\"\n    if result is None:  # pragma: no cover\n        return []\n\n    if isinstance(result, ContentBlock):\n        return [result]\n\n    if isinstance(result, Image):\n        return [result.to_image_content()]\n\n    if isinstance(result, Audio):\n        return [result.to_audio_content()]\n\n    if isinstance(result, list | tuple):\n        return list(\n            chain.from_iterable(\n                _convert_to_content(item)\n                for item in result  # type: ignore\n            )\n        )\n\n    if not isinstance(result, str):\n        result = pydantic_core.to_json(result, fallback=str, indent=2).decode()\n\n    return [TextContent(type=\"text\", text=result)]",
      "input_schema": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "result"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "result": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `_convert_to_content` in src\\mcp\\server\\fastmcp\\utilities\\func_metadata.py",
      "possible_syscalls": [],
      "confidence": 0.25,
      "evidence": [
        "function _convert_to_content in src\\mcp\\server\\fastmcp\\utilities\\func_metadata.py",
        "matched template: process image data (resize, crop, convert) (sim=0.30)"
      ]
    },
    {
      "name": "get_logger",
      "description": "list files in a directory. Function `get_logger`.",
      "predicted_filename": "src\\mcp\\server\\fastmcp\\utilities\\logging.py",
      "predicted_code_snippet": "def get_logger(name: str) -> logging.Logger:\n    \"\"\"Get a logger nested under MCPnamespace.\n\n    Args:\n        name: the name of the logger, which will be prefixed with 'FastMCP.'\n\n    Returns:\n        a configured logger instance\n    \"\"\"\n    return logging.getLogger(name)",
      "input_schema": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "name"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "name": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `get_logger` in src\\mcp\\server\\fastmcp\\utilities\\logging.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function get_logger in src\\mcp\\server\\fastmcp\\utilities\\logging.py",
        "matched template: list files in a directory (sim=0.11)"
      ]
    },
    {
      "name": "configure_logging",
      "description": "write data to a file. Function `configure_logging`.",
      "predicted_filename": "src\\mcp\\server\\fastmcp\\utilities\\logging.py",
      "predicted_code_snippet": "def configure_logging(\n    level: Literal[\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"] = \"INFO\",\n) -> None:\n    \"\"\"Configure logging for MCP.\n\n    Args:\n        level: the log level to use\n    \"\"\"\n    handlers: list[logging.Handler] = []\n    try:  # pragma: no cover\n        from rich.console import Console\n        from rich.logging import RichHandler\n\n        handlers.append(RichHandler(console=Console(stderr=True), rich_tracebacks=True))\n    except ImportError:  # pragma: no cover\n        pass\n\n    if not handlers:  # pragma: no cover\n        handlers.append(logging.StreamHandler())\n\n    logging.basicConfig(\n        level=level,\n        format=\"%(message)s\",\n        handlers=handlers,\n    )",
      "input_schema": {
        "type": "object",
        "properties": {
          "level": {
            "type": "string",
            "required": false
          }
        },
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "level": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `configure_logging` in src\\mcp\\server\\fastmcp\\utilities\\logging.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function configure_logging in src\\mcp\\server\\fastmcp\\utilities\\logging.py",
        "matched template: write data to a file (sim=0.19)"
      ]
    },
    {
      "name": "create_call_wrapper",
      "description": "make an HTTP request to an external API. Function `create_call_wrapper`.",
      "predicted_filename": "src\\mcp\\server\\lowlevel\\func_inspection.py",
      "predicted_code_snippet": "def create_call_wrapper(func: Callable[..., R], request_type: type[T]) -> Callable[[T], R]:\n    \"\"\"\n    Create a wrapper function that knows how to call func with the request object.\n\n    Returns a wrapper function that takes the request and calls func appropriately.\n\n    The wrapper handles three calling patterns:\n    1. Positional-only parameter typed as request_type (no default): func(req)\n    2. Positional/keyword parameter typed as request_type (no default): func(**{param_name: req})\n    3. No request parameter or parameter with default: func()\n    \"\"\"\n    try:\n        sig = inspect.signature(func)\n        type_hints = get_type_hints(func)\n    except (ValueError, TypeError, NameError):  # pragma: no cover\n        return lambda _: func()\n\n    # Check for positional-only parameter typed as request_type\n    for param_name, param in sig.parameters.items():\n        if param.kind == inspect.Parameter.POSITIONAL_ONLY:\n            param_type = type_hints.get(param_name)\n            if param_type == request_type:  # pragma: no branch\n                # Check if it has a default - if so, treat as old style\n                if param.default is not inspect.Parameter.empty:  # pragma: no cover\n                    return lambda _: func()\n                # Found positional-only parameter with correct type and no default\n                return lambda req: func(req)\n\n    # Check for any positional/keyword parameter typed as request_type\n    for param_name, param in sig.parameters.items():\n        if param.kind in (inspect.Parameter.POSITIONAL_OR_KEYWORD, inspect.Parameter.KEYWORD_ONLY):  # pragma: no branch\n            param_type = type_hints.get(param_name)\n            if param_type == request_type:\n                # Check if it has a default - if so, treat as old style\n                if param.default is not inspect.Parameter.empty:  # pragma: no cover\n                    return lambda _: func()\n\n                # Found keyword parameter with correct type and no default\n                # Need to capture param_name in closure properly\n                def make_keyword_wrapper(name: str) -> Callable[[Any], Any]:\n                    return lambda req: func(**{name: req})\n\n                return make_keyword_wrapper(param_name)\n\n    # No request parameter found - use old style\n    return lambda _: func()",
      "input_schema": {
        "type": "object",
        "properties": {
          "func": {
            "type": "string",
            "required": true
          },
          "request_type": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "func",
          "request_type"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "func": "string",
          "request_type": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `create_call_wrapper` in src\\mcp\\server\\lowlevel\\func_inspection.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function create_call_wrapper in src\\mcp\\server\\lowlevel\\func_inspection.py",
        "matched template: make an HTTP request to an external API (sim=0.27)"
      ]
    },
    {
      "name": "resource_url_from_server_url",
      "description": "make an HTTP request to an external API. Function `resource_url_from_server_url`.",
      "predicted_filename": "src\\mcp\\shared\\auth_utils.py",
      "predicted_code_snippet": "def resource_url_from_server_url(url: str | HttpUrl | AnyUrl) -> str:\n    \"\"\"Convert server URL to canonical resource URL per RFC 8707.\n\n    RFC 8707 section 2 states that resource URIs \"MUST NOT include a fragment component\".\n    Returns absolute URI with lowercase scheme/host for canonical form.\n\n    Args:\n        url: Server URL to convert\n\n    Returns:\n        Canonical resource URL string\n    \"\"\"\n    # Convert to string if needed\n    url_str = str(url)\n\n    # Parse the URL and remove fragment, create canonical form\n    parsed = urlsplit(url_str)\n    canonical = urlunsplit(parsed._replace(scheme=parsed.scheme.lower(), netloc=parsed.netloc.lower(), fragment=\"\"))\n\n    return canonical",
      "input_schema": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "url"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "url": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `resource_url_from_server_url` in src\\mcp\\shared\\auth_utils.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.26,
      "evidence": [
        "function resource_url_from_server_url in src\\mcp\\shared\\auth_utils.py",
        "matched template: make an HTTP request to an external API (sim=0.32)"
      ]
    },
    {
      "name": "check_resource_allowed",
      "description": "handle a HTTP route request and return response. Function `check_resource_allowed`.",
      "predicted_filename": "src\\mcp\\shared\\auth_utils.py",
      "predicted_code_snippet": "def check_resource_allowed(requested_resource: str, configured_resource: str) -> bool:\n    \"\"\"Check if a requested resource URL matches a configured resource URL.\n\n    A requested resource matches if it has the same scheme, domain, port,\n    and its path starts with the configured resource's path. This allows\n    hierarchical matching where a token for a parent resource can be used\n    for child resources.\n\n    Args:\n        requested_resource: The resource URL being requested\n        configured_resource: The resource URL that has been configured\n\n    Returns:\n        True if the requested resource matches the configured resource\n    \"\"\"\n    # Parse both URLs\n    requested = urlparse(requested_resource)\n    configured = urlparse(configured_resource)\n\n    # Compare scheme, host, and port (origin)\n    if requested.scheme.lower() != configured.scheme.lower() or requested.netloc.lower() != configured.netloc.lower():\n        return False\n\n    # Handle cases like requested=/foo and configured=/foo/\n    requested_path = requested.path\n    configured_path = configured.path\n\n    # If requested path is shorter, it cannot be a child\n    if len(requested_path) < len(configured_path):\n        return False\n\n    # Check if the requested path starts with the configured path\n    # Ensure both paths end with / for proper comparison\n    # This ensures that paths like \"/api123\" don't incorrectly match \"/api\"\n    if not requested_path.endswith(\"/\"):\n        requested_path += \"/\"\n    if not configured_path.endswith(\"/\"):\n        configured_path += \"/\"\n\n    return requested_path.startswith(configured_path)",
      "input_schema": {
        "type": "object",
        "properties": {
          "requested_resource": {
            "type": "string",
            "required": true
          },
          "configured_resource": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "requested_resource",
          "configured_resource"
        ]
      },
      "output_schema": {
        "type": "boolean"
      },
      "payload_shape": {
        "request": {
          "requested_resource": "string",
          "configured_resource": "string"
        },
        "response": {
          "type": "boolean"
        }
      },
      "explanation": "Detected Python function `check_resource_allowed` in src\\mcp\\shared\\auth_utils.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.22,
      "evidence": [
        "function check_resource_allowed in src\\mcp\\shared\\auth_utils.py",
        "matched template: handle a HTTP route request and return response (sim=0.25)"
      ]
    },
    {
      "name": "calculate_token_expiry",
      "description": "authenticate a user and return a token. Function `calculate_token_expiry`.",
      "predicted_filename": "src\\mcp\\shared\\auth_utils.py",
      "predicted_code_snippet": "def calculate_token_expiry(expires_in: int | str | None) -> float | None:\n    \"\"\"Calculate token expiry timestamp from expires_in seconds.\n\n    Args:\n        expires_in: Seconds until token expiration (may be string from some servers)\n\n    Returns:\n        Unix timestamp when token expires, or None if no expiry specified\n    \"\"\"\n    if expires_in is None:\n        return None  # pragma: no cover\n    # Defensive: handle servers that return expires_in as string\n    return time.time() + int(expires_in)",
      "input_schema": {
        "type": "object",
        "properties": {
          "expires_in": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "expires_in"
        ]
      },
      "output_schema": {
        "type": "number"
      },
      "payload_shape": {
        "request": {
          "expires_in": "string"
        },
        "response": {
          "type": "number"
        }
      },
      "explanation": "Detected Python function `calculate_token_expiry` in src\\mcp\\shared\\auth_utils.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.25,
      "evidence": [
        "function calculate_token_expiry in src\\mcp\\shared\\auth_utils.py",
        "matched template: authenticate a user and return a token (sim=0.31)"
      ]
    },
    {
      "name": "get_display_name",
      "description": "execute a shell command. Function `get_display_name`.",
      "predicted_filename": "src\\mcp\\shared\\metadata_utils.py",
      "predicted_code_snippet": "def get_display_name(obj: Tool | Resource | Prompt | ResourceTemplate | Implementation) -> str:\n    \"\"\"\n    Get the display name for an MCP object with proper precedence.\n\n    This is a client-side utility function designed to help MCP clients display\n    human-readable names in their user interfaces. When servers provide a 'title'\n    field, it should be preferred over the programmatic 'name' field for display.\n\n    For tools: title > annotations.title > name\n    For other objects: title > name\n\n    Example:\n        # In a client displaying available tools\n        tools = await session.list_tools()\n        for tool in tools.tools:\n            display_name = get_display_name(tool)\n            print(f\"Available tool: {display_name}\")\n\n    Args:\n        obj: An MCP object with name and optional title fields\n\n    Returns:\n        The display name to use for UI presentation\n    \"\"\"\n    if isinstance(obj, Tool):\n        # Tools have special precedence: title > annotations.title > name\n        if hasattr(obj, \"title\") and obj.title is not None:\n            return obj.title\n        if obj.annotations and hasattr(obj.annotations, \"title\") and obj.annotations.title is not None:\n            return obj.annotations.title\n        return obj.name\n    else:\n        # All other objects: title > name\n        if hasattr(obj, \"title\") and obj.title is not None:\n            return obj.title\n        return obj.name",
      "input_schema": {
        "type": "object",
        "properties": {
          "obj": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "obj"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "obj": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `get_display_name` in src\\mcp\\shared\\metadata_utils.py",
      "possible_syscalls": [],
      "confidence": 0.16,
      "evidence": [
        "function get_display_name in src\\mcp\\shared\\metadata_utils.py",
        "matched template: execute a shell command (sim=0.09)"
      ]
    },
    {
      "name": "progress",
      "description": "send an email notification. Function `progress`.",
      "predicted_filename": "src\\mcp\\shared\\progress.py",
      "predicted_code_snippet": "def progress(\n    ctx: RequestContext[\n        BaseSession[SendRequestT, SendNotificationT, SendResultT, ReceiveRequestT, ReceiveNotificationT],\n        LifespanContextT,\n    ],\n    total: float | None = None,\n) -> Generator[\n    ProgressContext[SendRequestT, SendNotificationT, SendResultT, ReceiveRequestT, ReceiveNotificationT],\n    None,\n]:\n    if ctx.meta is None or ctx.meta.progressToken is None:  # pragma: no cover\n        raise ValueError(\"No progress token provided\")\n\n    progress_ctx = ProgressContext(ctx.session, ctx.meta.progressToken, total)\n    try:\n        yield progress_ctx\n    finally:\n        pass",
      "input_schema": {
        "type": "object",
        "properties": {
          "ctx": {
            "type": "string",
            "required": true
          },
          "total": {
            "type": "number",
            "required": false
          }
        },
        "required": [
          "ctx"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "ctx": "string",
          "total": "number"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `progress` in src\\mcp\\shared\\progress.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function progress in src\\mcp\\shared\\progress.py",
        "matched template: send an email notification (sim=0.17)"
      ]
    },
    {
      "name": "create_mcp_http_client",
      "description": "make an HTTP request to an external API. Function `create_mcp_http_client`.",
      "predicted_filename": "src\\mcp\\shared\\_httpx_utils.py",
      "predicted_code_snippet": "def create_mcp_http_client(\n    headers: dict[str, str] | None = None,\n    timeout: httpx.Timeout | None = None,\n    auth: httpx.Auth | None = None,\n) -> httpx.AsyncClient:\n    \"\"\"Create a standardized httpx AsyncClient with MCP defaults.\n\n    This function provides common defaults used throughout the MCP codebase:\n    - follow_redirects=True (always enabled)\n    - Default timeout of 30 seconds if not specified\n\n    Args:\n        headers: Optional headers to include with all requests.\n        timeout: Request timeout as httpx.Timeout object.\n            Defaults to 30 seconds if not specified.\n        auth: Optional authentication handler.\n\n    Returns:\n        Configured httpx.AsyncClient instance with MCP defaults.\n\n    Note:\n        The returned AsyncClient must be used as a context manager to ensure\n        proper cleanup of connections.\n\n    Examples:\n        # Basic usage with MCP defaults\n        async with create_mcp_http_client() as client:\n            response = await client.get(\"https://api.example.com\")\n\n        # With custom headers\n        headers = {\"Authorization\": \"Bearer token\"}\n        async with create_mcp_http_client(headers) as client:\n            response = await client.get(\"/endpoint\")\n\n        # With both custom headers and timeout\n        timeout = httpx.Timeout(60.0, read=300.0)\n        async with create_mcp_http_client(headers, timeout) as client:\n            response = await client.get(\"/long-request\")\n\n        # With authentication\n        from httpx import BasicAuth\n        auth = BasicAuth(username=\"user\", password=\"pass\")\n        async with create_mcp_http_client(headers, timeout, auth) as client:\n            response = await client.get(\"/protected-endpoint\")\n    \"\"\"\n    # Set MCP defaults\n    kwargs: dict[str, Any] = {\n        \"follow_redirects\": True,\n    }\n\n    # Handle timeout\n    if timeout is None:\n        kwargs[\"timeout\"] = httpx.Timeout(30.0)\n    else:\n        kwargs[\"timeout\"] = timeout\n\n    # Handle headers\n    if headers is not None:\n        kwargs[\"headers\"] = headers\n\n    # Handle authentication\n    if auth is not None:  # pragma: no cover\n        kwargs[\"auth\"] = auth\n\n    return httpx.AsyncClient(**kwargs)",
      "input_schema": {
        "type": "object",
        "properties": {
          "headers": {
            "type": "string",
            "required": false
          },
          "timeout": {
            "type": "string",
            "required": false
          },
          "auth": {
            "type": "string",
            "required": false
          }
        },
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "headers": "string",
          "timeout": "string",
          "auth": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `create_mcp_http_client` in src\\mcp\\shared\\_httpx_utils.py",
      "possible_syscalls": [],
      "confidence": 0.29,
      "evidence": [
        "function create_mcp_http_client in src\\mcp\\shared\\_httpx_utils.py",
        "matched template: make an HTTP request to an external API (sim=0.37)"
      ]
    },
    {
      "name": "anyio_backend",
      "description": "handle a HTTP route request and return response. Function `anyio_backend`.",
      "predicted_filename": "tests\\conftest.py",
      "predicted_code_snippet": "def anyio_backend():\n    return \"asyncio\"",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `anyio_backend` in tests\\conftest.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function anyio_backend in tests\\conftest.py",
        "matched template: handle a HTTP route request and return response (sim=0.17)"
      ]
    },
    {
      "name": "test_docs_examples",
      "description": "list files in a directory. Function `test_docs_examples`.",
      "predicted_filename": "tests\\test_examples.py",
      "predicted_code_snippet": "def test_docs_examples(example: CodeExample, eval_example: EvalExample):\n    ruff_ignore: list[str] = [\"F841\", \"I001\", \"F821\"]  # F821: undefined names (snippets lack imports)\n\n    # Use project's actual line length of 120\n    eval_example.set_config(ruff_ignore=ruff_ignore, target_version=\"py310\", line_length=120)\n\n    # Use Ruff for both formatting and linting (skip Black)\n    if eval_example.update_examples:  # pragma: no cover\n        eval_example.format_ruff(example)\n    else:\n        eval_example.lint_ruff(example)",
      "input_schema": {
        "type": "object",
        "properties": {
          "example": {
            "type": "string",
            "required": true
          },
          "eval_example": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "example",
          "eval_example"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "example": "string",
          "eval_example": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_docs_examples` in tests\\test_examples.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function test_docs_examples in tests\\test_examples.py",
        "matched template: list files in a directory (sim=0.16)"
      ]
    },
    {
      "name": "wait_for_server",
      "description": "stream data over websocket. Function `wait_for_server`.",
      "predicted_filename": "tests\\test_helpers.py",
      "predicted_code_snippet": "def wait_for_server(port: int, timeout: float = 20.0) -> None:\n    \"\"\"Wait for server to be ready to accept connections.\n\n    Polls the server port until it accepts connections or timeout is reached.\n    This eliminates race conditions without arbitrary sleeps.\n\n    Args:\n        port: The port number to check\n        timeout: Maximum time to wait in seconds (default 5.0)\n\n    Raises:\n        TimeoutError: If server doesn't start within the timeout period\n    \"\"\"\n    start_time = time.time()\n    while time.time() - start_time < timeout:\n        try:\n            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n                s.settimeout(0.1)\n                s.connect((\"127.0.0.1\", port))\n                # Server is ready\n                return\n        except (ConnectionRefusedError, OSError):\n            # Server not ready yet, retry quickly\n            time.sleep(0.01)\n    raise TimeoutError(f\"Server on port {port} did not start within {timeout} seconds\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "port": {
            "type": "integer",
            "required": true
          },
          "timeout": {
            "type": "number",
            "required": false
          }
        },
        "required": [
          "port"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "port": "integer",
          "timeout": "number"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `wait_for_server` in tests\\test_helpers.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        }
      ],
      "confidence": 0.25,
      "evidence": [
        "function wait_for_server in tests\\test_helpers.py",
        "matched template: stream data over websocket (sim=0.31)"
      ]
    },
    {
      "name": "test_parse_file_path_accepts_valid_specs",
      "description": "write data to a file. Function `test_parse_file_path_accepts_valid_specs`.",
      "predicted_filename": "tests\\cli\\test_utils.py",
      "predicted_code_snippet": "def test_parse_file_path_accepts_valid_specs(tmp_path: Path, spec: str, expected_obj: str | None):\n    \"\"\"Should accept valid file specs.\"\"\"\n    file = tmp_path / spec.split(\":\")[0]\n    file.write_text(\"x = 1\")\n    path, obj = _parse_file_path(f\"{file}:{expected_obj}\" if \":\" in spec else str(file))\n    assert path == file.resolve()\n    assert obj == expected_obj",
      "input_schema": {
        "type": "object",
        "properties": {
          "tmp_path": {
            "type": "string",
            "required": true
          },
          "spec": {
            "type": "string",
            "required": true
          },
          "expected_obj": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "tmp_path",
          "spec",
          "expected_obj"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "tmp_path": "string",
          "spec": "string",
          "expected_obj": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_parse_file_path_accepts_valid_specs` in tests\\cli\\test_utils.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function test_parse_file_path_accepts_valid_specs in tests\\cli\\test_utils.py",
        "matched template: write data to a file (sim=0.22)"
      ]
    },
    {
      "name": "test_parse_file_path_missing",
      "description": "execute a shell command. Function `test_parse_file_path_missing`.",
      "predicted_filename": "tests\\cli\\test_utils.py",
      "predicted_code_snippet": "def test_parse_file_path_missing(tmp_path: Path):\n    \"\"\"Should system exit if a file is missing.\"\"\"\n    with pytest.raises(SystemExit):\n        _parse_file_path(str(tmp_path / \"missing.py\"))",
      "input_schema": {
        "type": "object",
        "properties": {
          "tmp_path": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "tmp_path"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "tmp_path": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_parse_file_path_missing` in tests\\cli\\test_utils.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_parse_file_path_missing in tests\\cli\\test_utils.py",
        "matched template: execute a shell command (sim=0.18)"
      ]
    },
    {
      "name": "test_parse_file_exit_on_dir",
      "description": "execute a shell command. Function `test_parse_file_exit_on_dir`.",
      "predicted_filename": "tests\\cli\\test_utils.py",
      "predicted_code_snippet": "def test_parse_file_exit_on_dir(tmp_path: Path):\n    \"\"\"Should system exit if a directory is passed\"\"\"\n    dir_path = tmp_path / \"dir\"\n    dir_path.mkdir()\n    with pytest.raises(SystemExit):\n        _parse_file_path(str(dir_path))",
      "input_schema": {
        "type": "object",
        "properties": {
          "tmp_path": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "tmp_path"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "tmp_path": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_parse_file_exit_on_dir` in tests\\cli\\test_utils.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function test_parse_file_exit_on_dir in tests\\cli\\test_utils.py",
        "matched template: execute a shell command (sim=0.24)"
      ]
    },
    {
      "name": "test_build_uv_command_minimal",
      "description": "execute a shell command. Function `test_build_uv_command_minimal`.",
      "predicted_filename": "tests\\cli\\test_utils.py",
      "predicted_code_snippet": "def test_build_uv_command_minimal():\n    \"\"\"Should emit core command when no extras specified.\"\"\"\n    cmd = _build_uv_command(\"foo.py\")\n    assert cmd == [\"uv\", \"run\", \"--with\", \"mcp\", \"mcp\", \"run\", \"foo.py\"]",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_build_uv_command_minimal` in tests\\cli\\test_utils.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function test_build_uv_command_minimal in tests\\cli\\test_utils.py",
        "matched template: execute a shell command (sim=0.27)"
      ]
    },
    {
      "name": "test_build_uv_command_adds_editable_and_packages",
      "description": "execute a shell command. Function `test_build_uv_command_adds_editable_and_packages`.",
      "predicted_filename": "tests\\cli\\test_utils.py",
      "predicted_code_snippet": "def test_build_uv_command_adds_editable_and_packages():\n    \"\"\"Should include --with-editable and every --with pkg in correct order.\"\"\"\n    test_path = Path(\"/pkg\")\n    cmd = _build_uv_command(\n        \"foo.py\",\n        with_editable=test_path,\n        with_packages=[\"package1\", \"package2\"],\n    )\n    assert cmd == [\n        \"uv\",\n        \"run\",\n        \"--with\",\n        \"mcp\",\n        \"--with-editable\",\n        str(test_path),  # Use str() to match what the function does\n        \"--with\",\n        \"package1\",\n        \"--with\",\n        \"package2\",\n        \"mcp\",\n        \"run\",\n        \"foo.py\",\n    ]",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_build_uv_command_adds_editable_and_packages` in tests\\cli\\test_utils.py",
      "possible_syscalls": [],
      "confidence": 0.24,
      "evidence": [
        "function test_build_uv_command_adds_editable_and_packages in tests\\cli\\test_utils.py",
        "matched template: execute a shell command (sim=0.29)"
      ]
    },
    {
      "name": "test_get_npx_unix_like",
      "description": "execute a shell command. Function `test_get_npx_unix_like`.",
      "predicted_filename": "tests\\cli\\test_utils.py",
      "predicted_code_snippet": "def test_get_npx_unix_like(monkeypatch: pytest.MonkeyPatch):\n    \"\"\"Should return \"npx\" on unix-like systems.\"\"\"\n    monkeypatch.setattr(sys, \"platform\", \"linux\")\n    assert _get_npx_command() == \"npx\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "monkeypatch": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "monkeypatch"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "monkeypatch": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_get_npx_unix_like` in tests\\cli\\test_utils.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function test_get_npx_unix_like in tests\\cli\\test_utils.py",
        "matched template: execute a shell command (sim=0.22)"
      ]
    },
    {
      "name": "test_get_npx_windows",
      "description": "execute a shell command. Function `test_get_npx_windows`.",
      "predicted_filename": "tests\\cli\\test_utils.py",
      "predicted_code_snippet": "def test_get_npx_windows(monkeypatch: pytest.MonkeyPatch):\n    \"\"\"Should return one of the npx candidates on Windows.\"\"\"\n    candidates = [\"npx.cmd\", \"npx.exe\", \"npx\"]\n\n    def fake_run(cmd: list[str], **kw: Any) -> subprocess.CompletedProcess[bytes]:\n        if cmd[0] in candidates:\n            return subprocess.CompletedProcess(cmd, 0)\n        else:  # pragma: no cover\n            raise subprocess.CalledProcessError(1, cmd[0])\n\n    monkeypatch.setattr(sys, \"platform\", \"win32\")\n    monkeypatch.setattr(subprocess, \"run\", fake_run)\n    assert _get_npx_command() in candidates",
      "input_schema": {
        "type": "object",
        "properties": {
          "monkeypatch": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "monkeypatch"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "monkeypatch": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_get_npx_windows` in tests\\cli\\test_utils.py",
      "possible_syscalls": [],
      "confidence": 0.25,
      "evidence": [
        "function test_get_npx_windows in tests\\cli\\test_utils.py",
        "matched template: execute a shell command (sim=0.31)"
      ]
    },
    {
      "name": "test_get_npx_returns_none_when_npx_missing",
      "description": "execute a shell command. Function `test_get_npx_returns_none_when_npx_missing`.",
      "predicted_filename": "tests\\cli\\test_utils.py",
      "predicted_code_snippet": "def test_get_npx_returns_none_when_npx_missing(monkeypatch: pytest.MonkeyPatch):\n    \"\"\"Should give None if every candidate fails.\"\"\"\n    monkeypatch.setattr(sys, \"platform\", \"win32\", raising=False)\n\n    def always_fail(*args: Any, **kwargs: Any) -> subprocess.CompletedProcess[bytes]:\n        raise subprocess.CalledProcessError(1, args[0])\n\n    monkeypatch.setattr(subprocess, \"run\", always_fail)\n    assert _get_npx_command() is None",
      "input_schema": {
        "type": "object",
        "properties": {
          "monkeypatch": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "monkeypatch"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "monkeypatch": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_get_npx_returns_none_when_npx_missing` in tests\\cli\\test_utils.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function test_get_npx_returns_none_when_npx_missing in tests\\cli\\test_utils.py",
        "matched template: execute a shell command (sim=0.20)"
      ]
    },
    {
      "name": "stream_spy",
      "description": "stream data over websocket. Function `stream_spy`.",
      "predicted_filename": "tests\\client\\conftest.py",
      "predicted_code_snippet": "def stream_spy() -> Generator[Callable[[], StreamSpyCollection], None, None]:\n    \"\"\"Fixture that provides spies for both client and server write streams.\n\n    Example usage:\n        async def test_something(stream_spy):\n            # ... set up server and client ...\n\n            spies = stream_spy()\n\n            # Run some operation that sends messages\n            await client.some_operation()\n\n            # Check the messages\n            requests = spies.get_client_requests(method=\"some/method\")\n            assert len(requests) == 1\n\n            # Clear for the next operation\n            spies.clear()\n    \"\"\"\n    client_spy = None\n    server_spy = None\n\n    # Store references to our spy objects\n    def capture_spies(c_spy: SpyMemoryObjectSendStream, s_spy: SpyMemoryObjectSendStream):\n        nonlocal client_spy, server_spy\n        client_spy = c_spy\n        server_spy = s_spy\n\n    # Create patched version of stream creation\n    original_create_streams = mcp.shared.memory.create_client_server_memory_streams\n\n    @asynccontextmanager\n    async def patched_create_streams():\n        async with original_create_streams() as (client_streams, server_streams):\n            client_read, client_write = client_streams\n            server_read, server_write = server_streams\n\n            # Create spy wrappers\n            spy_client_write = SpyMemoryObjectSendStream(client_write)\n            spy_server_write = SpyMemoryObjectSendStream(server_write)\n\n            # Capture references for the test to use\n            capture_spies(spy_client_write, spy_server_write)\n\n            yield (client_read, spy_client_write), (server_read, spy_server_write)\n\n    # Apply the patch for the duration of the test\n    with patch(\"mcp.shared.memory.create_client_server_memory_streams\", patched_create_streams):\n        # Return a collection with helper methods\n        def get_spy_collection() -> StreamSpyCollection:\n            assert client_spy is not None, \"client_spy was not initialized\"\n            assert server_spy is not None, \"server_spy was not initialized\"\n            return StreamSpyCollection(client_spy, server_spy)\n\n        yield get_spy_collection",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `stream_spy` in tests\\client\\conftest.py",
      "possible_syscalls": [],
      "confidence": 0.34,
      "evidence": [
        "function stream_spy in tests\\client\\conftest.py",
        "matched template: stream data over websocket (sim=0.44)"
      ]
    },
    {
      "name": "mock_storage",
      "description": "authenticate a user and return a token. Function `mock_storage`.",
      "predicted_filename": "tests\\client\\test_auth.py",
      "predicted_code_snippet": "def mock_storage():\n    return MockTokenStorage()",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `mock_storage` in tests\\client\\test_auth.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.22,
      "evidence": [
        "function mock_storage in tests\\client\\test_auth.py",
        "matched template: authenticate a user and return a token (sim=0.25)"
      ]
    },
    {
      "name": "client_metadata",
      "description": "make an HTTP request to an external API. Function `client_metadata`.",
      "predicted_filename": "tests\\client\\test_auth.py",
      "predicted_code_snippet": "def client_metadata():\n    return OAuthClientMetadata(\n        client_name=\"Test Client\",\n        client_uri=AnyHttpUrl(\"https://example.com\"),\n        redirect_uris=[AnyUrl(\"http://localhost:3030/callback\")],\n        scope=\"read write\",\n    )",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `client_metadata` in tests\\client\\test_auth.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.24,
      "evidence": [
        "function client_metadata in tests\\client\\test_auth.py",
        "matched template: make an HTTP request to an external API (sim=0.29)"
      ]
    },
    {
      "name": "valid_tokens",
      "description": "authenticate a user and return a token. Function `valid_tokens`.",
      "predicted_filename": "tests\\client\\test_auth.py",
      "predicted_code_snippet": "def valid_tokens():\n    return OAuthToken(\n        access_token=\"test_access_token\",\n        token_type=\"Bearer\",\n        expires_in=3600,\n        refresh_token=\"test_refresh_token\",\n        scope=\"read write\",\n    )",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `valid_tokens` in tests\\client\\test_auth.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.31,
      "evidence": [
        "function valid_tokens in tests\\client\\test_auth.py",
        "matched template: authenticate a user and return a token (sim=0.40)"
      ]
    },
    {
      "name": "oauth_provider",
      "description": "authenticate a user and return a token. Function `oauth_provider`.",
      "predicted_filename": "tests\\client\\test_auth.py",
      "predicted_code_snippet": "def oauth_provider(client_metadata: OAuthClientMetadata, mock_storage: MockTokenStorage):\n    async def redirect_handler(url: str) -> None:\n        \"\"\"Mock redirect handler.\"\"\"\n        pass  # pragma: no cover\n\n    async def callback_handler() -> tuple[str, str | None]:\n        \"\"\"Mock callback handler.\"\"\"\n        return \"test_auth_code\", \"test_state\"  # pragma: no cover\n\n    return OAuthClientProvider(\n        server_url=\"https://api.example.com/v1/mcp\",\n        client_metadata=client_metadata,\n        storage=mock_storage,\n        redirect_handler=redirect_handler,\n        callback_handler=callback_handler,\n    )",
      "input_schema": {
        "type": "object",
        "properties": {
          "client_metadata": {
            "type": "string",
            "required": true
          },
          "mock_storage": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "client_metadata",
          "mock_storage"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "client_metadata": "string",
          "mock_storage": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `oauth_provider` in tests\\client\\test_auth.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.26,
      "evidence": [
        "function oauth_provider in tests\\client\\test_auth.py",
        "matched template: authenticate a user and return a token (sim=0.33)"
      ]
    },
    {
      "name": "prm_metadata_response",
      "description": "make an HTTP request to an external API. Function `prm_metadata_response`.",
      "predicted_filename": "tests\\client\\test_auth.py",
      "predicted_code_snippet": "def prm_metadata_response():\n    \"\"\"PRM metadata response with scopes.\"\"\"\n    return httpx.Response(\n        200,\n        content=(\n            b'{\"resource\": \"https://api.example.com/v1/mcp\", '\n            b'\"authorization_servers\": [\"https://auth.example.com\"], '\n            b'\"scopes_supported\": [\"resource:read\", \"resource:write\"]}'\n        ),\n    )",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `prm_metadata_response` in tests\\client\\test_auth.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.24,
      "evidence": [
        "function prm_metadata_response in tests\\client\\test_auth.py",
        "matched template: make an HTTP request to an external API (sim=0.29)"
      ]
    },
    {
      "name": "prm_metadata_without_scopes_response",
      "description": "make an HTTP request to an external API. Function `prm_metadata_without_scopes_response`.",
      "predicted_filename": "tests\\client\\test_auth.py",
      "predicted_code_snippet": "def prm_metadata_without_scopes_response():\n    \"\"\"PRM metadata response without scopes.\"\"\"\n    return httpx.Response(\n        200,\n        content=(\n            b'{\"resource\": \"https://api.example.com/v1/mcp\", '\n            b'\"authorization_servers\": [\"https://auth.example.com\"], '\n            b'\"scopes_supported\": null}'\n        ),\n    )",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `prm_metadata_without_scopes_response` in tests\\client\\test_auth.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.24,
      "evidence": [
        "function prm_metadata_without_scopes_response in tests\\client\\test_auth.py",
        "matched template: make an HTTP request to an external API (sim=0.29)"
      ]
    },
    {
      "name": "init_response_with_www_auth_scope",
      "description": "authenticate a user and return a token. Function `init_response_with_www_auth_scope`.",
      "predicted_filename": "tests\\client\\test_auth.py",
      "predicted_code_snippet": "def init_response_with_www_auth_scope():\n    \"\"\"Initial 401 response with WWW-Authenticate header containing scope.\"\"\"\n    return httpx.Response(\n        401,\n        headers={\"WWW-Authenticate\": 'Bearer scope=\"special:scope from:www-authenticate\"'},\n        request=httpx.Request(\"GET\", \"https://api.example.com/test\"),\n    )",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `init_response_with_www_auth_scope` in tests\\client\\test_auth.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.27,
      "evidence": [
        "function init_response_with_www_auth_scope in tests\\client\\test_auth.py",
        "matched template: authenticate a user and return a token (sim=0.35)"
      ]
    },
    {
      "name": "init_response_without_www_auth_scope",
      "description": "make an HTTP request to an external API. Function `init_response_without_www_auth_scope`.",
      "predicted_filename": "tests\\client\\test_auth.py",
      "predicted_code_snippet": "def init_response_without_www_auth_scope():\n    \"\"\"Initial 401 response without WWW-Authenticate scope.\"\"\"\n    return httpx.Response(\n        401,\n        headers={},\n        request=httpx.Request(\"GET\", \"https://api.example.com/test\"),\n    )",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `init_response_without_www_auth_scope` in tests\\client\\test_auth.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.29,
      "evidence": [
        "function init_response_without_www_auth_scope in tests\\client\\test_auth.py",
        "matched template: make an HTTP request to an external API (sim=0.37)"
      ]
    },
    {
      "name": "test_build_metadata",
      "description": "authenticate a user and return a token. Function `test_build_metadata`.",
      "predicted_filename": "tests\\client\\test_auth.py",
      "predicted_code_snippet": "def test_build_metadata(\n    issuer_url: str,\n    service_documentation_url: str,\n    authorization_endpoint: str,\n    token_endpoint: str,\n    registration_endpoint: str,\n    revocation_endpoint: str,\n):\n    from mcp.server.auth.routes import build_metadata\n    from mcp.server.auth.settings import ClientRegistrationOptions, RevocationOptions\n\n    metadata = build_metadata(\n        issuer_url=AnyHttpUrl(issuer_url),\n        service_documentation_url=AnyHttpUrl(service_documentation_url),\n        client_registration_options=ClientRegistrationOptions(enabled=True, valid_scopes=[\"read\", \"write\", \"admin\"]),\n        revocation_options=RevocationOptions(enabled=True),\n    )\n\n    assert metadata.model_dump(exclude_defaults=True, mode=\"json\") == snapshot(\n        {\n            \"issuer\": Is(issuer_url),\n            \"authorization_endpoint\": Is(authorization_endpoint),\n            \"token_endpoint\": Is(token_endpoint),\n            \"registration_endpoint\": Is(registration_endpoint),\n            \"scopes_supported\": [\"read\", \"write\", \"admin\"],\n            \"grant_types_supported\": [\"authorization_code\", \"refresh_token\"],\n            \"token_endpoint_auth_methods_supported\": [\"client_secret_post\"],\n            \"service_documentation\": Is(service_documentation_url),\n            \"revocation_endpoint\": Is(revocation_endpoint),\n            \"revocation_endpoint_auth_methods_supported\": [\"client_secret_post\"],\n            \"code_challenge_methods_supported\": [\"S256\"],\n        }\n    )",
      "input_schema": {
        "type": "object",
        "properties": {
          "issuer_url": {
            "type": "string",
            "required": true
          },
          "service_documentation_url": {
            "type": "string",
            "required": true
          },
          "authorization_endpoint": {
            "type": "string",
            "required": true
          },
          "token_endpoint": {
            "type": "string",
            "required": true
          },
          "registration_endpoint": {
            "type": "string",
            "required": true
          },
          "revocation_endpoint": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "issuer_url",
          "service_documentation_url",
          "authorization_endpoint",
          "token_endpoint",
          "registration_endpoint",
          "revocation_endpoint"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "issuer_url": "string",
          "service_documentation_url": "string",
          "authorization_endpoint": "string",
          "token_endpoint": "string",
          "registration_endpoint": "string",
          "revocation_endpoint": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_build_metadata` in tests\\client\\test_auth.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.19,
      "evidence": [
        "function test_build_metadata in tests\\client\\test_auth.py",
        "matched template: authenticate a user and return a token (sim=0.18)"
      ]
    },
    {
      "name": "temp_config_dir",
      "description": "list files in a directory. Function `temp_config_dir`.",
      "predicted_filename": "tests\\client\\test_config.py",
      "predicted_code_snippet": "def temp_config_dir(tmp_path: Path):\n    \"\"\"Create a temporary Claude config directory.\"\"\"\n    config_dir = tmp_path / \"Claude\"\n    config_dir.mkdir()\n    return config_dir",
      "input_schema": {
        "type": "object",
        "properties": {
          "tmp_path": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "tmp_path"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "tmp_path": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `temp_config_dir` in tests\\client\\test_config.py",
      "possible_syscalls": [
        {
          "syscall": "execve/system",
          "reason": "calls to subprocess or os.system"
        }
      ],
      "confidence": 0.2,
      "evidence": [
        "function temp_config_dir in tests\\client\\test_config.py",
        "matched template: list files in a directory (sim=0.21)"
      ]
    },
    {
      "name": "mock_config_path",
      "description": "execute a shell command. Function `mock_config_path`.",
      "predicted_filename": "tests\\client\\test_config.py",
      "predicted_code_snippet": "def mock_config_path(temp_config_dir: Path):\n    \"\"\"Mock get_claude_config_path to return our temporary directory.\"\"\"\n    with patch(\"mcp.cli.claude.get_claude_config_path\", return_value=temp_config_dir):\n        yield temp_config_dir",
      "input_schema": {
        "type": "object",
        "properties": {
          "temp_config_dir": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "temp_config_dir"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "temp_config_dir": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `mock_config_path` in tests\\client\\test_config.py",
      "possible_syscalls": [
        {
          "syscall": "execve/system",
          "reason": "calls to subprocess or os.system"
        }
      ],
      "confidence": 0.18,
      "evidence": [
        "function mock_config_path in tests\\client\\test_config.py",
        "matched template: execute a shell command (sim=0.15)"
      ]
    },
    {
      "name": "test_command_execution",
      "description": "execute a shell command. Function `test_command_execution`.",
      "predicted_filename": "tests\\client\\test_config.py",
      "predicted_code_snippet": "def test_command_execution(mock_config_path: Path):\n    \"\"\"Test that the generated command can actually be executed.\"\"\"\n    # Setup\n    server_name = \"test_server\"\n    file_spec = \"test_server.py:app\"\n\n    # Update config\n    success = update_claude_config(file_spec=file_spec, server_name=server_name)\n    assert success\n\n    # Read the generated config\n    config_file = mock_config_path / \"claude_desktop_config.json\"\n    config = json.loads(config_file.read_text())\n\n    # Get the command and args\n    server_config = config[\"mcpServers\"][server_name]\n    command = server_config[\"command\"]\n    args = server_config[\"args\"]\n\n    test_args = [command] + args + [\"--help\"]\n\n    result = subprocess.run(test_args, capture_output=True, text=True, timeout=20, check=False)\n\n    assert result.returncode == 0\n    assert \"usage\" in result.stdout.lower()",
      "input_schema": {
        "type": "object",
        "properties": {
          "mock_config_path": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "mock_config_path"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "mock_config_path": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_command_execution` in tests\\client\\test_config.py",
      "possible_syscalls": [
        {
          "syscall": "execve/system",
          "reason": "calls to subprocess or os.system"
        }
      ],
      "confidence": 0.23,
      "evidence": [
        "function test_command_execution in tests\\client\\test_config.py",
        "matched template: execute a shell command (sim=0.28)"
      ]
    },
    {
      "name": "test_absolute_uv_path",
      "description": "execute a shell command. Function `test_absolute_uv_path`.",
      "predicted_filename": "tests\\client\\test_config.py",
      "predicted_code_snippet": "def test_absolute_uv_path(mock_config_path: Path):\n    \"\"\"Test that the absolute path to uv is used when available.\"\"\"\n    # Mock the shutil.which function to return a fake path\n    mock_uv_path = \"/usr/local/bin/uv\"\n\n    with patch(\"mcp.cli.claude.get_uv_path\", return_value=mock_uv_path):\n        # Setup\n        server_name = \"test_server\"\n        file_spec = \"test_server.py:app\"\n\n        # Update config\n        success = update_claude_config(file_spec=file_spec, server_name=server_name)\n        assert success\n\n        # Read the generated config\n        config_file = mock_config_path / \"claude_desktop_config.json\"\n        config = json.loads(config_file.read_text())\n\n        # Verify the command is the absolute path\n        server_config = config[\"mcpServers\"][server_name]\n        command = server_config[\"command\"]\n\n        assert command == mock_uv_path",
      "input_schema": {
        "type": "object",
        "properties": {
          "mock_config_path": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "mock_config_path"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "mock_config_path": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_absolute_uv_path` in tests\\client\\test_config.py",
      "possible_syscalls": [
        {
          "syscall": "execve/system",
          "reason": "calls to subprocess or os.system"
        }
      ],
      "confidence": 0.17,
      "evidence": [
        "function test_absolute_uv_path in tests\\client\\test_config.py",
        "matched template: execute a shell command (sim=0.14)"
      ]
    },
    {
      "name": "run_unicode_server",
      "description": "stream data over websocket. Function `run_unicode_server`.",
      "predicted_filename": "tests\\client\\test_http_unicode.py",
      "predicted_code_snippet": "def run_unicode_server(port: int) -> None:  # pragma: no cover\n    \"\"\"Run the Unicode test server in a separate process.\"\"\"\n    # Import inside the function since this runs in a separate process\n    from collections.abc import AsyncGenerator\n    from contextlib import asynccontextmanager\n    from typing import Any\n\n    import uvicorn\n    from starlette.applications import Starlette\n    from starlette.routing import Mount\n\n    import mcp.types as types\n    from mcp.server import Server\n    from mcp.server.streamable_http_manager import StreamableHTTPSessionManager\n    from mcp.types import TextContent, Tool\n\n    # Need to recreate the server setup in this process\n    server = Server(name=\"unicode_test_server\")\n\n    @server.list_tools()\n    async def list_tools() -> list[Tool]:\n        \"\"\"List tools with Unicode descriptions.\"\"\"\n        return [\n            Tool(\n                name=\"echo_unicode\",\n                description=\"\ud83d\udd24 Echo Unicode text - Hello \ud83d\udc4b World \ud83c\udf0d - Testing \ud83e\uddea Unicode \u2728\",\n                inputSchema={\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"text\": {\"type\": \"string\", \"description\": \"Text to echo back\"},\n                    },\n                    \"required\": [\"text\"],\n                },\n            ),\n        ]\n\n    @server.call_tool()\n    async def call_tool(name: str, arguments: dict[str, Any] | None) -> list[TextContent]:\n        \"\"\"Handle tool calls with Unicode content.\"\"\"\n        if name == \"echo_unicode\":\n            text = arguments.get(\"text\", \"\") if arguments else \"\"\n            return [\n                TextContent(\n                    type=\"text\",\n                    text=f\"Echo: {text}\",\n                )\n            ]\n        else:\n            raise ValueError(f\"Unknown tool: {name}\")\n\n    @server.list_prompts()\n    async def list_prompts() -> list[types.Prompt]:\n        \"\"\"List prompts with Unicode names and descriptions.\"\"\"\n        return [\n            types.Prompt(\n                name=\"unicode_prompt\",\n                description=\"Unicode prompt - \u0421\u043b\u043e\u0439 \u0445\u0440\u0430\u043d\u0438\u043b\u0438\u0449\u0430, \u0433\u0434\u0435 \u0440\u0430\u0441\u043f\u043e\u043b\u0430\u0433\u0430\u044e\u0442\u0441\u044f\",\n                arguments=[],\n            )\n        ]\n\n    @server.get_prompt()\n    async def get_prompt(name: str, arguments: dict[str, Any] | None) -> types.GetPromptResult:\n        \"\"\"Get a prompt with Unicode content.\"\"\"\n        if name == \"unicode_prompt\":\n            return types.GetPromptResult(\n                messages=[\n                    types.PromptMessage(\n                        role=\"user\",\n                        content=types.TextContent(\n                            type=\"text\",\n                            text=\"Hello\u4e16\u754c\ud83c\udf0d\u041f\u0440\u0438\u0432\u0435\u0442\uc548\ub155\u0645\u0631\u062d\u0628\u0627\u05e9\u05dc\u05d5\u05dd\",\n                        ),\n                    )\n                ]\n            )\n        raise ValueError(f\"Unknown prompt: {name}\")\n\n    # Create the session manager\n    session_manager = StreamableHTTPSessionManager(\n        app=server,\n        json_response=False,  # Use SSE for testing\n    )\n\n    @asynccontextmanager\n    async def lifespan(app: Starlette) -> AsyncGenerator[None, None]:\n        async with session_manager.run():\n            yield\n\n    # Create an ASGI application\n    app = Starlette(\n        debug=True,\n        routes=[\n            Mount(\"/mcp\", app=session_manager.handle_request),\n        ],\n        lifespan=lifespan,\n    )\n\n    # Run the server\n    config = uvicorn.Config(\n        app=app,\n        host=\"127.0.0.1\",\n        port=port,\n        log_level=\"error\",\n    )\n    uvicorn_server = uvicorn.Server(config)\n    uvicorn_server.run()",
      "input_schema": {
        "type": "object",
        "properties": {
          "port": {
            "type": "integer",
            "required": true
          }
        },
        "required": [
          "port"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "port": "integer"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `run_unicode_server` in tests\\client\\test_http_unicode.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        }
      ],
      "confidence": 0.2,
      "evidence": [
        "function run_unicode_server in tests\\client\\test_http_unicode.py",
        "matched template: stream data over websocket (sim=0.22)"
      ]
    },
    {
      "name": "unicode_server_port",
      "description": "stream data over websocket. Function `unicode_server_port`.",
      "predicted_filename": "tests\\client\\test_http_unicode.py",
      "predicted_code_snippet": "def unicode_server_port() -> int:\n    \"\"\"Find an available port for the Unicode test server.\"\"\"\n    with socket.socket() as s:\n        s.bind((\"127.0.0.1\", 0))\n        return s.getsockname()[1]",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "integer"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "integer"
        }
      },
      "explanation": "Detected Python function `unicode_server_port` in tests\\client\\test_http_unicode.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        }
      ],
      "confidence": 0.26,
      "evidence": [
        "function unicode_server_port in tests\\client\\test_http_unicode.py",
        "matched template: stream data over websocket (sim=0.33)"
      ]
    },
    {
      "name": "running_unicode_server",
      "description": "stream data over websocket. Function `running_unicode_server`.",
      "predicted_filename": "tests\\client\\test_http_unicode.py",
      "predicted_code_snippet": "def running_unicode_server(unicode_server_port: int) -> Generator[str, None, None]:\n    \"\"\"Start a Unicode test server in a separate process.\"\"\"\n    proc = multiprocessing.Process(target=run_unicode_server, kwargs={\"port\": unicode_server_port}, daemon=True)\n    proc.start()\n\n    # Wait for server to be ready\n    wait_for_server(unicode_server_port)\n\n    try:\n        yield f\"http://127.0.0.1:{unicode_server_port}\"\n    finally:\n        # Clean up - try graceful termination first\n        proc.terminate()\n        proc.join(timeout=2)\n        if proc.is_alive():  # pragma: no cover\n            proc.kill()\n            proc.join(timeout=1)",
      "input_schema": {
        "type": "object",
        "properties": {
          "unicode_server_port": {
            "type": "integer",
            "required": true
          }
        },
        "required": [
          "unicode_server_port"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "unicode_server_port": "integer"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `running_unicode_server` in tests\\client\\test_http_unicode.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        }
      ],
      "confidence": 0.21,
      "evidence": [
        "function running_unicode_server in tests\\client\\test_http_unicode.py",
        "matched template: stream data over websocket (sim=0.23)"
      ]
    },
    {
      "name": "create_non_sdk_server_app",
      "description": "make an HTTP request to an external API. Function `create_non_sdk_server_app`.",
      "predicted_filename": "tests\\client\\test_notification_response.py",
      "predicted_code_snippet": "def create_non_sdk_server_app() -> Starlette:  # pragma: no cover\n    \"\"\"Create a minimal server that doesn't follow SDK conventions.\"\"\"\n\n    async def handle_mcp_request(request: Request) -> Response:\n        \"\"\"Handle MCP requests with non-standard responses.\"\"\"\n        try:\n            body = await request.body()\n            data = json.loads(body)\n\n            # Handle initialize request normally\n            if data.get(\"method\") == \"initialize\":\n                response_data = {\n                    \"jsonrpc\": \"2.0\",\n                    \"id\": data[\"id\"],\n                    \"result\": {\n                        \"serverInfo\": {\"name\": \"test-non-sdk-server\", \"version\": \"1.0.0\"},\n                        \"protocolVersion\": \"2024-11-05\",\n                        \"capabilities\": {},\n                    },\n                }\n                return JSONResponse(response_data)\n\n            # For notifications, return 204 No Content (non-SDK behavior)\n            if \"id\" not in data:\n                return Response(status_code=204, headers={\"Content-Type\": \"application/json\"})\n\n            # Default response for other requests\n            return JSONResponse(\n                {\"jsonrpc\": \"2.0\", \"id\": data.get(\"id\"), \"error\": {\"code\": -32601, \"message\": \"Method not found\"}}\n            )\n\n        except Exception as e:\n            return JSONResponse({\"error\": f\"Server error: {str(e)}\"}, status_code=500)\n\n    app = Starlette(\n        debug=True,\n        routes=[\n            Route(\"/mcp\", handle_mcp_request, methods=[\"POST\"]),\n        ],\n    )\n    return app",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `create_non_sdk_server_app` in tests\\client\\test_notification_response.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        }
      ],
      "confidence": 0.25,
      "evidence": [
        "function create_non_sdk_server_app in tests\\client\\test_notification_response.py",
        "matched template: make an HTTP request to an external API (sim=0.30)"
      ]
    },
    {
      "name": "run_non_sdk_server",
      "description": "stream data over websocket. Function `run_non_sdk_server`.",
      "predicted_filename": "tests\\client\\test_notification_response.py",
      "predicted_code_snippet": "def run_non_sdk_server(port: int) -> None:  # pragma: no cover\n    \"\"\"Run the non-SDK server in a separate process.\"\"\"\n    app = create_non_sdk_server_app()\n    config = uvicorn.Config(\n        app=app,\n        host=\"127.0.0.1\",\n        port=port,\n        log_level=\"error\",  # Reduce noise in tests\n    )\n    server = uvicorn.Server(config=config)\n    server.run()",
      "input_schema": {
        "type": "object",
        "properties": {
          "port": {
            "type": "integer",
            "required": true
          }
        },
        "required": [
          "port"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "port": "integer"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `run_non_sdk_server` in tests\\client\\test_notification_response.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        }
      ],
      "confidence": 0.23,
      "evidence": [
        "function run_non_sdk_server in tests\\client\\test_notification_response.py",
        "matched template: stream data over websocket (sim=0.28)"
      ]
    },
    {
      "name": "non_sdk_server_port",
      "description": "stream data over websocket. Function `non_sdk_server_port`.",
      "predicted_filename": "tests\\client\\test_notification_response.py",
      "predicted_code_snippet": "def non_sdk_server_port() -> int:\n    \"\"\"Get an available port for the test server.\"\"\"\n    with socket.socket() as s:\n        s.bind((\"127.0.0.1\", 0))\n        return s.getsockname()[1]",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "integer"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "integer"
        }
      },
      "explanation": "Detected Python function `non_sdk_server_port` in tests\\client\\test_notification_response.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        }
      ],
      "confidence": 0.28,
      "evidence": [
        "function non_sdk_server_port in tests\\client\\test_notification_response.py",
        "matched template: stream data over websocket (sim=0.35)"
      ]
    },
    {
      "name": "non_sdk_server",
      "description": "stream data over websocket. Function `non_sdk_server`.",
      "predicted_filename": "tests\\client\\test_notification_response.py",
      "predicted_code_snippet": "def non_sdk_server(non_sdk_server_port: int) -> Generator[None, None, None]:\n    \"\"\"Start a non-SDK server for testing.\"\"\"\n    proc = multiprocessing.Process(target=run_non_sdk_server, kwargs={\"port\": non_sdk_server_port}, daemon=True)\n    proc.start()\n\n    # Wait for server to be ready\n    try:  # pragma: no cover\n        wait_for_server(non_sdk_server_port, timeout=10.0)\n    except TimeoutError:  # pragma: no cover\n        proc.kill()\n        proc.join(timeout=2)\n        pytest.fail(\"Server failed to start within 10 seconds\")\n\n    yield\n\n    proc.kill()\n    proc.join(timeout=2)",
      "input_schema": {
        "type": "object",
        "properties": {
          "non_sdk_server_port": {
            "type": "integer",
            "required": true
          }
        },
        "required": [
          "non_sdk_server_port"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "non_sdk_server_port": "integer"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `non_sdk_server` in tests\\client\\test_notification_response.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        }
      ],
      "confidence": 0.21,
      "evidence": [
        "function non_sdk_server in tests\\client\\test_notification_response.py",
        "matched template: stream data over websocket (sim=0.23)"
      ]
    },
    {
      "name": "bypass_server_output_validation",
      "description": "parse JSON input and validate fields. Function `bypass_server_output_validation`.",
      "predicted_filename": "tests\\client\\test_output_schema_validation.py",
      "predicted_code_snippet": "def bypass_server_output_validation():\n    \"\"\"\n    Context manager that bypasses server-side output validation.\n    This simulates a malicious or non-compliant server that doesn't validate\n    its outputs, allowing us to test client-side validation.\n    \"\"\"\n    import jsonschema\n\n    # Save the original validate function\n    original_validate = jsonschema.validate\n\n    # Create a mock that tracks which module is calling it\n    def selective_mock(instance: Any = None, schema: Any = None, *args: Any, **kwargs: Any) -> None:\n        import inspect\n\n        # Check the call stack to see where this is being called from\n        for frame_info in inspect.stack():\n            # If called from the server module, skip validation\n            # TODO: fix this as it's a rather gross workaround and will eventually break\n            # Normalize path separators for cross-platform compatibility\n            normalized_path = frame_info.filename.replace(\"\\\\\", \"/\")\n            if \"mcp/server/lowlevel/server.py\" in normalized_path:\n                return None\n        # Otherwise, use the real validation (for client-side)\n        return original_validate(instance=instance, schema=schema, *args, **kwargs)\n\n    with patch(\"jsonschema.validate\", selective_mock):\n        yield",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `bypass_server_output_validation` in tests\\client\\test_output_schema_validation.py",
      "possible_syscalls": [],
      "confidence": 0.25,
      "evidence": [
        "function bypass_server_output_validation in tests\\client\\test_output_schema_validation.py",
        "matched template: parse JSON input and validate fields (sim=0.31)"
      ]
    },
    {
      "name": "mock_exit_stack",
      "description": "handle a HTTP route request and return response. Function `mock_exit_stack`.",
      "predicted_filename": "tests\\client\\test_session_group.py",
      "predicted_code_snippet": "def mock_exit_stack():\n    \"\"\"Fixture for a mocked AsyncExitStack.\"\"\"\n    # Use unittest.mock.Mock directly if needed, or just a plain object\n    # if only attribute access/existence is needed.\n    # For AsyncExitStack, Mock or MagicMock is usually fine.\n    return mock.MagicMock(spec=contextlib.AsyncExitStack)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `mock_exit_stack` in tests\\client\\test_session_group.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function mock_exit_stack in tests\\client\\test_session_group.py",
        "matched template: handle a HTTP route request and return response (sim=0.12)"
      ]
    },
    {
      "name": "mock_storage",
      "description": "authenticate a user and return a token. Function `mock_storage`.",
      "predicted_filename": "tests\\client\\auth\\extensions\\test_client_credentials.py",
      "predicted_code_snippet": "def mock_storage():\n    return MockTokenStorage()",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `mock_storage` in tests\\client\\auth\\extensions\\test_client_credentials.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.28,
      "evidence": [
        "function mock_storage in tests\\client\\auth\\extensions\\test_client_credentials.py",
        "matched template: authenticate a user and return a token (sim=0.36)"
      ]
    },
    {
      "name": "client_metadata",
      "description": "authenticate a user and return a token. Function `client_metadata`.",
      "predicted_filename": "tests\\client\\auth\\extensions\\test_client_credentials.py",
      "predicted_code_snippet": "def client_metadata():\n    return OAuthClientMetadata(\n        client_name=\"Test Client\",\n        client_uri=AnyHttpUrl(\"https://example.com\"),\n        redirect_uris=[AnyUrl(\"http://localhost:3030/callback\")],\n        scope=\"read write\",\n    )",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `client_metadata` in tests\\client\\auth\\extensions\\test_client_credentials.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.27,
      "evidence": [
        "function client_metadata in tests\\client\\auth\\extensions\\test_client_credentials.py",
        "matched template: authenticate a user and return a token (sim=0.35)"
      ]
    },
    {
      "name": "rfc7523_oauth_provider",
      "description": "authenticate a user and return a token. Function `rfc7523_oauth_provider`.",
      "predicted_filename": "tests\\client\\auth\\extensions\\test_client_credentials.py",
      "predicted_code_snippet": "def rfc7523_oauth_provider(client_metadata: OAuthClientMetadata, mock_storage: MockTokenStorage):\n    async def redirect_handler(url: str) -> None:  # pragma: no cover\n        \"\"\"Mock redirect handler.\"\"\"\n        pass\n\n    async def callback_handler() -> tuple[str, str | None]:  # pragma: no cover\n        \"\"\"Mock callback handler.\"\"\"\n        return \"test_auth_code\", \"test_state\"\n\n    return RFC7523OAuthClientProvider(\n        server_url=\"https://api.example.com/v1/mcp\",\n        client_metadata=client_metadata,\n        storage=mock_storage,\n        redirect_handler=redirect_handler,\n        callback_handler=callback_handler,\n    )",
      "input_schema": {
        "type": "object",
        "properties": {
          "client_metadata": {
            "type": "string",
            "required": true
          },
          "mock_storage": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "client_metadata",
          "mock_storage"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "client_metadata": "string",
          "mock_storage": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `rfc7523_oauth_provider` in tests\\client\\auth\\extensions\\test_client_credentials.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.28,
      "evidence": [
        "function rfc7523_oauth_provider in tests\\client\\auth\\extensions\\test_client_credentials.py",
        "matched template: authenticate a user and return a token (sim=0.36)"
      ]
    },
    {
      "name": "query_db",
      "description": "perform database query and return records. Function `query_db`.",
      "predicted_filename": "tests\\issues\\test_355_type_error.py",
      "predicted_code_snippet": "def query_db(ctx: Context[ServerSession, AppContext]) -> str:  # pragma: no cover\n    \"\"\"Tool that uses initialized resources\"\"\"\n    db = ctx.request_context.lifespan_context.db\n    return db.query()",
      "input_schema": {
        "type": "object",
        "properties": {
          "ctx": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "ctx"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "ctx": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `query_db` in tests\\issues\\test_355_type_error.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function query_db in tests\\issues\\test_355_type_error.py",
        "matched template: perform database query and return records (sim=0.26)"
      ]
    },
    {
      "name": "create_add_tool",
      "description": "parse JSON input and validate fields. Function `create_add_tool`.",
      "predicted_filename": "tests\\server\\test_lowlevel_input_validation.py",
      "predicted_code_snippet": "def create_add_tool() -> Tool:\n    \"\"\"Create a standard 'add' tool for testing.\"\"\"\n    return Tool(\n        name=\"add\",\n        description=\"Add two numbers\",\n        inputSchema={\n            \"type\": \"object\",\n            \"properties\": {\n                \"a\": {\"type\": \"number\"},\n                \"b\": {\"type\": \"number\"},\n            },\n            \"required\": [\"a\", \"b\"],\n            \"additionalProperties\": False,\n        },\n    )",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `create_add_tool` in tests\\server\\test_lowlevel_input_validation.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function create_add_tool in tests\\server\\test_lowlevel_input_validation.py",
        "matched template: parse JSON input and validate fields (sim=0.21)"
      ]
    },
    {
      "name": "temp_file",
      "description": "write data to a file. Function `temp_file`.",
      "predicted_filename": "tests\\server\\test_read_resource.py",
      "predicted_code_snippet": "def temp_file():\n    \"\"\"Create a temporary file for testing.\"\"\"\n    with NamedTemporaryFile(mode=\"w\", delete=False) as f:\n        f.write(\"test content\")\n        path = Path(f.name).resolve()\n    yield path\n    try:\n        path.unlink()\n    except FileNotFoundError:  # pragma: no cover\n        pass",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `temp_file` in tests\\server\\test_read_resource.py",
      "possible_syscalls": [],
      "confidence": 0.3,
      "evidence": [
        "function temp_file in tests\\server\\test_read_resource.py",
        "matched template: write data to a file (sim=0.39)"
      ]
    },
    {
      "name": "server_port",
      "description": "stream data over websocket. Function `server_port`.",
      "predicted_filename": "tests\\server\\test_sse_security.py",
      "predicted_code_snippet": "def server_port() -> int:\n    with socket.socket() as s:\n        s.bind((\"127.0.0.1\", 0))\n        return s.getsockname()[1]",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "integer"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "integer"
        }
      },
      "explanation": "Detected Python function `server_port` in tests\\server\\test_sse_security.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        }
      ],
      "confidence": 0.22,
      "evidence": [
        "function server_port in tests\\server\\test_sse_security.py",
        "matched template: stream data over websocket (sim=0.26)"
      ]
    },
    {
      "name": "server_url",
      "description": "handle a HTTP route request and return response. Function `server_url`.",
      "predicted_filename": "tests\\server\\test_sse_security.py",
      "predicted_code_snippet": "def server_url(server_port: int) -> str:  # pragma: no cover\n    return f\"http://127.0.0.1:{server_port}\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "server_port": {
            "type": "integer",
            "required": true
          }
        },
        "required": [
          "server_port"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "server_port": "integer"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `server_url` in tests\\server\\test_sse_security.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        }
      ],
      "confidence": 0.21,
      "evidence": [
        "function server_url in tests\\server\\test_sse_security.py",
        "matched template: handle a HTTP route request and return response (sim=0.22)"
      ]
    },
    {
      "name": "run_server_with_settings",
      "description": "stream data over websocket. Function `run_server_with_settings`.",
      "predicted_filename": "tests\\server\\test_sse_security.py",
      "predicted_code_snippet": "def run_server_with_settings(port: int, security_settings: TransportSecuritySettings | None = None):  # pragma: no cover\n    \"\"\"Run the SSE server with specified security settings.\"\"\"\n    app = SecurityTestServer()\n    sse_transport = SseServerTransport(\"/messages/\", security_settings)\n\n    async def handle_sse(request: Request):\n        try:\n            async with sse_transport.connect_sse(request.scope, request.receive, request._send) as streams:\n                if streams:\n                    await app.run(streams[0], streams[1], app.create_initialization_options())\n        except ValueError as e:\n            # Validation error was already handled inside connect_sse\n            logger.debug(f\"SSE connection failed validation: {e}\")\n        return Response()\n\n    routes = [\n        Route(\"/sse\", endpoint=handle_sse),\n        Mount(\"/messages/\", app=sse_transport.handle_post_message),\n    ]\n\n    starlette_app = Starlette(routes=routes)\n    uvicorn.run(starlette_app, host=\"127.0.0.1\", port=port, log_level=\"error\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "port": {
            "type": "integer",
            "required": true
          },
          "security_settings": {
            "type": "string",
            "required": false
          }
        },
        "required": [
          "port"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "port": "integer",
          "security_settings": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `run_server_with_settings` in tests\\server\\test_sse_security.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        }
      ],
      "confidence": 0.26,
      "evidence": [
        "function run_server_with_settings in tests\\server\\test_sse_security.py",
        "matched template: stream data over websocket (sim=0.32)"
      ]
    },
    {
      "name": "start_server_process",
      "description": "stream data over websocket. Function `start_server_process`.",
      "predicted_filename": "tests\\server\\test_sse_security.py",
      "predicted_code_snippet": "def start_server_process(port: int, security_settings: TransportSecuritySettings | None = None):\n    \"\"\"Start server in a separate process.\"\"\"\n    process = multiprocessing.Process(target=run_server_with_settings, args=(port, security_settings))\n    process.start()\n    # Wait for server to be ready to accept connections\n    wait_for_server(port)\n    return process",
      "input_schema": {
        "type": "object",
        "properties": {
          "port": {
            "type": "integer",
            "required": true
          },
          "security_settings": {
            "type": "string",
            "required": false
          }
        },
        "required": [
          "port"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "port": "integer",
          "security_settings": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `start_server_process` in tests\\server\\test_sse_security.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        }
      ],
      "confidence": 0.2,
      "evidence": [
        "function start_server_process in tests\\server\\test_sse_security.py",
        "matched template: stream data over websocket (sim=0.21)"
      ]
    },
    {
      "name": "server_port",
      "description": "stream data over websocket. Function `server_port`.",
      "predicted_filename": "tests\\server\\test_streamable_http_security.py",
      "predicted_code_snippet": "def server_port() -> int:\n    with socket.socket() as s:\n        s.bind((\"127.0.0.1\", 0))\n        return s.getsockname()[1]",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "integer"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "integer"
        }
      },
      "explanation": "Detected Python function `server_port` in tests\\server\\test_streamable_http_security.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        }
      ],
      "confidence": 0.3,
      "evidence": [
        "function server_port in tests\\server\\test_streamable_http_security.py",
        "matched template: stream data over websocket (sim=0.38)"
      ]
    },
    {
      "name": "server_url",
      "description": "stream data over websocket. Function `server_url`.",
      "predicted_filename": "tests\\server\\test_streamable_http_security.py",
      "predicted_code_snippet": "def server_url(server_port: int) -> str:  # pragma: no cover\n    return f\"http://127.0.0.1:{server_port}\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "server_port": {
            "type": "integer",
            "required": true
          }
        },
        "required": [
          "server_port"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "server_port": "integer"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `server_url` in tests\\server\\test_streamable_http_security.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        }
      ],
      "confidence": 0.27,
      "evidence": [
        "function server_url in tests\\server\\test_streamable_http_security.py",
        "matched template: stream data over websocket (sim=0.34)"
      ]
    },
    {
      "name": "run_server_with_settings",
      "description": "stream data over websocket. Function `run_server_with_settings`.",
      "predicted_filename": "tests\\server\\test_streamable_http_security.py",
      "predicted_code_snippet": "def run_server_with_settings(port: int, security_settings: TransportSecuritySettings | None = None):  # pragma: no cover\n    \"\"\"Run the StreamableHTTP server with specified security settings.\"\"\"\n    app = SecurityTestServer()\n\n    # Create session manager with security settings\n    session_manager = StreamableHTTPSessionManager(\n        app=app,\n        json_response=False,\n        stateless=False,\n        security_settings=security_settings,\n    )\n\n    # Create the ASGI handler\n    async def handle_streamable_http(scope: Scope, receive: Receive, send: Send) -> None:\n        await session_manager.handle_request(scope, receive, send)\n\n    # Create Starlette app with lifespan\n    @asynccontextmanager\n    async def lifespan(app: Starlette) -> AsyncGenerator[None, None]:\n        async with session_manager.run():\n            yield\n\n    routes = [\n        Mount(\"/\", app=handle_streamable_http),\n    ]\n\n    starlette_app = Starlette(routes=routes, lifespan=lifespan)\n    uvicorn.run(starlette_app, host=\"127.0.0.1\", port=port, log_level=\"error\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "port": {
            "type": "integer",
            "required": true
          },
          "security_settings": {
            "type": "string",
            "required": false
          }
        },
        "required": [
          "port"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "port": "integer",
          "security_settings": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `run_server_with_settings` in tests\\server\\test_streamable_http_security.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        }
      ],
      "confidence": 0.3,
      "evidence": [
        "function run_server_with_settings in tests\\server\\test_streamable_http_security.py",
        "matched template: stream data over websocket (sim=0.38)"
      ]
    },
    {
      "name": "start_server_process",
      "description": "stream data over websocket. Function `start_server_process`.",
      "predicted_filename": "tests\\server\\test_streamable_http_security.py",
      "predicted_code_snippet": "def start_server_process(port: int, security_settings: TransportSecuritySettings | None = None):\n    \"\"\"Start server in a separate process.\"\"\"\n    process = multiprocessing.Process(target=run_server_with_settings, args=(port, security_settings))\n    process.start()\n    # Wait for server to be ready to accept connections\n    wait_for_server(port)\n    return process",
      "input_schema": {
        "type": "object",
        "properties": {
          "port": {
            "type": "integer",
            "required": true
          },
          "security_settings": {
            "type": "string",
            "required": false
          }
        },
        "required": [
          "port"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "port": "integer",
          "security_settings": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `start_server_process` in tests\\server\\test_streamable_http_security.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        }
      ],
      "confidence": 0.28,
      "evidence": [
        "function start_server_process in tests\\server\\test_streamable_http_security.py",
        "matched template: stream data over websocket (sim=0.35)"
      ]
    },
    {
      "name": "oauth_provider",
      "description": "authenticate a user and return a token. Function `oauth_provider`.",
      "predicted_filename": "tests\\server\\auth\\test_error_handling.py",
      "predicted_code_snippet": "def oauth_provider():\n    \"\"\"Return a MockOAuthProvider instance that can be configured to raise errors.\"\"\"\n    return MockOAuthProvider()",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `oauth_provider` in tests\\server\\auth\\test_error_handling.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.24,
      "evidence": [
        "function oauth_provider in tests\\server\\auth\\test_error_handling.py",
        "matched template: authenticate a user and return a token (sim=0.28)"
      ]
    },
    {
      "name": "app",
      "description": "authenticate a user and return a token. Function `app`.",
      "predicted_filename": "tests\\server\\auth\\test_error_handling.py",
      "predicted_code_snippet": "def app(oauth_provider: MockOAuthProvider):\n    from mcp.server.auth.settings import ClientRegistrationOptions, RevocationOptions\n\n    # Enable client registration\n    client_registration_options = ClientRegistrationOptions(enabled=True)\n    revocation_options = RevocationOptions(enabled=True)\n\n    # Create auth routes\n    auth_routes = create_auth_routes(\n        oauth_provider,\n        issuer_url=AnyHttpUrl(\"http://localhost\"),\n        client_registration_options=client_registration_options,\n        revocation_options=revocation_options,\n    )\n\n    # Create Starlette app with routes directly\n    return Starlette(routes=auth_routes)",
      "input_schema": {
        "type": "object",
        "properties": {
          "oauth_provider": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "oauth_provider"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "oauth_provider": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `app` in tests\\server\\auth\\test_error_handling.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.27,
      "evidence": [
        "function app in tests\\server\\auth\\test_error_handling.py",
        "matched template: authenticate a user and return a token (sim=0.34)"
      ]
    },
    {
      "name": "client",
      "description": "handle a HTTP route request and return response. Function `client`.",
      "predicted_filename": "tests\\server\\auth\\test_error_handling.py",
      "predicted_code_snippet": "def client(app: Starlette):\n    transport = ASGITransport(app=app)\n    # Use base_url without a path since routes are directly on the app\n    return httpx.AsyncClient(transport=transport, base_url=\"http://localhost\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `client` in tests\\server\\auth\\test_error_handling.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.23,
      "evidence": [
        "function client in tests\\server\\auth\\test_error_handling.py",
        "matched template: handle a HTTP route request and return response (sim=0.26)"
      ]
    },
    {
      "name": "pkce_challenge",
      "description": "compute cryptographic hash of input data. Function `pkce_challenge`.",
      "predicted_filename": "tests\\server\\auth\\test_error_handling.py",
      "predicted_code_snippet": "def pkce_challenge():\n    \"\"\"Create a PKCE challenge with code_verifier and code_challenge.\"\"\"\n    import base64\n    import hashlib\n    import secrets\n\n    # Generate a code verifier\n    code_verifier = secrets.token_urlsafe(64)[:128]\n\n    # Create code challenge using S256 method\n    code_verifier_bytes = code_verifier.encode(\"ascii\")\n    sha256 = hashlib.sha256(code_verifier_bytes).digest()\n    code_challenge = base64.urlsafe_b64encode(sha256).decode().rstrip(\"=\")\n\n    return {\"code_verifier\": code_verifier, \"code_challenge\": code_challenge}",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "code_verifier": {
            "type": "string"
          },
          "code_challenge": {
            "type": "string"
          }
        },
        "required": [
          "code_verifier",
          "code_challenge"
        ]
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object",
          "properties": {
            "code_verifier": {
              "type": "string"
            },
            "code_challenge": {
              "type": "string"
            }
          },
          "required": [
            "code_verifier",
            "code_challenge"
          ]
        }
      },
      "explanation": "Detected Python function `pkce_challenge` in tests\\server\\auth\\test_error_handling.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.26,
      "evidence": [
        "function pkce_challenge in tests\\server\\auth\\test_error_handling.py",
        "matched template: compute cryptographic hash of input data (sim=0.32)"
      ]
    },
    {
      "name": "test_app",
      "description": "make an HTTP request to an external API. Function `test_app`.",
      "predicted_filename": "tests\\server\\auth\\test_protected_resource.py",
      "predicted_code_snippet": "def test_app():\n    \"\"\"Fixture to create protected resource routes for testing.\"\"\"\n\n    # Create the protected resource routes\n    protected_resource_routes = create_protected_resource_routes(\n        resource_url=AnyHttpUrl(\"https://example.com/resource\"),\n        authorization_servers=[AnyHttpUrl(\"https://auth.example.com/authorization\")],\n        scopes_supported=[\"read\", \"write\"],\n        resource_name=\"Example Resource\",\n        resource_documentation=AnyHttpUrl(\"https://docs.example.com/resource\"),\n    )\n\n    app = Starlette(routes=protected_resource_routes)\n    return app",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_app` in tests\\server\\auth\\test_protected_resource.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.22,
      "evidence": [
        "function test_app in tests\\server\\auth\\test_protected_resource.py",
        "matched template: make an HTTP request to an external API (sim=0.24)"
      ]
    },
    {
      "name": "root_resource_app",
      "description": "make an HTTP request to an external API. Function `root_resource_app`.",
      "predicted_filename": "tests\\server\\auth\\test_protected_resource.py",
      "predicted_code_snippet": "def root_resource_app():\n    \"\"\"Fixture to create protected resource routes for root-level resource.\"\"\"\n\n    # Create routes for a resource without path component\n    protected_resource_routes = create_protected_resource_routes(\n        resource_url=AnyHttpUrl(\"https://example.com\"),\n        authorization_servers=[AnyHttpUrl(\"https://auth.example.com\")],\n        scopes_supported=[\"read\"],\n        resource_name=\"Root Resource\",\n    )\n\n    app = Starlette(routes=protected_resource_routes)\n    return app",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `root_resource_app` in tests\\server\\auth\\test_protected_resource.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.19,
      "evidence": [
        "function root_resource_app in tests\\server\\auth\\test_protected_resource.py",
        "matched template: make an HTTP request to an external API (sim=0.20)"
      ]
    },
    {
      "name": "valid_access_token",
      "description": "authenticate a user and return a token. Function `valid_access_token`.",
      "predicted_filename": "tests\\server\\auth\\middleware\\test_auth_context.py",
      "predicted_code_snippet": "def valid_access_token() -> AccessToken:\n    \"\"\"Create a valid access token.\"\"\"\n    return AccessToken(\n        token=\"valid_token\",\n        client_id=\"test_client\",\n        scopes=[\"read\", \"write\"],\n        expires_at=int(time.time()) + 3600,  # 1 hour from now\n    )",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `valid_access_token` in tests\\server\\auth\\middleware\\test_auth_context.py",
      "possible_syscalls": [],
      "confidence": 0.35,
      "evidence": [
        "function valid_access_token in tests\\server\\auth\\middleware\\test_auth_context.py",
        "matched template: authenticate a user and return a token (sim=0.45)"
      ]
    },
    {
      "name": "add_token_to_provider",
      "description": "authenticate a user and return a token. Function `add_token_to_provider`.",
      "predicted_filename": "tests\\server\\auth\\middleware\\test_bearer_auth.py",
      "predicted_code_snippet": "def add_token_to_provider(\n    provider: OAuthAuthorizationServerProvider[Any, Any, Any],\n    token: str,\n    access_token: AccessToken,\n) -> None:\n    \"\"\"Helper function to add a token to a provider.\n\n    This is used to work around type checking issues with our mock provider.\n    \"\"\"\n    # We know this is actually a MockOAuthProvider\n    mock_provider = cast(MockOAuthProvider, provider)\n    mock_provider.add_token(token, access_token)",
      "input_schema": {
        "type": "object",
        "properties": {
          "provider": {
            "type": "string",
            "required": true
          },
          "token": {
            "type": "string",
            "required": true
          },
          "access_token": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "provider",
          "token",
          "access_token"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "provider": "string",
          "token": "string",
          "access_token": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `add_token_to_provider` in tests\\server\\auth\\middleware\\test_bearer_auth.py",
      "possible_syscalls": [],
      "confidence": 0.28,
      "evidence": [
        "function add_token_to_provider in tests\\server\\auth\\middleware\\test_bearer_auth.py",
        "matched template: authenticate a user and return a token (sim=0.36)"
      ]
    },
    {
      "name": "mock_oauth_provider",
      "description": "authenticate a user and return a token. Function `mock_oauth_provider`.",
      "predicted_filename": "tests\\server\\auth\\middleware\\test_bearer_auth.py",
      "predicted_code_snippet": "def mock_oauth_provider() -> OAuthAuthorizationServerProvider[Any, Any, Any]:\n    \"\"\"Create a mock OAuth provider.\"\"\"\n    # Use type casting to satisfy the type checker\n    return cast(OAuthAuthorizationServerProvider[Any, Any, Any], MockOAuthProvider())",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `mock_oauth_provider` in tests\\server\\auth\\middleware\\test_bearer_auth.py",
      "possible_syscalls": [],
      "confidence": 0.26,
      "evidence": [
        "function mock_oauth_provider in tests\\server\\auth\\middleware\\test_bearer_auth.py",
        "matched template: authenticate a user and return a token (sim=0.33)"
      ]
    },
    {
      "name": "valid_access_token",
      "description": "authenticate a user and return a token. Function `valid_access_token`.",
      "predicted_filename": "tests\\server\\auth\\middleware\\test_bearer_auth.py",
      "predicted_code_snippet": "def valid_access_token() -> AccessToken:\n    \"\"\"Create a valid access token.\"\"\"\n    return AccessToken(\n        token=\"valid_token\",\n        client_id=\"test_client\",\n        scopes=[\"read\", \"write\"],\n        expires_at=int(time.time()) + 3600,  # 1 hour from now\n    )",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `valid_access_token` in tests\\server\\auth\\middleware\\test_bearer_auth.py",
      "possible_syscalls": [],
      "confidence": 0.35,
      "evidence": [
        "function valid_access_token in tests\\server\\auth\\middleware\\test_bearer_auth.py",
        "matched template: authenticate a user and return a token (sim=0.45)"
      ]
    },
    {
      "name": "expired_access_token",
      "description": "authenticate a user and return a token. Function `expired_access_token`.",
      "predicted_filename": "tests\\server\\auth\\middleware\\test_bearer_auth.py",
      "predicted_code_snippet": "def expired_access_token() -> AccessToken:\n    \"\"\"Create an expired access token.\"\"\"\n    return AccessToken(\n        token=\"expired_token\",\n        client_id=\"test_client\",\n        scopes=[\"read\"],\n        expires_at=int(time.time()) - 3600,  # 1 hour ago\n    )",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `expired_access_token` in tests\\server\\auth\\middleware\\test_bearer_auth.py",
      "possible_syscalls": [],
      "confidence": 0.33,
      "evidence": [
        "function expired_access_token in tests\\server\\auth\\middleware\\test_bearer_auth.py",
        "matched template: authenticate a user and return a token (sim=0.43)"
      ]
    },
    {
      "name": "no_expiry_access_token",
      "description": "authenticate a user and return a token. Function `no_expiry_access_token`.",
      "predicted_filename": "tests\\server\\auth\\middleware\\test_bearer_auth.py",
      "predicted_code_snippet": "def no_expiry_access_token() -> AccessToken:\n    \"\"\"Create an access token with no expiry.\"\"\"\n    return AccessToken(\n        token=\"no_expiry_token\",\n        client_id=\"test_client\",\n        scopes=[\"read\", \"write\"],\n        expires_at=None,\n    )",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `no_expiry_access_token` in tests\\server\\auth\\middleware\\test_bearer_auth.py",
      "possible_syscalls": [],
      "confidence": 0.33,
      "evidence": [
        "function no_expiry_access_token in tests\\server\\auth\\middleware\\test_bearer_auth.py",
        "matched template: authenticate a user and return a token (sim=0.43)"
      ]
    },
    {
      "name": "create_ask_user_tool",
      "description": "execute a shell command. Function `create_ask_user_tool`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_elicitation.py",
      "predicted_code_snippet": "def create_ask_user_tool(mcp: FastMCP):\n    \"\"\"Create a standard ask_user tool that handles all elicitation responses.\"\"\"\n\n    @mcp.tool(description=\"A tool that uses elicitation\")\n    async def ask_user(prompt: str, ctx: Context[ServerSession, None]) -> str:\n        result = await ctx.elicit(message=f\"Tool wants to ask: {prompt}\", schema=AnswerSchema)\n\n        if result.action == \"accept\" and result.data:\n            return f\"User answered: {result.data.answer}\"\n        elif result.action == \"decline\":\n            return \"User declined to answer\"\n        else:  # pragma: no cover\n            return \"User cancelled\"\n\n    return ask_user",
      "input_schema": {
        "type": "object",
        "properties": {
          "mcp": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "mcp"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "mcp": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `create_ask_user_tool` in tests\\server\\fastmcp\\test_elicitation.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function create_ask_user_tool in tests\\server\\fastmcp\\test_elicitation.py",
        "matched template: execute a shell command (sim=0.25)"
      ]
    },
    {
      "name": "complex_arguments_fn",
      "description": "parse JSON input and validate fields. Function `complex_arguments_fn`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_func_metadata.py",
      "predicted_code_snippet": "def complex_arguments_fn(\n    an_int: int,\n    must_be_none: None,\n    must_be_none_dumb_annotation: Annotated[None, \"blah\"],\n    list_of_ints: list[int],\n    # list[str] | str is an interesting case because if it comes in as JSON like\n    # \"[\\\"a\\\", \\\"b\\\"]\" then it will be naively parsed as a string.\n    list_str_or_str: list[str] | str,\n    an_int_annotated_with_field: Annotated[int, Field(description=\"An int with a field\")],\n    an_int_annotated_with_field_and_others: Annotated[\n        int,\n        str,  # Should be ignored, really\n        Field(description=\"An int with a field\"),\n        annotated_types.Gt(1),\n    ],\n    an_int_annotated_with_junk: Annotated[\n        int,\n        \"123\",\n        456,\n    ],\n    field_with_default_via_field_annotation_before_nondefault_arg: Annotated[int, Field(1)],\n    unannotated,\n    my_model_a: SomeInputModelA,\n    my_model_a_forward_ref: \"SomeInputModelA\",\n    my_model_b: SomeInputModelB,\n    an_int_annotated_with_field_default: Annotated[\n        int,\n        Field(1, description=\"An int with a field\"),\n    ],\n    unannotated_with_default=5,\n    my_model_a_with_default: SomeInputModelA = SomeInputModelA(),  # noqa: B008\n    an_int_with_default: int = 1,\n    must_be_none_with_default: None = None,\n    an_int_with_equals_field: int = Field(1, ge=0),\n    int_annotated_with_default: Annotated[int, Field(description=\"hey\")] = 5,\n) -> str:\n    _: Any = (\n        an_int,\n        must_be_none,\n        must_be_none_dumb_annotation,\n        list_of_ints,\n        list_str_or_str,\n        an_int_annotated_with_field,\n        an_int_annotated_with_field_and_others,\n        an_int_annotated_with_junk,\n        field_with_default_via_field_annotation_before_nondefault_arg,\n        unannotated,\n        an_int_annotated_with_field_default,\n        unannotated_with_default,\n        my_model_a,\n        my_model_a_forward_ref,\n        my_model_b,\n        my_model_a_with_default,\n        an_int_with_default,\n        must_be_none_with_default,\n        an_int_with_equals_field,\n        int_annotated_with_default,\n    )\n    return \"ok!\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "an_int": {
            "type": "integer",
            "required": true
          },
          "must_be_none": {
            "type": "string",
            "required": true
          },
          "must_be_none_dumb_annotation": {
            "type": "string",
            "required": true
          },
          "list_of_ints": {
            "type": "integer",
            "required": true
          },
          "list_str_or_str": {
            "type": "string",
            "required": true
          },
          "an_int_annotated_with_field": {
            "type": "integer",
            "required": true
          },
          "an_int_annotated_with_field_and_others": {
            "type": "string",
            "required": true
          },
          "an_int_annotated_with_junk": {
            "type": "integer",
            "required": true
          },
          "field_with_default_via_field_annotation_before_nondefault_arg": {
            "type": "integer",
            "required": true
          },
          "unannotated": {
            "type": "string",
            "required": true
          },
          "my_model_a": {
            "type": "string",
            "required": true
          },
          "my_model_a_forward_ref": {
            "type": "string",
            "required": true
          },
          "my_model_b": {
            "type": "string",
            "required": true
          },
          "an_int_annotated_with_field_default": {
            "type": "integer",
            "required": true
          },
          "unannotated_with_default": {
            "type": "string",
            "required": false
          },
          "my_model_a_with_default": {
            "type": "string",
            "required": false
          },
          "an_int_with_default": {
            "type": "integer",
            "required": false
          },
          "must_be_none_with_default": {
            "type": "string",
            "required": false
          },
          "an_int_with_equals_field": {
            "type": "integer",
            "required": false
          },
          "int_annotated_with_default": {
            "type": "integer",
            "required": false
          }
        },
        "required": [
          "an_int",
          "must_be_none",
          "must_be_none_dumb_annotation",
          "list_of_ints",
          "list_str_or_str",
          "an_int_annotated_with_field",
          "an_int_annotated_with_field_and_others",
          "an_int_annotated_with_junk",
          "field_with_default_via_field_annotation_before_nondefault_arg",
          "unannotated",
          "my_model_a",
          "my_model_a_forward_ref",
          "my_model_b",
          "an_int_annotated_with_field_default"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "an_int": "integer",
          "must_be_none": "string",
          "must_be_none_dumb_annotation": "string",
          "list_of_ints": "integer",
          "list_str_or_str": "string",
          "an_int_annotated_with_field": "integer",
          "an_int_annotated_with_field_and_others": "string",
          "an_int_annotated_with_junk": "integer",
          "field_with_default_via_field_annotation_before_nondefault_arg": "integer",
          "unannotated": "string",
          "my_model_a": "string",
          "my_model_a_forward_ref": "string",
          "my_model_b": "string",
          "an_int_annotated_with_field_default": "integer",
          "unannotated_with_default": "string",
          "my_model_a_with_default": "string",
          "an_int_with_default": "integer",
          "must_be_none_with_default": "string",
          "an_int_with_equals_field": "integer",
          "int_annotated_with_default": "integer"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `complex_arguments_fn` in tests\\server\\fastmcp\\test_func_metadata.py",
      "possible_syscalls": [],
      "confidence": 0.24,
      "evidence": [
        "function complex_arguments_fn in tests\\server\\fastmcp\\test_func_metadata.py",
        "matched template: parse JSON input and validate fields (sim=0.29)"
      ]
    },
    {
      "name": "test_str_vs_list_str",
      "description": "parse JSON input and validate fields. Function `test_str_vs_list_str`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_func_metadata.py",
      "predicted_code_snippet": "def test_str_vs_list_str():\n    \"\"\"Test handling of string vs list[str] type annotations.\n\n    This is tricky as '\"hello\"' can be parsed as a JSON string or a Python string.\n    We want to make sure it's kept as a python string.\n    \"\"\"\n\n    def func_with_str_types(str_or_list: str | list[str]):  # pragma: no cover\n        return str_or_list\n\n    meta = func_metadata(func_with_str_types)\n\n    # Test string input for union type\n    result = meta.pre_parse_json({\"str_or_list\": \"hello\"})\n    assert result[\"str_or_list\"] == \"hello\"\n\n    # Test string input that contains valid JSON for union type\n    # We want to see here that the JSON-vali string is NOT parsed as JSON, but rather\n    # kept as a raw string\n    result = meta.pre_parse_json({\"str_or_list\": '\"hello\"'})\n    assert result[\"str_or_list\"] == '\"hello\"'\n\n    # Test list input for union type\n    result = meta.pre_parse_json({\"str_or_list\": '[\"hello\", \"world\"]'})\n    assert result[\"str_or_list\"] == [\"hello\", \"world\"]",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_str_vs_list_str` in tests\\server\\fastmcp\\test_func_metadata.py",
      "possible_syscalls": [],
      "confidence": 0.31,
      "evidence": [
        "function test_str_vs_list_str in tests\\server\\fastmcp\\test_func_metadata.py",
        "matched template: parse JSON input and validate fields (sim=0.41)"
      ]
    },
    {
      "name": "test_skip_names",
      "description": "parse JSON input and validate fields. Function `test_skip_names`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_func_metadata.py",
      "predicted_code_snippet": "def test_skip_names():\n    \"\"\"Test that skipped parameters are not included in the model\"\"\"\n\n    def func_with_many_params(keep_this: int, skip_this: str, also_keep: float, also_skip: bool):  # pragma: no cover\n        return keep_this, skip_this, also_keep, also_skip\n\n    # Skip some parameters\n    meta = func_metadata(func_with_many_params, skip_names=[\"skip_this\", \"also_skip\"])\n\n    # Check model fields\n    assert \"keep_this\" in meta.arg_model.model_fields\n    assert \"also_keep\" in meta.arg_model.model_fields\n    assert \"skip_this\" not in meta.arg_model.model_fields\n    assert \"also_skip\" not in meta.arg_model.model_fields\n\n    # Validate that we can call with only non-skipped parameters\n    model: BaseModel = meta.arg_model.model_validate({\"keep_this\": 1, \"also_keep\": 2.5})  # type: ignore\n    assert model.keep_this == 1  # type: ignore\n    assert model.also_keep == 2.5",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_skip_names` in tests\\server\\fastmcp\\test_func_metadata.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_skip_names in tests\\server\\fastmcp\\test_func_metadata.py",
        "matched template: parse JSON input and validate fields (sim=0.18)"
      ]
    },
    {
      "name": "test_structured_output_dict_str_types",
      "description": "deserialize JSON to object and validate. Function `test_structured_output_dict_str_types`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_func_metadata.py",
      "predicted_code_snippet": "def test_structured_output_dict_str_types():\n    \"\"\"Test that dict[str, T] types are handled without wrapping.\"\"\"\n\n    # Test dict[str, Any]\n    def func_dict_any() -> dict[str, Any]:  # pragma: no cover\n        return {\"a\": 1, \"b\": \"hello\", \"c\": [1, 2, 3]}\n\n    meta = func_metadata(func_dict_any)\n\n    assert meta.output_schema == IsPartialDict(type=\"object\", title=\"func_dict_anyDictOutput\")\n\n    # Test dict[str, str]\n    def func_dict_str() -> dict[str, str]:  # pragma: no cover\n        return {\"name\": \"John\", \"city\": \"NYC\"}\n\n    meta = func_metadata(func_dict_str)\n    assert meta.output_schema == {\n        \"type\": \"object\",\n        \"additionalProperties\": {\"type\": \"string\"},\n        \"title\": \"func_dict_strDictOutput\",\n    }\n\n    # Test dict[str, list[int]]\n    def func_dict_list() -> dict[str, list[int]]:  # pragma: no cover\n        return {\"nums\": [1, 2, 3], \"more\": [4, 5, 6]}\n\n    meta = func_metadata(func_dict_list)\n    assert meta.output_schema == {\n        \"type\": \"object\",\n        \"additionalProperties\": {\"type\": \"array\", \"items\": {\"type\": \"integer\"}},\n        \"title\": \"func_dict_listDictOutput\",\n    }\n\n    # Test dict[int, str] - should be wrapped since key is not str\n    def func_dict_int_key() -> dict[int, str]:  # pragma: no cover\n        return {1: \"a\", 2: \"b\"}\n\n    meta = func_metadata(func_dict_int_key)\n    assert meta.output_schema is not None\n    assert \"result\" in meta.output_schema[\"properties\"]",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "a": {
            "type": "integer"
          },
          "b": {
            "type": "string"
          },
          "c": {
            "type": "string"
          }
        },
        "required": [
          "a",
          "b",
          "c"
        ]
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object",
          "properties": {
            "a": {
              "type": "integer"
            },
            "b": {
              "type": "string"
            },
            "c": {
              "type": "string"
            }
          },
          "required": [
            "a",
            "b",
            "c"
          ]
        }
      },
      "explanation": "Detected Python function `test_structured_output_dict_str_types` in tests\\server\\fastmcp\\test_func_metadata.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_structured_output_dict_str_types in tests\\server\\fastmcp\\test_func_metadata.py",
        "matched template: deserialize JSON to object and validate (sim=0.19)"
      ]
    },
    {
      "name": "test_complex_function_json_schema",
      "description": "parse JSON input and validate fields. Function `test_complex_function_json_schema`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_func_metadata.py",
      "predicted_code_snippet": "def test_complex_function_json_schema():\n    \"\"\"Test JSON schema generation for complex function arguments.\n\n    Note: Different versions of pydantic output slightly different\n    JSON Schema formats for model fields with defaults. The format changed in 2.9.0:\n\n    1. Before 2.9.0:\n       {\n         \"allOf\": [{\"$ref\": \"#/$defs/Model\"}],\n         \"default\": {}\n       }\n\n    2. Since 2.9.0:\n       {\n         \"$ref\": \"#/$defs/Model\",\n         \"default\": {}\n       }\n\n    Both formats are valid and functionally equivalent. This test accepts either format\n    to ensure compatibility across our supported pydantic versions.\n\n    This change in format does not affect runtime behavior since:\n    1. Both schemas validate the same way\n    2. The actual model classes and validation logic are unchanged\n    3. func_metadata uses model_validate/model_dump, not the schema directly\n    \"\"\"\n    meta = func_metadata(complex_arguments_fn)\n    actual_schema = meta.arg_model.model_json_schema()\n\n    # Create a copy of the actual schema to normalize\n    normalized_schema = actual_schema.copy()\n\n    # Normalize the my_model_a_with_default field to handle both pydantic formats\n    if \"allOf\" in actual_schema[\"properties\"][\"my_model_a_with_default\"]:  # pragma: no cover\n        normalized_schema[\"properties\"][\"my_model_a_with_default\"] = {  # pragma: no cover\n            \"$ref\": \"#/$defs/SomeInputModelA\",\n            \"default\": {},\n        }\n\n    assert normalized_schema == {\n        \"$defs\": {\n            \"InnerModel\": {\n                \"properties\": {\"x\": {\"title\": \"X\", \"type\": \"integer\"}},\n                \"required\": [\"x\"],\n                \"title\": \"InnerModel\",\n                \"type\": \"object\",\n            },\n            \"SomeInputModelA\": {\n                \"properties\": {},\n                \"title\": \"SomeInputModelA\",\n                \"type\": \"object\",\n            },\n            \"SomeInputModelB\": {\n                \"properties\": {\n                    \"how_many_shrimp\": {\n                        \"description\": \"How many shrimp in the tank???\",\n                        \"title\": \"How Many Shrimp\",\n                        \"type\": \"integer\",\n                    },\n                    \"ok\": {\"$ref\": \"#/$defs/InnerModel\"},\n                    \"y\": {\"title\": \"Y\", \"type\": \"null\"},\n                },\n                \"required\": [\"how_many_shrimp\", \"ok\", \"y\"],\n                \"title\": \"SomeInputModelB\",\n                \"type\": \"object\",\n            },\n        },\n        \"properties\": {\n            \"an_int\": {\"title\": \"An Int\", \"type\": \"integer\"},\n            \"must_be_none\": {\"title\": \"Must Be None\", \"type\": \"null\"},\n            \"must_be_none_dumb_annotation\": {\n                \"title\": \"Must Be None Dumb Annotation\",\n                \"type\": \"null\",\n            },\n            \"list_of_ints\": {\n                \"items\": {\"type\": \"integer\"},\n                \"title\": \"List Of Ints\",\n                \"type\": \"array\",\n            },\n            \"list_str_or_str\": {\n                \"anyOf\": [\n                    {\"items\": {\"type\": \"string\"}, \"type\": \"array\"},\n                    {\"type\": \"string\"},\n                ],\n                \"title\": \"List Str Or Str\",\n            },\n            \"an_int_annotated_with_field\": {\n                \"description\": \"An int with a field\",\n                \"title\": \"An Int Annotated With Field\",\n                \"type\": \"integer\",\n            },\n            \"an_int_annotated_with_field_and_others\": {\n                \"description\": \"An int with a field\",\n                \"exclusiveMinimum\": 1,\n                \"title\": \"An Int Annotated With Field And Others\",\n                \"type\": \"integer\",\n            },\n            \"an_int_annotated_with_junk\": {\n                \"title\": \"An Int Annotated With Junk\",\n                \"type\": \"integer\",\n            },\n            \"field_with_default_via_field_annotation_before_nondefault_arg\": {\n                \"default\": 1,\n                \"title\": \"Field With Default Via Field Annotation Before Nondefault Arg\",\n                \"type\": \"integer\",\n            },\n            \"unannotated\": {\"title\": \"unannotated\", \"type\": \"string\"},\n            \"my_model_a\": {\"$ref\": \"#/$defs/SomeInputModelA\"},\n            \"my_model_a_forward_ref\": {\"$ref\": \"#/$defs/SomeInputModelA\"},\n            \"my_model_b\": {\"$ref\": \"#/$defs/SomeInputModelB\"},\n            \"an_int_annotated_with_field_default\": {\n                \"default\": 1,\n                \"description\": \"An int with a field\",\n                \"title\": \"An Int Annotated With Field Default\",\n                \"type\": \"integer\",\n            },\n            \"unannotated_with_default\": {\n                \"default\": 5,\n                \"title\": \"unannotated_with_default\",\n                \"type\": \"string\",\n            },\n            \"my_model_a_with_default\": {\n                \"$ref\": \"#/$defs/SomeInputModelA\",\n                \"default\": {},\n            },\n            \"an_int_with_default\": {\n                \"default\": 1,\n                \"title\": \"An Int With Default\",\n                \"type\": \"integer\",\n            },\n            \"must_be_none_with_default\": {\n                \"default\": None,\n                \"title\": \"Must Be None With Default\",\n                \"type\": \"null\",\n            },\n            \"an_int_with_equals_field\": {\n                \"default\": 1,\n                \"minimum\": 0,\n                \"title\": \"An Int With Equals Field\",\n                \"type\": \"integer\",\n            },\n            \"int_annotated_with_default\": {\n                \"default\": 5,\n                \"description\": \"hey\",\n                \"title\": \"Int Annotated With Default\",\n                \"type\": \"integer\",\n            },\n        },\n        \"required\": [\n            \"an_int\",\n            \"must_be_none\",\n            \"must_be_none_dumb_annotation\",\n            \"list_of_ints\",\n            \"list_str_or_str\",\n            \"an_int_annotated_with_field\",\n            \"an_int_annotated_with_field_and_others\",\n            \"an_int_annotated_with_junk\",\n            \"unannotated\",\n            \"my_model_a\",\n            \"my_model_a_forward_ref\",\n            \"my_model_b\",\n        ],\n        \"title\": \"complex_arguments_fnArguments\",\n        \"type\": \"object\",\n    }",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_complex_function_json_schema` in tests\\server\\fastmcp\\test_func_metadata.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function test_complex_function_json_schema in tests\\server\\fastmcp\\test_func_metadata.py",
        "matched template: parse JSON input and validate fields (sim=0.26)"
      ]
    },
    {
      "name": "test_str_vs_int",
      "description": "parse JSON input and validate fields. Function `test_str_vs_int`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_func_metadata.py",
      "predicted_code_snippet": "def test_str_vs_int():\n    \"\"\"\n    Test that string values are kept as strings even when they contain numbers,\n    while numbers are parsed correctly.\n    \"\"\"\n\n    def func_with_str_and_int(a: str, b: int):  # pragma: no cover\n        return a\n\n    meta = func_metadata(func_with_str_and_int)\n    result = meta.pre_parse_json({\"a\": \"123\", \"b\": 123})\n    assert result[\"a\"] == \"123\"\n    assert result[\"b\"] == 123",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_str_vs_int` in tests\\server\\fastmcp\\test_func_metadata.py",
      "possible_syscalls": [],
      "confidence": 0.25,
      "evidence": [
        "function test_str_vs_int in tests\\server\\fastmcp\\test_func_metadata.py",
        "matched template: parse JSON input and validate fields (sim=0.31)"
      ]
    },
    {
      "name": "test_str_annotation_preserves_json_string",
      "description": "parse JSON input and validate fields. Function `test_str_annotation_preserves_json_string`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_func_metadata.py",
      "predicted_code_snippet": "def test_str_annotation_preserves_json_string():\n    \"\"\"\n    Regression test for PR #1113: Ensure that when a parameter is annotated as str,\n    valid JSON strings are NOT parsed into Python objects.\n\n    This test would fail before the fix (JSON string would be parsed to dict)\n    and passes after the fix (JSON string remains as string).\n    \"\"\"\n\n    def process_json_config(config: str, enabled: bool = True) -> str:  # pragma: no cover\n        \"\"\"Function that expects a JSON string as a string parameter.\"\"\"\n        # In real use, this function might validate or transform the JSON string\n        # before parsing it, or pass it to another service as-is\n        return f\"Processing config: {config}\"\n\n    meta = func_metadata(process_json_config)\n\n    # Test case 1: JSON object as string\n    json_obj_str = '{\"database\": \"postgres\", \"port\": 5432}'\n    result = meta.pre_parse_json({\"config\": json_obj_str, \"enabled\": True})\n\n    # The config parameter should remain as a string, NOT be parsed to a dict\n    assert isinstance(result[\"config\"], str)\n    assert result[\"config\"] == json_obj_str\n\n    # Test case 2: JSON array as string\n    json_array_str = '[\"item1\", \"item2\", \"item3\"]'\n    result = meta.pre_parse_json({\"config\": json_array_str})\n\n    # Should remain as string\n    assert isinstance(result[\"config\"], str)\n    assert result[\"config\"] == json_array_str\n\n    # Test case 3: JSON string value (double-encoded)\n    json_string_str = '\"This is a JSON string\"'\n    result = meta.pre_parse_json({\"config\": json_string_str})\n\n    # Should remain as the original string with quotes\n    assert isinstance(result[\"config\"], str)\n    assert result[\"config\"] == json_string_str\n\n    # Test case 4: Complex nested JSON as string\n    complex_json_str = '{\"users\": [{\"id\": 1, \"name\": \"Alice\"}, {\"id\": 2, \"name\": \"Bob\"}], \"count\": 2}'\n    result = meta.pre_parse_json({\"config\": complex_json_str})\n\n    # Should remain as string\n    assert isinstance(result[\"config\"], str)\n    assert result[\"config\"] == complex_json_str",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_str_annotation_preserves_json_string` in tests\\server\\fastmcp\\test_func_metadata.py",
      "possible_syscalls": [],
      "confidence": 0.31,
      "evidence": [
        "function test_str_annotation_preserves_json_string in tests\\server\\fastmcp\\test_func_metadata.py",
        "matched template: parse JSON input and validate fields (sim=0.40)"
      ]
    },
    {
      "name": "test_structured_output_requires_return_annotation",
      "description": "parse JSON input and validate fields. Function `test_structured_output_requires_return_annotation`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_func_metadata.py",
      "predicted_code_snippet": "def test_structured_output_requires_return_annotation():\n    \"\"\"Test that structured_output=True requires a return annotation\"\"\"\n    from mcp.server.fastmcp.exceptions import InvalidSignature\n\n    def func_no_annotation():  # pragma: no cover\n        return \"hello\"\n\n    def func_none_annotation() -> None:  # pragma: no cover\n        return None\n\n    with pytest.raises(InvalidSignature) as exc_info:\n        func_metadata(func_no_annotation, structured_output=True)\n    assert \"return annotation required\" in str(exc_info.value)\n\n    # None annotation should work\n    meta = func_metadata(func_none_annotation)\n    assert meta.output_schema == {\n        \"type\": \"object\",\n        \"properties\": {\"result\": {\"title\": \"Result\", \"type\": \"null\"}},\n        \"required\": [\"result\"],\n        \"title\": \"func_none_annotationOutput\",\n    }",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_structured_output_requires_return_annotation` in tests\\server\\fastmcp\\test_func_metadata.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function test_structured_output_requires_return_annotation in tests\\server\\fastmcp\\test_func_metadata.py",
        "matched template: parse JSON input and validate fields (sim=0.15)"
      ]
    },
    {
      "name": "test_structured_output_basemodel",
      "description": "deserialize JSON to object and validate. Function `test_structured_output_basemodel`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_func_metadata.py",
      "predicted_code_snippet": "def test_structured_output_basemodel():\n    \"\"\"Test structured output with BaseModel return types\"\"\"\n\n    class PersonModel(BaseModel):\n        name: str\n        age: int\n        email: str | None = None\n\n    def func_returning_person() -> PersonModel:  # pragma: no cover\n        return PersonModel(name=\"Alice\", age=30)\n\n    meta = func_metadata(func_returning_person)\n    assert meta.output_schema == {\n        \"type\": \"object\",\n        \"properties\": {\n            \"name\": {\"title\": \"Name\", \"type\": \"string\"},\n            \"age\": {\"title\": \"Age\", \"type\": \"integer\"},\n            \"email\": {\"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}], \"default\": None, \"title\": \"Email\"},\n        },\n        \"required\": [\"name\", \"age\"],\n        \"title\": \"PersonModel\",\n    }",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_structured_output_basemodel` in tests\\server\\fastmcp\\test_func_metadata.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function test_structured_output_basemodel in tests\\server\\fastmcp\\test_func_metadata.py",
        "matched template: deserialize JSON to object and validate (sim=0.28)"
      ]
    },
    {
      "name": "test_structured_output_primitives",
      "description": "compute cryptographic hash of input data. Function `test_structured_output_primitives`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_func_metadata.py",
      "predicted_code_snippet": "def test_structured_output_primitives():\n    \"\"\"Test structured output with primitive return types\"\"\"\n\n    def func_str() -> str:  # pragma: no cover\n        return \"hello\"\n\n    def func_int() -> int:  # pragma: no cover\n        return 42\n\n    def func_float() -> float:  # pragma: no cover\n        return 3.14\n\n    def func_bool() -> bool:  # pragma: no cover\n        return True\n\n    def func_bytes() -> bytes:  # pragma: no cover\n        return b\"data\"\n\n    # Test string\n    meta = func_metadata(func_str)\n    assert meta.output_schema == {\n        \"type\": \"object\",\n        \"properties\": {\"result\": {\"title\": \"Result\", \"type\": \"string\"}},\n        \"required\": [\"result\"],\n        \"title\": \"func_strOutput\",\n    }\n\n    # Test int\n    meta = func_metadata(func_int)\n    assert meta.output_schema == {\n        \"type\": \"object\",\n        \"properties\": {\"result\": {\"title\": \"Result\", \"type\": \"integer\"}},\n        \"required\": [\"result\"],\n        \"title\": \"func_intOutput\",\n    }\n\n    # Test float\n    meta = func_metadata(func_float)\n    assert meta.output_schema == {\n        \"type\": \"object\",\n        \"properties\": {\"result\": {\"title\": \"Result\", \"type\": \"number\"}},\n        \"required\": [\"result\"],\n        \"title\": \"func_floatOutput\",\n    }\n\n    # Test bool\n    meta = func_metadata(func_bool)\n    assert meta.output_schema == {\n        \"type\": \"object\",\n        \"properties\": {\"result\": {\"title\": \"Result\", \"type\": \"boolean\"}},\n        \"required\": [\"result\"],\n        \"title\": \"func_boolOutput\",\n    }\n\n    # Test bytes\n    meta = func_metadata(func_bytes)\n    assert meta.output_schema == {\n        \"type\": \"object\",\n        \"properties\": {\"result\": {\"title\": \"Result\", \"type\": \"string\", \"format\": \"binary\"}},\n        \"required\": [\"result\"],\n        \"title\": \"func_bytesOutput\",\n    }",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_structured_output_primitives` in tests\\server\\fastmcp\\test_func_metadata.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_structured_output_primitives in tests\\server\\fastmcp\\test_func_metadata.py",
        "matched template: compute cryptographic hash of input data (sim=0.20)"
      ]
    },
    {
      "name": "test_structured_output_generic_types",
      "description": "deserialize JSON to object and validate. Function `test_structured_output_generic_types`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_func_metadata.py",
      "predicted_code_snippet": "def test_structured_output_generic_types():\n    \"\"\"Test structured output with generic types (list, dict, Union, etc.)\"\"\"\n\n    def func_list_str() -> list[str]:  # pragma: no cover\n        return [\"a\", \"b\", \"c\"]\n\n    def func_dict_str_int() -> dict[str, int]:  # pragma: no cover\n        return {\"a\": 1, \"b\": 2}\n\n    def func_union() -> str | int:  # pragma: no cover\n        return \"hello\"\n\n    def func_optional() -> str | None:  # pragma: no cover\n        return None\n\n    # Test list\n    meta = func_metadata(func_list_str)\n    assert meta.output_schema == {\n        \"type\": \"object\",\n        \"properties\": {\"result\": {\"title\": \"Result\", \"type\": \"array\", \"items\": {\"type\": \"string\"}}},\n        \"required\": [\"result\"],\n        \"title\": \"func_list_strOutput\",\n    }\n\n    # Test dict[str, int] - should NOT be wrapped\n    meta = func_metadata(func_dict_str_int)\n    assert meta.output_schema == {\n        \"type\": \"object\",\n        \"additionalProperties\": {\"type\": \"integer\"},\n        \"title\": \"func_dict_str_intDictOutput\",\n    }\n\n    # Test Union\n    meta = func_metadata(func_union)\n    assert meta.output_schema == {\n        \"type\": \"object\",\n        \"properties\": {\"result\": {\"title\": \"Result\", \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"integer\"}]}},\n        \"required\": [\"result\"],\n        \"title\": \"func_unionOutput\",\n    }\n\n    # Test Optional\n    meta = func_metadata(func_optional)\n    assert meta.output_schema == {\n        \"type\": \"object\",\n        \"properties\": {\"result\": {\"title\": \"Result\", \"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}]}},\n        \"required\": [\"result\"],\n        \"title\": \"func_optionalOutput\",\n    }",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "a": {
            "type": "integer"
          },
          "b": {
            "type": "integer"
          }
        },
        "required": [
          "a",
          "b"
        ]
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object",
          "properties": {
            "a": {
              "type": "integer"
            },
            "b": {
              "type": "integer"
            }
          },
          "required": [
            "a",
            "b"
          ]
        }
      },
      "explanation": "Detected Python function `test_structured_output_generic_types` in tests\\server\\fastmcp\\test_func_metadata.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function test_structured_output_generic_types in tests\\server\\fastmcp\\test_func_metadata.py",
        "matched template: deserialize JSON to object and validate (sim=0.16)"
      ]
    },
    {
      "name": "test_structured_output_dataclass",
      "description": "deserialize JSON to object and validate. Function `test_structured_output_dataclass`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_func_metadata.py",
      "predicted_code_snippet": "def test_structured_output_dataclass():\n    \"\"\"Test structured output with dataclass return types\"\"\"\n\n    @dataclass\n    class PersonDataClass:\n        name: str\n        age: int\n        email: str | None = None\n        tags: list[str] | None = None\n\n    def func_returning_dataclass() -> PersonDataClass:  # pragma: no cover\n        return PersonDataClass(name=\"Bob\", age=25)\n\n    meta = func_metadata(func_returning_dataclass)\n    assert meta.output_schema == {\n        \"type\": \"object\",\n        \"properties\": {\n            \"name\": {\"title\": \"Name\", \"type\": \"string\"},\n            \"age\": {\"title\": \"Age\", \"type\": \"integer\"},\n            \"email\": {\"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}], \"default\": None, \"title\": \"Email\"},\n            \"tags\": {\n                \"anyOf\": [{\"items\": {\"type\": \"string\"}, \"type\": \"array\"}, {\"type\": \"null\"}],\n                \"default\": None,\n                \"title\": \"Tags\",\n            },\n        },\n        \"required\": [\"name\", \"age\"],\n        \"title\": \"PersonDataClass\",\n    }",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_structured_output_dataclass` in tests\\server\\fastmcp\\test_func_metadata.py",
      "possible_syscalls": [],
      "confidence": 0.26,
      "evidence": [
        "function test_structured_output_dataclass in tests\\server\\fastmcp\\test_func_metadata.py",
        "matched template: deserialize JSON to object and validate (sim=0.32)"
      ]
    },
    {
      "name": "test_structured_output_typeddict",
      "description": "deserialize JSON to object and validate. Function `test_structured_output_typeddict`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_func_metadata.py",
      "predicted_code_snippet": "def test_structured_output_typeddict():\n    \"\"\"Test structured output with TypedDict return types\"\"\"\n\n    class PersonTypedDictOptional(TypedDict, total=False):\n        name: str\n        age: int\n\n    def func_returning_typeddict_optional() -> PersonTypedDictOptional:  # pragma: no cover\n        return {\"name\": \"Dave\"}  # Only returning one field to test partial dict\n\n    meta = func_metadata(func_returning_typeddict_optional)\n    assert meta.output_schema == {\n        \"type\": \"object\",\n        \"properties\": {\n            \"name\": {\"title\": \"Name\", \"type\": \"string\", \"default\": None},\n            \"age\": {\"title\": \"Age\", \"type\": \"integer\", \"default\": None},\n        },\n        \"title\": \"PersonTypedDictOptional\",\n    }\n\n    # Test with total=True (all required)\n    class PersonTypedDictRequired(TypedDict):\n        name: str\n        age: int\n        email: str | None\n\n    def func_returning_typeddict_required() -> PersonTypedDictRequired:  # pragma: no cover\n        return {\"name\": \"Eve\", \"age\": 40, \"email\": None}  # Testing None value\n\n    meta = func_metadata(func_returning_typeddict_required)\n    assert meta.output_schema == {\n        \"type\": \"object\",\n        \"properties\": {\n            \"name\": {\"title\": \"Name\", \"type\": \"string\"},\n            \"age\": {\"title\": \"Age\", \"type\": \"integer\"},\n            \"email\": {\"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}], \"title\": \"Email\"},\n        },\n        \"required\": [\"name\", \"age\", \"email\"],\n        \"title\": \"PersonTypedDictRequired\",\n    }",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          }
        },
        "required": [
          "name"
        ]
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object",
          "properties": {
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name"
          ]
        }
      },
      "explanation": "Detected Python function `test_structured_output_typeddict` in tests\\server\\fastmcp\\test_func_metadata.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function test_structured_output_typeddict in tests\\server\\fastmcp\\test_func_metadata.py",
        "matched template: deserialize JSON to object and validate (sim=0.24)"
      ]
    },
    {
      "name": "test_structured_output_ordinary_class",
      "description": "deserialize JSON to object and validate. Function `test_structured_output_ordinary_class`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_func_metadata.py",
      "predicted_code_snippet": "def test_structured_output_ordinary_class():\n    \"\"\"Test structured output with ordinary annotated classes\"\"\"\n\n    class PersonClass:\n        name: str\n        age: int\n        email: str | None\n\n        def __init__(self, name: str, age: int, email: str | None = None):  # pragma: no cover\n            self.name = name\n            self.age = age\n            self.email = email\n\n    def func_returning_class() -> PersonClass:  # pragma: no cover\n        return PersonClass(\"Helen\", 55)\n\n    meta = func_metadata(func_returning_class)\n    assert meta.output_schema == {\n        \"type\": \"object\",\n        \"properties\": {\n            \"name\": {\"title\": \"Name\", \"type\": \"string\"},\n            \"age\": {\"title\": \"Age\", \"type\": \"integer\"},\n            \"email\": {\"anyOf\": [{\"type\": \"string\"}, {\"type\": \"null\"}], \"title\": \"Email\"},\n        },\n        \"required\": [\"name\", \"age\", \"email\"],\n        \"title\": \"PersonClass\",\n    }",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_structured_output_ordinary_class` in tests\\server\\fastmcp\\test_func_metadata.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function test_structured_output_ordinary_class in tests\\server\\fastmcp\\test_func_metadata.py",
        "matched template: deserialize JSON to object and validate (sim=0.24)"
      ]
    },
    {
      "name": "test_unstructured_output_unannotated_class",
      "description": "compute cryptographic hash of input data. Function `test_unstructured_output_unannotated_class`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_func_metadata.py",
      "predicted_code_snippet": "def test_unstructured_output_unannotated_class():\n    # Test with class that has no annotations\n    class UnannotatedClass:\n        def __init__(self, x, y):  # pragma: no cover\n            self.x = x\n            self.y = y\n\n    def func_returning_unannotated() -> UnannotatedClass:  # pragma: no cover\n        return UnannotatedClass(1, 2)\n\n    meta = func_metadata(func_returning_unannotated)\n    assert meta.output_schema is None",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_unstructured_output_unannotated_class` in tests\\server\\fastmcp\\test_func_metadata.py",
      "possible_syscalls": [],
      "confidence": 0.16,
      "evidence": [
        "function test_unstructured_output_unannotated_class in tests\\server\\fastmcp\\test_func_metadata.py",
        "matched template: compute cryptographic hash of input data (sim=0.09)"
      ]
    },
    {
      "name": "test_tool_call_result_is_unstructured_and_not_converted",
      "description": "validate and sanitize user input. Function `test_tool_call_result_is_unstructured_and_not_converted`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_func_metadata.py",
      "predicted_code_snippet": "def test_tool_call_result_is_unstructured_and_not_converted():\n    def func_returning_call_tool_result() -> CallToolResult:  # pragma: no cover\n        return CallToolResult(content=[])\n\n    meta = func_metadata(func_returning_call_tool_result)\n\n    assert meta.output_schema is None\n    assert isinstance(meta.convert_result(func_returning_call_tool_result()), CallToolResult)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_tool_call_result_is_unstructured_and_not_converted` in tests\\server\\fastmcp\\test_func_metadata.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function test_tool_call_result_is_unstructured_and_not_converted in tests\\server\\fastmcp\\test_func_metadata.py",
        "matched template: validate and sanitize user input (sim=0.11)"
      ]
    },
    {
      "name": "test_tool_call_result_annotated_is_structured_and_converted",
      "description": "deserialize JSON to object and validate. Function `test_tool_call_result_annotated_is_structured_and_converted`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_func_metadata.py",
      "predicted_code_snippet": "def test_tool_call_result_annotated_is_structured_and_converted():\n    class PersonClass(BaseModel):\n        name: str\n\n    def func_returning_annotated_tool_call_result() -> Annotated[CallToolResult, PersonClass]:  # pragma: no cover\n        return CallToolResult(content=[], structuredContent={\"name\": \"Brandon\"})\n\n    meta = func_metadata(func_returning_annotated_tool_call_result)\n\n    assert meta.output_schema == {\n        \"type\": \"object\",\n        \"properties\": {\n            \"name\": {\"title\": \"Name\", \"type\": \"string\"},\n        },\n        \"required\": [\"name\"],\n        \"title\": \"PersonClass\",\n    }\n    assert isinstance(meta.convert_result(func_returning_annotated_tool_call_result()), CallToolResult)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_tool_call_result_annotated_is_structured_and_converted` in tests\\server\\fastmcp\\test_func_metadata.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function test_tool_call_result_annotated_is_structured_and_converted in tests\\server\\fastmcp\\test_func_metadata.py",
        "matched template: deserialize JSON to object and validate (sim=0.22)"
      ]
    },
    {
      "name": "test_tool_call_result_annotated_is_structured_and_invalid",
      "description": "deserialize JSON to object and validate. Function `test_tool_call_result_annotated_is_structured_and_invalid`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_func_metadata.py",
      "predicted_code_snippet": "def test_tool_call_result_annotated_is_structured_and_invalid():\n    class PersonClass(BaseModel):\n        name: str\n\n    def func_returning_annotated_tool_call_result() -> Annotated[CallToolResult, PersonClass]:  # pragma: no cover\n        return CallToolResult(content=[], structuredContent={\"person\": \"Brandon\"})\n\n    meta = func_metadata(func_returning_annotated_tool_call_result)\n\n    with pytest.raises(ValueError):\n        meta.convert_result(func_returning_annotated_tool_call_result())",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_tool_call_result_annotated_is_structured_and_invalid` in tests\\server\\fastmcp\\test_func_metadata.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function test_tool_call_result_annotated_is_structured_and_invalid in tests\\server\\fastmcp\\test_func_metadata.py",
        "matched template: deserialize JSON to object and validate (sim=0.16)"
      ]
    },
    {
      "name": "test_tool_call_result_in_optional_is_rejected",
      "description": "validate and sanitize user input. Function `test_tool_call_result_in_optional_is_rejected`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_func_metadata.py",
      "predicted_code_snippet": "def test_tool_call_result_in_optional_is_rejected():\n    \"\"\"Test that Optional[CallToolResult] raises InvalidSignature\"\"\"\n\n    from mcp.server.fastmcp.exceptions import InvalidSignature\n\n    def func_optional_call_tool_result() -> CallToolResult | None:  # pragma: no cover\n        return CallToolResult(content=[])\n\n    with pytest.raises(InvalidSignature) as exc_info:\n        func_metadata(func_optional_call_tool_result)\n\n    assert \"Union or Optional\" in str(exc_info.value)\n    assert \"CallToolResult\" in str(exc_info.value)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_tool_call_result_in_optional_is_rejected` in tests\\server\\fastmcp\\test_func_metadata.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function test_tool_call_result_in_optional_is_rejected in tests\\server\\fastmcp\\test_func_metadata.py",
        "matched template: validate and sanitize user input (sim=0.15)"
      ]
    },
    {
      "name": "test_tool_call_result_in_union_is_rejected",
      "description": "cache results to disk or memory. Function `test_tool_call_result_in_union_is_rejected`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_func_metadata.py",
      "predicted_code_snippet": "def test_tool_call_result_in_union_is_rejected():\n    \"\"\"Test that Union[str, CallToolResult] raises InvalidSignature\"\"\"\n\n    from mcp.server.fastmcp.exceptions import InvalidSignature\n\n    def func_union_call_tool_result() -> str | CallToolResult:  # pragma: no cover\n        return CallToolResult(content=[])\n\n    with pytest.raises(InvalidSignature) as exc_info:\n        func_metadata(func_union_call_tool_result)\n\n    assert \"Union or Optional\" in str(exc_info.value)\n    assert \"CallToolResult\" in str(exc_info.value)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_tool_call_result_in_union_is_rejected` in tests\\server\\fastmcp\\test_func_metadata.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function test_tool_call_result_in_union_is_rejected in tests\\server\\fastmcp\\test_func_metadata.py",
        "matched template: cache results to disk or memory (sim=0.11)"
      ]
    },
    {
      "name": "test_tool_call_result_in_pipe_union_is_rejected",
      "description": "validate and sanitize user input. Function `test_tool_call_result_in_pipe_union_is_rejected`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_func_metadata.py",
      "predicted_code_snippet": "def test_tool_call_result_in_pipe_union_is_rejected():\n    \"\"\"Test that str | CallToolResult raises InvalidSignature\"\"\"\n    from mcp.server.fastmcp.exceptions import InvalidSignature\n\n    def func_pipe_union_call_tool_result() -> str | CallToolResult:  # pragma: no cover\n        return CallToolResult(content=[])\n\n    with pytest.raises(InvalidSignature) as exc_info:\n        func_metadata(func_pipe_union_call_tool_result)\n\n    assert \"Union or Optional\" in str(exc_info.value)\n    assert \"CallToolResult\" in str(exc_info.value)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_tool_call_result_in_pipe_union_is_rejected` in tests\\server\\fastmcp\\test_func_metadata.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function test_tool_call_result_in_pipe_union_is_rejected in tests\\server\\fastmcp\\test_func_metadata.py",
        "matched template: validate and sanitize user input (sim=0.14)"
      ]
    },
    {
      "name": "test_structured_output_with_field_descriptions",
      "description": "parse JSON input and validate fields. Function `test_structured_output_with_field_descriptions`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_func_metadata.py",
      "predicted_code_snippet": "def test_structured_output_with_field_descriptions():\n    \"\"\"Test that Field descriptions are preserved in structured output\"\"\"\n\n    class ModelWithDescriptions(BaseModel):\n        name: Annotated[str, Field(description=\"The person's full name\")]\n        age: Annotated[int, Field(description=\"Age in years\", ge=0, le=150)]\n\n    def func_with_descriptions() -> ModelWithDescriptions:  # pragma: no cover\n        return ModelWithDescriptions(name=\"Ian\", age=60)\n\n    meta = func_metadata(func_with_descriptions)\n    assert meta.output_schema == {\n        \"type\": \"object\",\n        \"properties\": {\n            \"name\": {\"title\": \"Name\", \"type\": \"string\", \"description\": \"The person's full name\"},\n            \"age\": {\"title\": \"Age\", \"type\": \"integer\", \"description\": \"Age in years\", \"minimum\": 0, \"maximum\": 150},\n        },\n        \"required\": [\"name\", \"age\"],\n        \"title\": \"ModelWithDescriptions\",\n    }",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_structured_output_with_field_descriptions` in tests\\server\\fastmcp\\test_func_metadata.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function test_structured_output_with_field_descriptions in tests\\server\\fastmcp\\test_func_metadata.py",
        "matched template: parse JSON input and validate fields (sim=0.20)"
      ]
    },
    {
      "name": "test_structured_output_nested_models",
      "description": "deserialize JSON to object and validate. Function `test_structured_output_nested_models`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_func_metadata.py",
      "predicted_code_snippet": "def test_structured_output_nested_models():\n    \"\"\"Test structured output with nested models\"\"\"\n\n    class Address(BaseModel):\n        street: str\n        city: str\n        zipcode: str\n\n    class PersonWithAddress(BaseModel):\n        name: str\n        address: Address\n\n    def func_nested() -> PersonWithAddress:  # pragma: no cover\n        return PersonWithAddress(name=\"Jack\", address=Address(street=\"123 Main St\", city=\"Anytown\", zipcode=\"12345\"))\n\n    meta = func_metadata(func_nested)\n    assert meta.output_schema == {\n        \"type\": \"object\",\n        \"$defs\": {\n            \"Address\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"street\": {\"title\": \"Street\", \"type\": \"string\"},\n                    \"city\": {\"title\": \"City\", \"type\": \"string\"},\n                    \"zipcode\": {\"title\": \"Zipcode\", \"type\": \"string\"},\n                },\n                \"required\": [\"street\", \"city\", \"zipcode\"],\n                \"title\": \"Address\",\n            }\n        },\n        \"properties\": {\n            \"name\": {\"title\": \"Name\", \"type\": \"string\"},\n            \"address\": {\"$ref\": \"#/$defs/Address\"},\n        },\n        \"required\": [\"name\", \"address\"],\n        \"title\": \"PersonWithAddress\",\n    }",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_structured_output_nested_models` in tests\\server\\fastmcp\\test_func_metadata.py",
      "possible_syscalls": [],
      "confidence": 0.24,
      "evidence": [
        "function test_structured_output_nested_models in tests\\server\\fastmcp\\test_func_metadata.py",
        "matched template: deserialize JSON to object and validate (sim=0.29)"
      ]
    },
    {
      "name": "test_structured_output_unserializable_type_error",
      "description": "deserialize JSON to object and validate. Function `test_structured_output_unserializable_type_error`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_func_metadata.py",
      "predicted_code_snippet": "def test_structured_output_unserializable_type_error():\n    \"\"\"Test error when structured_output=True is used with unserializable types\"\"\"\n    from typing import NamedTuple\n\n    from mcp.server.fastmcp.exceptions import InvalidSignature\n\n    # Test with a class that has non-serializable default values\n    class ConfigWithCallable:\n        name: str\n        # Callable defaults are not JSON serializable and will trigger Pydantic warnings\n        callback: Callable[[Any], Any] = lambda x: x * 2\n\n    def func_returning_config_with_callable() -> ConfigWithCallable:  # pragma: no cover\n        return ConfigWithCallable()\n\n    # Should work without structured_output=True (returns None for output_schema)\n    meta = func_metadata(func_returning_config_with_callable)\n    assert meta.output_schema is None\n\n    # Should raise error with structured_output=True\n    with pytest.raises(InvalidSignature) as exc_info:\n        func_metadata(func_returning_config_with_callable, structured_output=True)\n    assert \"is not serializable for structured output\" in str(exc_info.value)\n    assert \"ConfigWithCallable\" in str(exc_info.value)\n\n    # Also test with NamedTuple for good measure\n    class Point(NamedTuple):\n        x: int\n        y: int\n\n    def func_returning_namedtuple() -> Point:  # pragma: no cover\n        return Point(1, 2)\n\n    # Should work without structured_output=True (returns None for output_schema)\n    meta = func_metadata(func_returning_namedtuple)\n    assert meta.output_schema is None\n\n    # Should raise error with structured_output=True\n    with pytest.raises(InvalidSignature) as exc_info:\n        func_metadata(func_returning_namedtuple, structured_output=True)\n    assert \"is not serializable for structured output\" in str(exc_info.value)\n    assert \"Point\" in str(exc_info.value)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_structured_output_unserializable_type_error` in tests\\server\\fastmcp\\test_func_metadata.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function test_structured_output_unserializable_type_error in tests\\server\\fastmcp\\test_func_metadata.py",
        "matched template: deserialize JSON to object and validate (sim=0.20)"
      ]
    },
    {
      "name": "test_structured_output_aliases",
      "description": "execute a shell command. Function `test_structured_output_aliases`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_func_metadata.py",
      "predicted_code_snippet": "def test_structured_output_aliases():\n    \"\"\"Test that field aliases are consistent between schema and output\"\"\"\n\n    class ModelWithAliases(BaseModel):\n        field_first: str | None = Field(default=None, alias=\"first\", description=\"The first field.\")\n        field_second: str | None = Field(default=None, alias=\"second\", description=\"The second field.\")\n\n    def func_with_aliases() -> ModelWithAliases:  # pragma: no cover\n        # When aliases are defined, we must use the aliased names to set values\n        return ModelWithAliases(**{\"first\": \"hello\", \"second\": \"world\"})\n\n    meta = func_metadata(func_with_aliases)\n\n    # Check that schema uses aliases\n    assert meta.output_schema is not None\n    assert \"first\" in meta.output_schema[\"properties\"]\n    assert \"second\" in meta.output_schema[\"properties\"]\n    assert \"field_first\" not in meta.output_schema[\"properties\"]\n    assert \"field_second\" not in meta.output_schema[\"properties\"]\n\n    # Check that the actual output uses aliases too\n    result = ModelWithAliases(**{\"first\": \"hello\", \"second\": \"world\"})\n    _, structured_content = meta.convert_result(result)\n\n    # The structured content should use aliases to match the schema\n    assert \"first\" in structured_content\n    assert \"second\" in structured_content\n    assert \"field_first\" not in structured_content\n    assert \"field_second\" not in structured_content\n    assert structured_content[\"first\"] == \"hello\"\n    assert structured_content[\"second\"] == \"world\"\n\n    # Also test the case where we have a model with defaults to ensure aliases work in all cases\n    result_with_defaults = ModelWithAliases()  # Uses default None values\n    _, structured_content_defaults = meta.convert_result(result_with_defaults)\n\n    # Even with defaults, should use aliases in output\n    assert \"first\" in structured_content_defaults\n    assert \"second\" in structured_content_defaults\n    assert \"field_first\" not in structured_content_defaults\n    assert \"field_second\" not in structured_content_defaults\n    assert structured_content_defaults[\"first\"] is None\n    assert structured_content_defaults[\"second\"] is None",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_structured_output_aliases` in tests\\server\\fastmcp\\test_func_metadata.py",
      "possible_syscalls": [],
      "confidence": 0.16,
      "evidence": [
        "function test_structured_output_aliases in tests\\server\\fastmcp\\test_func_metadata.py",
        "matched template: execute a shell command (sim=0.11)"
      ]
    },
    {
      "name": "test_basemodel_reserved_names",
      "description": "deserialize JSON to object and validate. Function `test_basemodel_reserved_names`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_func_metadata.py",
      "predicted_code_snippet": "def test_basemodel_reserved_names():\n    \"\"\"Test that functions with parameters named after BaseModel methods work correctly\"\"\"\n\n    def func_with_reserved_names(  # pragma: no cover\n        model_dump: str,\n        model_validate: int,\n        dict: list[str],\n        json: dict[str, Any],\n        validate: bool,\n        copy: float,\n        normal_param: str,\n    ) -> str:\n        return f\"{model_dump}, {model_validate}, {dict}, {json}, {validate}, {copy}, {normal_param}\"\n\n    meta = func_metadata(func_with_reserved_names)\n\n    # Check that the schema has all the original parameter names (using aliases)\n    schema = meta.arg_model.model_json_schema(by_alias=True)\n    assert \"model_dump\" in schema[\"properties\"]\n    assert \"model_validate\" in schema[\"properties\"]\n    assert \"dict\" in schema[\"properties\"]\n    assert \"json\" in schema[\"properties\"]\n    assert \"validate\" in schema[\"properties\"]\n    assert \"copy\" in schema[\"properties\"]\n    assert \"normal_param\" in schema[\"properties\"]",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_basemodel_reserved_names` in tests\\server\\fastmcp\\test_func_metadata.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function test_basemodel_reserved_names in tests\\server\\fastmcp\\test_func_metadata.py",
        "matched template: deserialize JSON to object and validate (sim=0.26)"
      ]
    },
    {
      "name": "test_basemodel_reserved_names_with_json_preparsing",
      "description": "parse JSON input and validate fields. Function `test_basemodel_reserved_names_with_json_preparsing`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_func_metadata.py",
      "predicted_code_snippet": "def test_basemodel_reserved_names_with_json_preparsing():\n    \"\"\"Test that pre_parse_json works correctly with reserved parameter names\"\"\"\n\n    def func_with_reserved_json(  # pragma: no cover\n        json: dict[str, Any],\n        model_dump: list[int],\n        normal: str,\n    ) -> str:\n        return \"ok\"\n\n    meta = func_metadata(func_with_reserved_json)\n\n    # Test pre-parsing with reserved names\n    result = meta.pre_parse_json(\n        {\n            \"json\": '{\"nested\": \"data\"}',  # JSON string that should be parsed\n            \"model_dump\": \"[1, 2, 3]\",  # JSON string that should be parsed\n            \"normal\": \"plain string\",  # Should remain as string\n        }\n    )\n\n    assert result[\"json\"] == {\"nested\": \"data\"}\n    assert result[\"model_dump\"] == [1, 2, 3]\n    assert result[\"normal\"] == \"plain string\"",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_basemodel_reserved_names_with_json_preparsing` in tests\\server\\fastmcp\\test_func_metadata.py",
      "possible_syscalls": [],
      "confidence": 0.33,
      "evidence": [
        "function test_basemodel_reserved_names_with_json_preparsing in tests\\server\\fastmcp\\test_func_metadata.py",
        "matched template: parse JSON input and validate fields (sim=0.42)"
      ]
    },
    {
      "name": "test_disallowed_type_qualifier",
      "description": "validate and sanitize user input. Function `test_disallowed_type_qualifier`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_func_metadata.py",
      "predicted_code_snippet": "def test_disallowed_type_qualifier():\n    from mcp.server.fastmcp.exceptions import InvalidSignature\n\n    def func_disallowed_qualifier() -> Final[int]:  # type: ignore\n        pass  # pragma: no cover\n\n    with pytest.raises(InvalidSignature) as exc_info:\n        func_metadata(func_disallowed_qualifier)\n    assert \"return annotation contains an invalid type qualifier\" in str(exc_info.value)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_disallowed_type_qualifier` in tests\\server\\fastmcp\\test_func_metadata.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_disallowed_type_qualifier in tests\\server\\fastmcp\\test_func_metadata.py",
        "matched template: validate and sanitize user input (sim=0.17)"
      ]
    },
    {
      "name": "test_preserves_pydantic_metadata",
      "description": "validate and sanitize user input. Function `test_preserves_pydantic_metadata`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_func_metadata.py",
      "predicted_code_snippet": "def test_preserves_pydantic_metadata():\n    def func_with_metadata() -> Annotated[int, Field(gt=1)]: ...  # pragma: no branch\n\n    meta = func_metadata(func_with_metadata)\n\n    assert meta.output_schema is not None\n    assert meta.output_schema[\"properties\"][\"result\"] == {\"exclusiveMinimum\": 1, \"title\": \"Result\", \"type\": \"integer\"}",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_preserves_pydantic_metadata` in tests\\server\\fastmcp\\test_func_metadata.py",
      "possible_syscalls": [],
      "confidence": 0.16,
      "evidence": [
        "function test_preserves_pydantic_metadata in tests\\server\\fastmcp\\test_func_metadata.py",
        "matched template: validate and sanitize user input (sim=0.10)"
      ]
    },
    {
      "name": "server_port",
      "description": "stream data over websocket. Function `server_port`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_integration.py",
      "predicted_code_snippet": "def server_port() -> int:\n    \"\"\"Get a free port for testing.\"\"\"\n    with socket.socket() as s:\n        s.bind((\"127.0.0.1\", 0))\n        return s.getsockname()[1]",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "integer"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "integer"
        }
      },
      "explanation": "Detected Python function `server_port` in tests\\server\\fastmcp\\test_integration.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        }
      ],
      "confidence": 0.22,
      "evidence": [
        "function server_port in tests\\server\\fastmcp\\test_integration.py",
        "matched template: stream data over websocket (sim=0.26)"
      ]
    },
    {
      "name": "server_url",
      "description": "stream data over websocket. Function `server_url`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_integration.py",
      "predicted_code_snippet": "def server_url(server_port: int) -> str:\n    \"\"\"Get the server URL for testing.\"\"\"\n    return f\"http://127.0.0.1:{server_port}\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "server_port": {
            "type": "integer",
            "required": true
          }
        },
        "required": [
          "server_port"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "server_port": "integer"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `server_url` in tests\\server\\fastmcp\\test_integration.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        }
      ],
      "confidence": 0.2,
      "evidence": [
        "function server_url in tests\\server\\fastmcp\\test_integration.py",
        "matched template: stream data over websocket (sim=0.21)"
      ]
    },
    {
      "name": "run_server_with_transport",
      "description": "send an email notification. Function `run_server_with_transport`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_integration.py",
      "predicted_code_snippet": "def run_server_with_transport(module_name: str, port: int, transport: str) -> None:  # pragma: no cover\n    \"\"\"Run server with specified transport.\"\"\"\n    # Get the MCP instance based on module name\n    if module_name == \"basic_tool\":\n        mcp = basic_tool.mcp\n    elif module_name == \"basic_resource\":\n        mcp = basic_resource.mcp\n    elif module_name == \"basic_prompt\":\n        mcp = basic_prompt.mcp\n    elif module_name == \"tool_progress\":\n        mcp = tool_progress.mcp\n    elif module_name == \"sampling\":\n        mcp = sampling.mcp\n    elif module_name == \"elicitation\":\n        mcp = elicitation.mcp\n    elif module_name == \"completion\":\n        mcp = completion.mcp\n    elif module_name == \"notifications\":\n        mcp = notifications.mcp\n    elif module_name == \"fastmcp_quickstart\":\n        mcp = fastmcp_quickstart.mcp\n    elif module_name == \"structured_output\":\n        mcp = structured_output.mcp\n    else:\n        raise ImportError(f\"Unknown module: {module_name}\")\n\n    # Create app based on transport type\n    if transport == \"sse\":\n        app = mcp.sse_app()\n    elif transport == \"streamable-http\":\n        app = mcp.streamable_http_app()\n    else:\n        raise ValueError(f\"Invalid transport for test server: {transport}\")\n\n    server = uvicorn.Server(config=uvicorn.Config(app=app, host=\"127.0.0.1\", port=port, log_level=\"error\"))\n    print(f\"Starting {transport} server on port {port}\")\n    server.run()",
      "input_schema": {
        "type": "object",
        "properties": {
          "module_name": {
            "type": "string",
            "required": true
          },
          "port": {
            "type": "integer",
            "required": true
          },
          "transport": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "module_name",
          "port",
          "transport"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "module_name": "string",
          "port": "integer",
          "transport": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `run_server_with_transport` in tests\\server\\fastmcp\\test_integration.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        }
      ],
      "confidence": 0.19,
      "evidence": [
        "function run_server_with_transport in tests\\server\\fastmcp\\test_integration.py",
        "matched template: send an email notification (sim=0.19)"
      ]
    },
    {
      "name": "server_transport",
      "description": "stream data over websocket. Function `server_transport`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_integration.py",
      "predicted_code_snippet": "def server_transport(request: pytest.FixtureRequest, server_port: int) -> Generator[str, None, None]:\n    \"\"\"Start server in a separate process with specified MCP instance and transport.\n\n    Args:\n        request: pytest request with param tuple of (module_name, transport)\n        server_port: Port to run the server on\n\n    Yields:\n        str: The transport type ('sse' or 'streamable_http')\n    \"\"\"\n    module_name, transport = request.param\n\n    proc = multiprocessing.Process(\n        target=run_server_with_transport,\n        args=(module_name, server_port, transport),\n        daemon=True,\n    )\n    proc.start()\n\n    # Wait for server to be ready\n    wait_for_server(server_port)\n\n    yield transport\n\n    proc.kill()\n    proc.join(timeout=2)\n    if proc.is_alive():  # pragma: no cover\n        print(\"Server process failed to terminate\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "request": {
            "type": "string",
            "required": true
          },
          "server_port": {
            "type": "integer",
            "required": true
          }
        },
        "required": [
          "request",
          "server_port"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "request": "string",
          "server_port": "integer"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `server_transport` in tests\\server\\fastmcp\\test_integration.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        }
      ],
      "confidence": 0.21,
      "evidence": [
        "function server_transport in tests\\server\\fastmcp\\test_integration.py",
        "matched template: stream data over websocket (sim=0.23)"
      ]
    },
    {
      "name": "create_client_for_transport",
      "description": "stream data over websocket. Function `create_client_for_transport`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_integration.py",
      "predicted_code_snippet": "def create_client_for_transport(transport: str, server_url: str):\n    \"\"\"Create the appropriate client context manager based on transport type.\"\"\"\n    if transport == \"sse\":\n        endpoint = f\"{server_url}/sse\"\n        return sse_client(endpoint)\n    elif transport == \"streamable-http\":\n        endpoint = f\"{server_url}/mcp\"\n        return streamablehttp_client(endpoint)\n    else:  # pragma: no cover\n        raise ValueError(f\"Invalid transport: {transport}\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "transport": {
            "type": "string",
            "required": true
          },
          "server_url": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "transport",
          "server_url"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "transport": "string",
          "server_url": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `create_client_for_transport` in tests\\server\\fastmcp\\test_integration.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        }
      ],
      "confidence": 0.2,
      "evidence": [
        "function create_client_for_transport in tests\\server\\fastmcp\\test_integration.py",
        "matched template: stream data over websocket (sim=0.22)"
      ]
    },
    {
      "name": "unpack_streams",
      "description": "stream data over websocket. Function `unpack_streams`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_integration.py",
      "predicted_code_snippet": "def unpack_streams(\n    client_streams: tuple[MemoryObjectReceiveStream[SessionMessage | Exception], MemoryObjectSendStream[SessionMessage]]\n    | tuple[\n        MemoryObjectReceiveStream[SessionMessage | Exception],\n        MemoryObjectSendStream[SessionMessage],\n        GetSessionIdCallback,\n    ],\n):\n    \"\"\"Unpack client streams handling different return values from SSE vs StreamableHTTP.\n\n    SSE client returns (read_stream, write_stream)\n    StreamableHTTP client returns (read_stream, write_stream, session_id_callback)\n\n    Args:\n        client_streams: Tuple from client context manager\n\n    Returns:\n        Tuple of (read_stream, write_stream)\n    \"\"\"\n    if len(client_streams) == 2:\n        return client_streams\n    else:\n        read_stream, write_stream, _ = client_streams\n        return read_stream, write_stream",
      "input_schema": {
        "type": "object",
        "properties": {
          "client_streams": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "client_streams"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "client_streams": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `unpack_streams` in tests\\server\\fastmcp\\test_integration.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        }
      ],
      "confidence": 0.29,
      "evidence": [
        "function unpack_streams in tests\\server\\fastmcp\\test_integration.py",
        "matched template: stream data over websocket (sim=0.38)"
      ]
    },
    {
      "name": "tool_fn",
      "description": "cache results to disk or memory. Function `tool_fn`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_server.py",
      "predicted_code_snippet": "def tool_fn(x: int, y: int) -> int:\n    return x + y",
      "input_schema": {
        "type": "object",
        "properties": {
          "x": {
            "type": "integer",
            "required": true
          },
          "y": {
            "type": "integer",
            "required": true
          }
        },
        "required": [
          "x",
          "y"
        ]
      },
      "output_schema": {
        "type": "integer"
      },
      "payload_shape": {
        "request": {
          "x": "integer",
          "y": "integer"
        },
        "response": {
          "type": "integer"
        }
      },
      "explanation": "Detected Python function `tool_fn` in tests\\server\\fastmcp\\test_server.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function tool_fn in tests\\server\\fastmcp\\test_server.py",
        "matched template: cache results to disk or memory (sim=0.16)"
      ]
    },
    {
      "name": "error_tool_fn",
      "description": "cache results to disk or memory. Function `error_tool_fn`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_server.py",
      "predicted_code_snippet": "def error_tool_fn() -> None:\n    raise ValueError(\"Test error\")",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `error_tool_fn` in tests\\server\\fastmcp\\test_server.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function error_tool_fn in tests\\server\\fastmcp\\test_server.py",
        "matched template: cache results to disk or memory (sim=0.14)"
      ]
    },
    {
      "name": "image_tool_fn",
      "description": "process image data (resize, crop, convert). Function `image_tool_fn`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_server.py",
      "predicted_code_snippet": "def image_tool_fn(path: str) -> Image:\n    return Image(path)",
      "input_schema": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "path"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "path": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `image_tool_fn` in tests\\server\\fastmcp\\test_server.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function image_tool_fn in tests\\server\\fastmcp\\test_server.py",
        "matched template: process image data (resize, crop, convert) (sim=0.20)"
      ]
    },
    {
      "name": "audio_tool_fn",
      "description": "read a file from disk and return its contents. Function `audio_tool_fn`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_server.py",
      "predicted_code_snippet": "def audio_tool_fn(path: str) -> Audio:\n    return Audio(path)",
      "input_schema": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "path"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "path": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `audio_tool_fn` in tests\\server\\fastmcp\\test_server.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function audio_tool_fn in tests\\server\\fastmcp\\test_server.py",
        "matched template: read a file from disk and return its contents (sim=0.14)"
      ]
    },
    {
      "name": "mixed_content_tool_fn",
      "description": "read a file from disk and return its contents. Function `mixed_content_tool_fn`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_server.py",
      "predicted_code_snippet": "def mixed_content_tool_fn() -> list[ContentBlock]:\n    return [\n        TextContent(type=\"text\", text=\"Hello\"),\n        ImageContent(type=\"image\", data=\"abc\", mimeType=\"image/png\"),\n        AudioContent(type=\"audio\", data=\"def\", mimeType=\"audio/wav\"),\n    ]",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "array"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "array"
        }
      },
      "explanation": "Detected Python function `mixed_content_tool_fn` in tests\\server\\fastmcp\\test_server.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function mixed_content_tool_fn in tests\\server\\fastmcp\\test_server.py",
        "matched template: read a file from disk and return its contents (sim=0.19)"
      ]
    },
    {
      "name": "test_streamable_http_no_redirect",
      "description": "handle a HTTP route request and return response. Function `test_streamable_http_no_redirect`.",
      "predicted_filename": "tests\\server\\fastmcp\\test_server.py",
      "predicted_code_snippet": "def test_streamable_http_no_redirect() -> None:\n    \"\"\"Test that streamable HTTP routes are correctly configured.\"\"\"\n    mcp = FastMCP()\n    app = mcp.streamable_http_app()\n\n    # Find routes by type - streamable_http_app creates Route objects, not Mount objects\n    streamable_routes = [\n        r\n        for r in app.routes\n        if isinstance(r, Route) and hasattr(r, \"path\") and r.path == mcp.settings.streamable_http_path\n    ]\n\n    # Verify routes exist\n    assert len(streamable_routes) == 1, \"Should have one streamable route\"\n\n    # Verify path values\n    assert streamable_routes[0].path == \"/mcp\", \"Streamable route path should be /mcp\"",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `test_streamable_http_no_redirect` in tests\\server\\fastmcp\\test_server.py",
      "possible_syscalls": [],
      "confidence": 0.25,
      "evidence": [
        "function test_streamable_http_no_redirect in tests\\server\\fastmcp\\test_server.py",
        "matched template: handle a HTTP route request and return response (sim=0.31)"
      ]
    },
    {
      "name": "mock_oauth_provider",
      "description": "authenticate a user and return a token. Function `mock_oauth_provider`.",
      "predicted_filename": "tests\\server\\fastmcp\\auth\\test_auth_integration.py",
      "predicted_code_snippet": "def mock_oauth_provider():\n    return MockOAuthProvider()",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `mock_oauth_provider` in tests\\server\\fastmcp\\auth\\test_auth_integration.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.27,
      "evidence": [
        "function mock_oauth_provider in tests\\server\\fastmcp\\auth\\test_auth_integration.py",
        "matched template: authenticate a user and return a token (sim=0.34)"
      ]
    },
    {
      "name": "auth_app",
      "description": "authenticate a user and return a token. Function `auth_app`.",
      "predicted_filename": "tests\\server\\fastmcp\\auth\\test_auth_integration.py",
      "predicted_code_snippet": "def auth_app(mock_oauth_provider: MockOAuthProvider):\n    # Create auth router\n    auth_routes = create_auth_routes(\n        mock_oauth_provider,\n        AnyHttpUrl(\"https://auth.example.com\"),\n        AnyHttpUrl(\"https://docs.example.com\"),\n        client_registration_options=ClientRegistrationOptions(\n            enabled=True,\n            valid_scopes=[\"read\", \"write\", \"profile\"],\n            default_scopes=[\"read\", \"write\"],\n        ),\n        revocation_options=RevocationOptions(enabled=True),\n    )\n\n    # Create Starlette app\n    app = Starlette(routes=auth_routes)\n\n    return app",
      "input_schema": {
        "type": "object",
        "properties": {
          "mock_oauth_provider": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "mock_oauth_provider"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "mock_oauth_provider": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `auth_app` in tests\\server\\fastmcp\\auth\\test_auth_integration.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.29,
      "evidence": [
        "function auth_app in tests\\server\\fastmcp\\auth\\test_auth_integration.py",
        "matched template: authenticate a user and return a token (sim=0.38)"
      ]
    },
    {
      "name": "pkce_challenge",
      "description": "compute cryptographic hash of input data. Function `pkce_challenge`.",
      "predicted_filename": "tests\\server\\fastmcp\\auth\\test_auth_integration.py",
      "predicted_code_snippet": "def pkce_challenge():\n    \"\"\"Create a PKCE challenge with code_verifier and code_challenge.\"\"\"\n    code_verifier = \"some_random_verifier_string\"\n    code_challenge = base64.urlsafe_b64encode(hashlib.sha256(code_verifier.encode()).digest()).decode().rstrip(\"=\")\n\n    return {\"code_verifier\": code_verifier, \"code_challenge\": code_challenge}",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "code_verifier": {
            "type": "string"
          },
          "code_challenge": {
            "type": "string"
          }
        },
        "required": [
          "code_verifier",
          "code_challenge"
        ]
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object",
          "properties": {
            "code_verifier": {
              "type": "string"
            },
            "code_challenge": {
              "type": "string"
            }
          },
          "required": [
            "code_verifier",
            "code_challenge"
          ]
        }
      },
      "explanation": "Detected Python function `pkce_challenge` in tests\\server\\fastmcp\\auth\\test_auth_integration.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.2,
      "evidence": [
        "function pkce_challenge in tests\\server\\fastmcp\\auth\\test_auth_integration.py",
        "matched template: compute cryptographic hash of input data (sim=0.22)"
      ]
    },
    {
      "name": "temp_file",
      "description": "write data to a file. Function `temp_file`.",
      "predicted_filename": "tests\\server\\fastmcp\\resources\\test_file_resources.py",
      "predicted_code_snippet": "def temp_file():\n    \"\"\"Create a temporary file for testing.\n\n    File is automatically cleaned up after the test if it still exists.\n    \"\"\"\n    content = \"test content\"\n    with NamedTemporaryFile(mode=\"w\", delete=False) as f:\n        f.write(content)\n        path = Path(f.name).resolve()\n    yield path\n    try:  # pragma: no cover\n        path.unlink()\n    except FileNotFoundError:  # pragma: no cover\n        pass",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `temp_file` in tests\\server\\fastmcp\\resources\\test_file_resources.py",
      "possible_syscalls": [],
      "confidence": 0.27,
      "evidence": [
        "function temp_file in tests\\server\\fastmcp\\resources\\test_file_resources.py",
        "matched template: write data to a file (sim=0.34)"
      ]
    },
    {
      "name": "temp_file",
      "description": "write data to a file. Function `temp_file`.",
      "predicted_filename": "tests\\server\\fastmcp\\resources\\test_resource_manager.py",
      "predicted_code_snippet": "def temp_file():\n    \"\"\"Create a temporary file for testing.\n\n    File is automatically cleaned up after the test if it still exists.\n    \"\"\"\n    content = \"test content\"\n    with NamedTemporaryFile(mode=\"w\", delete=False) as f:\n        f.write(content)\n        path = Path(f.name).resolve()\n    yield path\n    try:  # pragma: no cover\n        path.unlink()\n    except FileNotFoundError:  # pragma: no cover\n        pass",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `temp_file` in tests\\server\\fastmcp\\resources\\test_resource_manager.py",
      "possible_syscalls": [],
      "confidence": 0.26,
      "evidence": [
        "function temp_file in tests\\server\\fastmcp\\resources\\test_resource_manager.py",
        "matched template: write data to a file (sim=0.33)"
      ]
    },
    {
      "name": "test_dir",
      "description": "write data to a file. Function `test_dir`.",
      "predicted_filename": "tests\\server\\fastmcp\\servers\\test_file_server.py",
      "predicted_code_snippet": "def test_dir(tmp_path_factory: pytest.TempPathFactory) -> Path:\n    \"\"\"Create a temporary directory with test files.\"\"\"\n    tmp = tmp_path_factory.mktemp(\"test_files\")\n\n    # Create test files\n    (tmp / \"example.py\").write_text(\"print('hello world')\")\n    (tmp / \"readme.md\").write_text(\"# Test Directory\\nThis is a test.\")\n    (tmp / \"config.json\").write_text('{\"test\": true}')\n\n    return tmp",
      "input_schema": {
        "type": "object",
        "properties": {
          "tmp_path_factory": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "tmp_path_factory"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "tmp_path_factory": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `test_dir` in tests\\server\\fastmcp\\servers\\test_file_server.py",
      "possible_syscalls": [],
      "confidence": 0.26,
      "evidence": [
        "function test_dir in tests\\server\\fastmcp\\servers\\test_file_server.py",
        "matched template: write data to a file (sim=0.32)"
      ]
    },
    {
      "name": "mcp",
      "description": "write data to a file. Function `mcp`.",
      "predicted_filename": "tests\\server\\fastmcp\\servers\\test_file_server.py",
      "predicted_code_snippet": "def mcp() -> FastMCP:\n    mcp = FastMCP()\n\n    return mcp",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `mcp` in tests\\server\\fastmcp\\servers\\test_file_server.py",
      "possible_syscalls": [],
      "confidence": 0.26,
      "evidence": [
        "function mcp in tests\\server\\fastmcp\\servers\\test_file_server.py",
        "matched template: write data to a file (sim=0.32)"
      ]
    },
    {
      "name": "resources",
      "description": "list files in a directory. Function `resources`.",
      "predicted_filename": "tests\\server\\fastmcp\\servers\\test_file_server.py",
      "predicted_code_snippet": "def resources(mcp: FastMCP, test_dir: Path) -> FastMCP:\n    @mcp.resource(\"dir://test_dir\")\n    def list_test_dir() -> list[str]:\n        \"\"\"List the files in the test directory\"\"\"\n        return [str(f) for f in test_dir.iterdir()]\n\n    @mcp.resource(\"file://test_dir/example.py\")\n    def read_example_py() -> str:\n        \"\"\"Read the example.py file\"\"\"\n        try:\n            return (test_dir / \"example.py\").read_text()\n        except FileNotFoundError:\n            return \"File not found\"\n\n    @mcp.resource(\"file://test_dir/readme.md\")\n    def read_readme_md() -> str:\n        \"\"\"Read the readme.md file\"\"\"\n        try:  # pragma: no cover\n            return (test_dir / \"readme.md\").read_text()\n        except FileNotFoundError:  # pragma: no cover\n            return \"File not found\"\n\n    @mcp.resource(\"file://test_dir/config.json\")\n    def read_config_json() -> str:\n        \"\"\"Read the config.json file\"\"\"\n        try:  # pragma: no cover\n            return (test_dir / \"config.json\").read_text()\n        except FileNotFoundError:  # pragma: no cover\n            return \"File not found\"\n\n    return mcp",
      "input_schema": {
        "type": "object",
        "properties": {
          "mcp": {
            "type": "string",
            "required": true
          },
          "test_dir": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "mcp",
          "test_dir"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "mcp": "string",
          "test_dir": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `resources` in tests\\server\\fastmcp\\servers\\test_file_server.py",
      "possible_syscalls": [],
      "confidence": 0.3,
      "evidence": [
        "function resources in tests\\server\\fastmcp\\servers\\test_file_server.py",
        "matched template: list files in a directory (sim=0.39)"
      ]
    },
    {
      "name": "tools",
      "description": "list files in a directory. Function `tools`.",
      "predicted_filename": "tests\\server\\fastmcp\\servers\\test_file_server.py",
      "predicted_code_snippet": "def tools(mcp: FastMCP, test_dir: Path) -> FastMCP:\n    @mcp.tool()\n    def delete_file(path: str) -> bool:\n        # ensure path is in test_dir\n        if Path(path).resolve().parent != test_dir:  # pragma: no cover\n            raise ValueError(f\"Path must be in test_dir: {path}\")\n        Path(path).unlink()\n        return True\n\n    return mcp",
      "input_schema": {
        "type": "object",
        "properties": {
          "mcp": {
            "type": "string",
            "required": true
          },
          "test_dir": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "mcp",
          "test_dir"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "mcp": "string",
          "test_dir": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `tools` in tests\\server\\fastmcp\\servers\\test_file_server.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function tools in tests\\server\\fastmcp\\servers\\test_file_server.py",
        "matched template: list files in a directory (sim=0.23)"
      ]
    },
    {
      "name": "test_default_settings",
      "description": "handle a HTTP route request and return response. Function `test_default_settings`.",
      "predicted_filename": "tests\\shared\\test_httpx_utils.py",
      "predicted_code_snippet": "def test_default_settings():\n    \"\"\"Test that default settings are applied correctly.\"\"\"\n    client = create_mcp_http_client()\n\n    assert client.follow_redirects is True\n    assert client.timeout.connect == 30.0",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_default_settings` in tests\\shared\\test_httpx_utils.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function test_default_settings in tests\\shared\\test_httpx_utils.py",
        "matched template: handle a HTTP route request and return response (sim=0.23)"
      ]
    },
    {
      "name": "test_custom_parameters",
      "description": "make an HTTP request to an external API. Function `test_custom_parameters`.",
      "predicted_filename": "tests\\shared\\test_httpx_utils.py",
      "predicted_code_snippet": "def test_custom_parameters():\n    \"\"\"Test custom headers and timeout are set correctly.\"\"\"\n    headers = {\"Authorization\": \"Bearer token\"}\n    timeout = httpx.Timeout(60.0)\n\n    client = create_mcp_http_client(headers, timeout)\n\n    assert client.headers[\"Authorization\"] == \"Bearer token\"\n    assert client.timeout.connect == 60.0",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_custom_parameters` in tests\\shared\\test_httpx_utils.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function test_custom_parameters in tests\\shared\\test_httpx_utils.py",
        "matched template: make an HTTP request to an external API (sim=0.26)"
      ]
    },
    {
      "name": "mcp_server",
      "description": "cache results to disk or memory. Function `mcp_server`.",
      "predicted_filename": "tests\\shared\\test_memory.py",
      "predicted_code_snippet": "def mcp_server() -> Server:\n    server = Server(name=\"test_server\")\n\n    @server.list_resources()\n    async def handle_list_resources():  # pragma: no cover\n        return [\n            Resource(\n                uri=AnyUrl(\"memory://test\"),\n                name=\"Test Resource\",\n                description=\"A test resource\",\n            )\n        ]\n\n    return server",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `mcp_server` in tests\\shared\\test_memory.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function mcp_server in tests\\shared\\test_memory.py",
        "matched template: cache results to disk or memory (sim=0.25)"
      ]
    },
    {
      "name": "mcp_server",
      "description": "stream data over websocket. Function `mcp_server`.",
      "predicted_filename": "tests\\shared\\test_session.py",
      "predicted_code_snippet": "def mcp_server() -> Server:\n    return Server(name=\"test server\")",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `mcp_server` in tests\\shared\\test_session.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function mcp_server in tests\\shared\\test_session.py",
        "matched template: stream data over websocket (sim=0.21)"
      ]
    },
    {
      "name": "server_port",
      "description": "stream data over websocket. Function `server_port`.",
      "predicted_filename": "tests\\shared\\test_sse.py",
      "predicted_code_snippet": "def server_port() -> int:\n    with socket.socket() as s:\n        s.bind((\"127.0.0.1\", 0))\n        return s.getsockname()[1]",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "integer"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "integer"
        }
      },
      "explanation": "Detected Python function `server_port` in tests\\shared\\test_sse.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        }
      ],
      "confidence": 0.27,
      "evidence": [
        "function server_port in tests\\shared\\test_sse.py",
        "matched template: stream data over websocket (sim=0.34)"
      ]
    },
    {
      "name": "server_url",
      "description": "stream data over websocket. Function `server_url`.",
      "predicted_filename": "tests\\shared\\test_sse.py",
      "predicted_code_snippet": "def server_url(server_port: int) -> str:\n    return f\"http://127.0.0.1:{server_port}\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "server_port": {
            "type": "integer",
            "required": true
          }
        },
        "required": [
          "server_port"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "server_port": "integer"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `server_url` in tests\\shared\\test_sse.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        }
      ],
      "confidence": 0.24,
      "evidence": [
        "function server_url in tests\\shared\\test_sse.py",
        "matched template: stream data over websocket (sim=0.29)"
      ]
    },
    {
      "name": "make_server_app",
      "description": "stream data over websocket. Function `make_server_app`.",
      "predicted_filename": "tests\\shared\\test_sse.py",
      "predicted_code_snippet": "def make_server_app() -> Starlette:  # pragma: no cover\n    \"\"\"Create test Starlette app with SSE transport\"\"\"\n    # Configure security with allowed hosts/origins for testing\n    security_settings = TransportSecuritySettings(\n        allowed_hosts=[\"127.0.0.1:*\", \"localhost:*\"], allowed_origins=[\"http://127.0.0.1:*\", \"http://localhost:*\"]\n    )\n    sse = SseServerTransport(\"/messages/\", security_settings=security_settings)\n    server = ServerTest()\n\n    async def handle_sse(request: Request) -> Response:\n        async with sse.connect_sse(request.scope, request.receive, request._send) as streams:\n            await server.run(streams[0], streams[1], server.create_initialization_options())\n        return Response()\n\n    app = Starlette(\n        routes=[\n            Route(\"/sse\", endpoint=handle_sse),\n            Mount(\"/messages/\", app=sse.handle_post_message),\n        ]\n    )\n\n    return app",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `make_server_app` in tests\\shared\\test_sse.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        }
      ],
      "confidence": 0.23,
      "evidence": [
        "function make_server_app in tests\\shared\\test_sse.py",
        "matched template: stream data over websocket (sim=0.27)"
      ]
    },
    {
      "name": "run_server",
      "description": "stream data over websocket. Function `run_server`.",
      "predicted_filename": "tests\\shared\\test_sse.py",
      "predicted_code_snippet": "def run_server(server_port: int) -> None:  # pragma: no cover\n    app = make_server_app()\n    server = uvicorn.Server(config=uvicorn.Config(app=app, host=\"127.0.0.1\", port=server_port, log_level=\"error\"))\n    print(f\"starting server on {server_port}\")\n    server.run()\n\n    # Give server time to start\n    while not server.started:\n        print(\"waiting for server to start\")\n        time.sleep(0.5)",
      "input_schema": {
        "type": "object",
        "properties": {
          "server_port": {
            "type": "integer",
            "required": true
          }
        },
        "required": [
          "server_port"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "server_port": "integer"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `run_server` in tests\\shared\\test_sse.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        }
      ],
      "confidence": 0.23,
      "evidence": [
        "function run_server in tests\\shared\\test_sse.py",
        "matched template: stream data over websocket (sim=0.28)"
      ]
    },
    {
      "name": "server",
      "description": "stream data over websocket. Function `server`.",
      "predicted_filename": "tests\\shared\\test_sse.py",
      "predicted_code_snippet": "def server(server_port: int) -> Generator[None, None, None]:\n    proc = multiprocessing.Process(target=run_server, kwargs={\"server_port\": server_port}, daemon=True)\n    print(\"starting process\")\n    proc.start()\n\n    # Wait for server to be running\n    print(\"waiting for server to start\")\n    wait_for_server(server_port)\n\n    yield\n\n    print(\"killing server\")\n    # Signal the server to stop\n    proc.kill()\n    proc.join(timeout=2)\n    if proc.is_alive():  # pragma: no cover\n        print(\"server process failed to terminate\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "server_port": {
            "type": "integer",
            "required": true
          }
        },
        "required": [
          "server_port"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "server_port": "integer"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `server` in tests\\shared\\test_sse.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        }
      ],
      "confidence": 0.2,
      "evidence": [
        "function server in tests\\shared\\test_sse.py",
        "matched template: stream data over websocket (sim=0.22)"
      ]
    },
    {
      "name": "run_mounted_server",
      "description": "stream data over websocket. Function `run_mounted_server`.",
      "predicted_filename": "tests\\shared\\test_sse.py",
      "predicted_code_snippet": "def run_mounted_server(server_port: int) -> None:  # pragma: no cover\n    app = make_server_app()\n    main_app = Starlette(routes=[Mount(\"/mounted_app\", app=app)])\n    server = uvicorn.Server(config=uvicorn.Config(app=main_app, host=\"127.0.0.1\", port=server_port, log_level=\"error\"))\n    print(f\"starting server on {server_port}\")\n    server.run()\n\n    # Give server time to start\n    while not server.started:\n        print(\"waiting for server to start\")\n        time.sleep(0.5)",
      "input_schema": {
        "type": "object",
        "properties": {
          "server_port": {
            "type": "integer",
            "required": true
          }
        },
        "required": [
          "server_port"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "server_port": "integer"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `run_mounted_server` in tests\\shared\\test_sse.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        }
      ],
      "confidence": 0.19,
      "evidence": [
        "function run_mounted_server in tests\\shared\\test_sse.py",
        "matched template: stream data over websocket (sim=0.19)"
      ]
    },
    {
      "name": "mounted_server",
      "description": "execute a shell command. Function `mounted_server`.",
      "predicted_filename": "tests\\shared\\test_sse.py",
      "predicted_code_snippet": "def mounted_server(server_port: int) -> Generator[None, None, None]:\n    proc = multiprocessing.Process(target=run_mounted_server, kwargs={\"server_port\": server_port}, daemon=True)\n    print(\"starting process\")\n    proc.start()\n\n    # Wait for server to be running\n    print(\"waiting for server to start\")\n    wait_for_server(server_port)\n\n    yield\n\n    print(\"killing server\")\n    # Signal the server to stop\n    proc.kill()\n    proc.join(timeout=2)\n    if proc.is_alive():  # pragma: no cover\n        print(\"server process failed to terminate\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "server_port": {
            "type": "integer",
            "required": true
          }
        },
        "required": [
          "server_port"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "server_port": "integer"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `mounted_server` in tests\\shared\\test_sse.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        }
      ],
      "confidence": 0.2,
      "evidence": [
        "function mounted_server in tests\\shared\\test_sse.py",
        "matched template: execute a shell command (sim=0.21)"
      ]
    },
    {
      "name": "run_context_server",
      "description": "stream data over websocket. Function `run_context_server`.",
      "predicted_filename": "tests\\shared\\test_sse.py",
      "predicted_code_snippet": "def run_context_server(server_port: int) -> None:  # pragma: no cover\n    \"\"\"Run a server that captures request context\"\"\"\n    # Configure security with allowed hosts/origins for testing\n    security_settings = TransportSecuritySettings(\n        allowed_hosts=[\"127.0.0.1:*\", \"localhost:*\"], allowed_origins=[\"http://127.0.0.1:*\", \"http://localhost:*\"]\n    )\n    sse = SseServerTransport(\"/messages/\", security_settings=security_settings)\n    context_server = RequestContextServer()\n\n    async def handle_sse(request: Request) -> Response:\n        async with sse.connect_sse(request.scope, request.receive, request._send) as streams:\n            await context_server.run(streams[0], streams[1], context_server.create_initialization_options())\n        return Response()\n\n    app = Starlette(\n        routes=[\n            Route(\"/sse\", endpoint=handle_sse),\n            Mount(\"/messages/\", app=sse.handle_post_message),\n        ]\n    )\n\n    server = uvicorn.Server(config=uvicorn.Config(app=app, host=\"127.0.0.1\", port=server_port, log_level=\"error\"))\n    print(f\"starting context server on {server_port}\")\n    server.run()",
      "input_schema": {
        "type": "object",
        "properties": {
          "server_port": {
            "type": "integer",
            "required": true
          }
        },
        "required": [
          "server_port"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "server_port": "integer"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `run_context_server` in tests\\shared\\test_sse.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        }
      ],
      "confidence": 0.26,
      "evidence": [
        "function run_context_server in tests\\shared\\test_sse.py",
        "matched template: stream data over websocket (sim=0.32)"
      ]
    },
    {
      "name": "context_server",
      "description": "stream data over websocket. Function `context_server`.",
      "predicted_filename": "tests\\shared\\test_sse.py",
      "predicted_code_snippet": "def context_server(server_port: int) -> Generator[None, None, None]:\n    \"\"\"Fixture that provides a server with request context capture\"\"\"\n    proc = multiprocessing.Process(target=run_context_server, kwargs={\"server_port\": server_port}, daemon=True)\n    print(\"starting context server process\")\n    proc.start()\n\n    # Wait for server to be running\n    print(\"waiting for context server to start\")\n    wait_for_server(server_port)\n\n    yield\n\n    print(\"killing context server\")\n    proc.kill()\n    proc.join(timeout=2)\n    if proc.is_alive():  # pragma: no cover\n        print(\"context server process failed to terminate\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "server_port": {
            "type": "integer",
            "required": true
          }
        },
        "required": [
          "server_port"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "server_port": "integer"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `context_server` in tests\\shared\\test_sse.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        }
      ],
      "confidence": 0.22,
      "evidence": [
        "function context_server in tests\\shared\\test_sse.py",
        "matched template: stream data over websocket (sim=0.24)"
      ]
    },
    {
      "name": "test_sse_message_id_coercion",
      "description": "deserialize JSON to object and validate. Function `test_sse_message_id_coercion`.",
      "predicted_filename": "tests\\shared\\test_sse.py",
      "predicted_code_snippet": "def test_sse_message_id_coercion():\n    \"\"\"Previously, the `RequestId` would coerce a string that looked like an integer into an integer.\n\n    See <https://github.com/modelcontextprotocol/python-sdk/pull/851> for more details.\n\n    As per the JSON-RPC 2.0 specification, the id in the response object needs to be the same type as the id in the\n    request object. In other words, we can't perform the coercion.\n\n    See <https://www.jsonrpc.org/specification#response_object> for more details.\n    \"\"\"\n    json_message = '{\"jsonrpc\": \"2.0\", \"id\": \"123\", \"method\": \"ping\", \"params\": null}'\n    msg = types.JSONRPCMessage.model_validate_json(json_message)\n    assert msg == snapshot(types.JSONRPCMessage(root=types.JSONRPCRequest(method=\"ping\", jsonrpc=\"2.0\", id=\"123\")))\n\n    json_message = '{\"jsonrpc\": \"2.0\", \"id\": 123, \"method\": \"ping\", \"params\": null}'\n    msg = types.JSONRPCMessage.model_validate_json(json_message)\n    assert msg == snapshot(types.JSONRPCMessage(root=types.JSONRPCRequest(method=\"ping\", jsonrpc=\"2.0\", id=123)))",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_sse_message_id_coercion` in tests\\shared\\test_sse.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        }
      ],
      "confidence": 0.27,
      "evidence": [
        "function test_sse_message_id_coercion in tests\\shared\\test_sse.py",
        "matched template: deserialize JSON to object and validate (sim=0.34)"
      ]
    },
    {
      "name": "test_sse_server_transport_endpoint_validation",
      "description": "handle a HTTP route request and return response. Function `test_sse_server_transport_endpoint_validation`.",
      "predicted_filename": "tests\\shared\\test_sse.py",
      "predicted_code_snippet": "def test_sse_server_transport_endpoint_validation(endpoint: str, expected_result: str | type[Exception]):\n    \"\"\"Test that SseServerTransport properly validates and normalizes endpoints.\"\"\"\n    if isinstance(expected_result, type):\n        # Test invalid endpoints that should raise an exception\n        with pytest.raises(expected_result, match=\"is not a relative path.*expecting a relative path\"):\n            SseServerTransport(endpoint)\n    else:\n        # Test valid endpoints that should normalize correctly\n        sse = SseServerTransport(endpoint)\n        assert sse._endpoint == expected_result\n        assert sse._endpoint.startswith(\"/\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "endpoint": {
            "type": "string",
            "required": true
          },
          "expected_result": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "endpoint",
          "expected_result"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "endpoint": "string",
          "expected_result": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_sse_server_transport_endpoint_validation` in tests\\shared\\test_sse.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        }
      ],
      "confidence": 0.19,
      "evidence": [
        "function test_sse_server_transport_endpoint_validation in tests\\shared\\test_sse.py",
        "matched template: handle a HTTP route request and return response (sim=0.19)"
      ]
    },
    {
      "name": "extract_protocol_version_from_sse",
      "description": "stream data over websocket. Function `extract_protocol_version_from_sse`.",
      "predicted_filename": "tests\\shared\\test_streamable_http.py",
      "predicted_code_snippet": "def extract_protocol_version_from_sse(response: requests.Response) -> str:  # pragma: no cover\n    \"\"\"Extract the negotiated protocol version from an SSE initialization response.\"\"\"\n    assert response.headers.get(\"Content-Type\") == \"text/event-stream\"\n    for line in response.text.splitlines():\n        if line.startswith(\"data: \"):\n            init_data = json.loads(line[6:])\n            return init_data[\"result\"][\"protocolVersion\"]\n    raise ValueError(\"Could not extract protocol version from SSE response\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "response": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "response"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "response": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `extract_protocol_version_from_sse` in tests\\shared\\test_streamable_http.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        },
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.26,
      "evidence": [
        "function extract_protocol_version_from_sse in tests\\shared\\test_streamable_http.py",
        "matched template: stream data over websocket (sim=0.32)"
      ]
    },
    {
      "name": "create_app",
      "description": "make an HTTP request to an external API. Function `create_app`.",
      "predicted_filename": "tests\\shared\\test_streamable_http.py",
      "predicted_code_snippet": "def create_app(\n    is_json_response_enabled: bool = False, event_store: EventStore | None = None\n) -> Starlette:  # pragma: no cover\n    \"\"\"Create a Starlette application for testing using the session manager.\n\n    Args:\n        is_json_response_enabled: If True, use JSON responses instead of SSE streams.\n        event_store: Optional event store for testing resumability.\n    \"\"\"\n    # Create server instance\n    server = ServerTest()\n\n    # Create the session manager\n    security_settings = TransportSecuritySettings(\n        allowed_hosts=[\"127.0.0.1:*\", \"localhost:*\"], allowed_origins=[\"http://127.0.0.1:*\", \"http://localhost:*\"]\n    )\n    session_manager = StreamableHTTPSessionManager(\n        app=server,\n        event_store=event_store,\n        json_response=is_json_response_enabled,\n        security_settings=security_settings,\n    )\n\n    # Create an ASGI application that uses the session manager\n    app = Starlette(\n        debug=True,\n        routes=[\n            Mount(\"/mcp\", app=session_manager.handle_request),\n        ],\n        lifespan=lambda app: session_manager.run(),\n    )\n\n    return app",
      "input_schema": {
        "type": "object",
        "properties": {
          "is_json_response_enabled": {
            "type": "boolean",
            "required": false
          },
          "event_store": {
            "type": "string",
            "required": false
          }
        },
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "is_json_response_enabled": "boolean",
          "event_store": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `create_app` in tests\\shared\\test_streamable_http.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        },
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.25,
      "evidence": [
        "function create_app in tests\\shared\\test_streamable_http.py",
        "matched template: make an HTTP request to an external API (sim=0.30)"
      ]
    },
    {
      "name": "run_server",
      "description": "stream data over websocket. Function `run_server`.",
      "predicted_filename": "tests\\shared\\test_streamable_http.py",
      "predicted_code_snippet": "def run_server(\n    port: int, is_json_response_enabled: bool = False, event_store: EventStore | None = None\n) -> None:  # pragma: no cover\n    \"\"\"Run the test server.\n\n    Args:\n        port: Port to listen on.\n        is_json_response_enabled: If True, use JSON responses instead of SSE streams.\n        event_store: Optional event store for testing resumability.\n    \"\"\"\n\n    app = create_app(is_json_response_enabled, event_store)\n    # Configure server\n    config = uvicorn.Config(\n        app=app,\n        host=\"127.0.0.1\",\n        port=port,\n        log_level=\"info\",\n        limit_concurrency=10,\n        timeout_keep_alive=5,\n        access_log=False,\n    )\n\n    # Start the server\n    server = uvicorn.Server(config=config)\n\n    # This is important to catch exceptions and prevent test hangs\n    try:\n        server.run()\n    except Exception:\n        import traceback\n\n        traceback.print_exc()",
      "input_schema": {
        "type": "object",
        "properties": {
          "port": {
            "type": "integer",
            "required": true
          },
          "is_json_response_enabled": {
            "type": "boolean",
            "required": false
          },
          "event_store": {
            "type": "string",
            "required": false
          }
        },
        "required": [
          "port"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "port": "integer",
          "is_json_response_enabled": "boolean",
          "event_store": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `run_server` in tests\\shared\\test_streamable_http.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        },
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.23,
      "evidence": [
        "function run_server in tests\\shared\\test_streamable_http.py",
        "matched template: stream data over websocket (sim=0.28)"
      ]
    },
    {
      "name": "basic_server_port",
      "description": "stream data over websocket. Function `basic_server_port`.",
      "predicted_filename": "tests\\shared\\test_streamable_http.py",
      "predicted_code_snippet": "def basic_server_port() -> int:\n    \"\"\"Find an available port for the basic server.\"\"\"\n    with socket.socket() as s:\n        s.bind((\"127.0.0.1\", 0))\n        return s.getsockname()[1]",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "integer"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "integer"
        }
      },
      "explanation": "Detected Python function `basic_server_port` in tests\\shared\\test_streamable_http.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        },
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.33,
      "evidence": [
        "function basic_server_port in tests\\shared\\test_streamable_http.py",
        "matched template: stream data over websocket (sim=0.43)"
      ]
    },
    {
      "name": "json_server_port",
      "description": "stream data over websocket. Function `json_server_port`.",
      "predicted_filename": "tests\\shared\\test_streamable_http.py",
      "predicted_code_snippet": "def json_server_port() -> int:\n    \"\"\"Find an available port for the JSON response server.\"\"\"\n    with socket.socket() as s:\n        s.bind((\"127.0.0.1\", 0))\n        return s.getsockname()[1]",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "integer"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "integer"
        }
      },
      "explanation": "Detected Python function `json_server_port` in tests\\shared\\test_streamable_http.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        },
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.3,
      "evidence": [
        "function json_server_port in tests\\shared\\test_streamable_http.py",
        "matched template: stream data over websocket (sim=0.39)"
      ]
    },
    {
      "name": "basic_server",
      "description": "stream data over websocket. Function `basic_server`.",
      "predicted_filename": "tests\\shared\\test_streamable_http.py",
      "predicted_code_snippet": "def basic_server(basic_server_port: int) -> Generator[None, None, None]:\n    \"\"\"Start a basic server.\"\"\"\n    proc = multiprocessing.Process(target=run_server, kwargs={\"port\": basic_server_port}, daemon=True)\n    proc.start()\n\n    # Wait for server to be running\n    wait_for_server(basic_server_port)\n\n    yield\n\n    # Clean up\n    proc.kill()\n    proc.join(timeout=2)",
      "input_schema": {
        "type": "object",
        "properties": {
          "basic_server_port": {
            "type": "integer",
            "required": true
          }
        },
        "required": [
          "basic_server_port"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "basic_server_port": "integer"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `basic_server` in tests\\shared\\test_streamable_http.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        },
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.35,
      "evidence": [
        "function basic_server in tests\\shared\\test_streamable_http.py",
        "matched template: stream data over websocket (sim=0.45)"
      ]
    },
    {
      "name": "event_store",
      "description": "stream data over websocket. Function `event_store`.",
      "predicted_filename": "tests\\shared\\test_streamable_http.py",
      "predicted_code_snippet": "def event_store() -> SimpleEventStore:\n    \"\"\"Create a test event store.\"\"\"\n    return SimpleEventStore()",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `event_store` in tests\\shared\\test_streamable_http.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        },
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.32,
      "evidence": [
        "function event_store in tests\\shared\\test_streamable_http.py",
        "matched template: stream data over websocket (sim=0.42)"
      ]
    },
    {
      "name": "event_server_port",
      "description": "stream data over websocket. Function `event_server_port`.",
      "predicted_filename": "tests\\shared\\test_streamable_http.py",
      "predicted_code_snippet": "def event_server_port() -> int:\n    \"\"\"Find an available port for the event store server.\"\"\"\n    with socket.socket() as s:\n        s.bind((\"127.0.0.1\", 0))\n        return s.getsockname()[1]",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "integer"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "integer"
        }
      },
      "explanation": "Detected Python function `event_server_port` in tests\\shared\\test_streamable_http.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        },
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.33,
      "evidence": [
        "function event_server_port in tests\\shared\\test_streamable_http.py",
        "matched template: stream data over websocket (sim=0.43)"
      ]
    },
    {
      "name": "event_server",
      "description": "stream data over websocket. Function `event_server`.",
      "predicted_filename": "tests\\shared\\test_streamable_http.py",
      "predicted_code_snippet": "def event_server(\n    event_server_port: int, event_store: SimpleEventStore\n) -> Generator[tuple[SimpleEventStore, str], None, None]:\n    \"\"\"Start a server with event store enabled.\"\"\"\n    proc = multiprocessing.Process(\n        target=run_server,\n        kwargs={\"port\": event_server_port, \"event_store\": event_store},\n        daemon=True,\n    )\n    proc.start()\n\n    # Wait for server to be running\n    wait_for_server(event_server_port)\n\n    yield event_store, f\"http://127.0.0.1:{event_server_port}\"\n\n    # Clean up\n    proc.kill()\n    proc.join(timeout=2)",
      "input_schema": {
        "type": "object",
        "properties": {
          "event_server_port": {
            "type": "integer",
            "required": true
          },
          "event_store": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "event_server_port",
          "event_store"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "event_server_port": "integer",
          "event_store": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `event_server` in tests\\shared\\test_streamable_http.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        },
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.33,
      "evidence": [
        "function event_server in tests\\shared\\test_streamable_http.py",
        "matched template: stream data over websocket (sim=0.43)"
      ]
    },
    {
      "name": "json_response_server",
      "description": "stream data over websocket. Function `json_response_server`.",
      "predicted_filename": "tests\\shared\\test_streamable_http.py",
      "predicted_code_snippet": "def json_response_server(json_server_port: int) -> Generator[None, None, None]:\n    \"\"\"Start a server with JSON response enabled.\"\"\"\n    proc = multiprocessing.Process(\n        target=run_server,\n        kwargs={\"port\": json_server_port, \"is_json_response_enabled\": True},\n        daemon=True,\n    )\n    proc.start()\n\n    # Wait for server to be running\n    wait_for_server(json_server_port)\n\n    yield\n\n    # Clean up\n    proc.kill()\n    proc.join(timeout=2)",
      "input_schema": {
        "type": "object",
        "properties": {
          "json_server_port": {
            "type": "integer",
            "required": true
          }
        },
        "required": [
          "json_server_port"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "json_server_port": "integer"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `json_response_server` in tests\\shared\\test_streamable_http.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        },
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.31,
      "evidence": [
        "function json_response_server in tests\\shared\\test_streamable_http.py",
        "matched template: stream data over websocket (sim=0.39)"
      ]
    },
    {
      "name": "basic_server_url",
      "description": "stream data over websocket. Function `basic_server_url`.",
      "predicted_filename": "tests\\shared\\test_streamable_http.py",
      "predicted_code_snippet": "def basic_server_url(basic_server_port: int) -> str:\n    \"\"\"Get the URL for the basic test server.\"\"\"\n    return f\"http://127.0.0.1:{basic_server_port}\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "basic_server_port": {
            "type": "integer",
            "required": true
          }
        },
        "required": [
          "basic_server_port"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "basic_server_port": "integer"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `basic_server_url` in tests\\shared\\test_streamable_http.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        },
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.3,
      "evidence": [
        "function basic_server_url in tests\\shared\\test_streamable_http.py",
        "matched template: stream data over websocket (sim=0.39)"
      ]
    },
    {
      "name": "json_server_url",
      "description": "stream data over websocket. Function `json_server_url`.",
      "predicted_filename": "tests\\shared\\test_streamable_http.py",
      "predicted_code_snippet": "def json_server_url(json_server_port: int) -> str:\n    \"\"\"Get the URL for the JSON response test server.\"\"\"\n    return f\"http://127.0.0.1:{json_server_port}\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "json_server_port": {
            "type": "integer",
            "required": true
          }
        },
        "required": [
          "json_server_port"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "json_server_port": "integer"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `json_server_url` in tests\\shared\\test_streamable_http.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        },
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.3,
      "evidence": [
        "function json_server_url in tests\\shared\\test_streamable_http.py",
        "matched template: stream data over websocket (sim=0.38)"
      ]
    },
    {
      "name": "test_accept_header_validation",
      "description": "make an HTTP request to an external API. Function `test_accept_header_validation`.",
      "predicted_filename": "tests\\shared\\test_streamable_http.py",
      "predicted_code_snippet": "def test_accept_header_validation(basic_server: None, basic_server_url: str):\n    \"\"\"Test that Accept header is properly validated.\"\"\"\n    # Test without Accept header\n    response = requests.post(\n        f\"{basic_server_url}/mcp\",\n        headers={\"Content-Type\": \"application/json\"},\n        json={\"jsonrpc\": \"2.0\", \"method\": \"initialize\", \"id\": 1},\n    )\n    assert response.status_code == 406\n    assert \"Not Acceptable\" in response.text",
      "input_schema": {
        "type": "object",
        "properties": {
          "basic_server": {
            "type": "string",
            "required": true
          },
          "basic_server_url": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "basic_server",
          "basic_server_url"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "basic_server": "string",
          "basic_server_url": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_accept_header_validation` in tests\\shared\\test_streamable_http.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        },
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.27,
      "evidence": [
        "function test_accept_header_validation in tests\\shared\\test_streamable_http.py",
        "matched template: make an HTTP request to an external API (sim=0.34)"
      ]
    },
    {
      "name": "test_content_type_validation",
      "description": "parse JSON input and validate fields. Function `test_content_type_validation`.",
      "predicted_filename": "tests\\shared\\test_streamable_http.py",
      "predicted_code_snippet": "def test_content_type_validation(basic_server: None, basic_server_url: str):\n    \"\"\"Test that Content-Type header is properly validated.\"\"\"\n    # Test with incorrect Content-Type\n    response = requests.post(\n        f\"{basic_server_url}/mcp\",\n        headers={\n            \"Accept\": \"application/json, text/event-stream\",\n            \"Content-Type\": \"text/plain\",\n        },\n        data=\"This is not JSON\",\n    )\n\n    assert response.status_code == 400\n    assert \"Invalid Content-Type\" in response.text",
      "input_schema": {
        "type": "object",
        "properties": {
          "basic_server": {
            "type": "string",
            "required": true
          },
          "basic_server_url": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "basic_server",
          "basic_server_url"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "basic_server": "string",
          "basic_server_url": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_content_type_validation` in tests\\shared\\test_streamable_http.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        },
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.24,
      "evidence": [
        "function test_content_type_validation in tests\\shared\\test_streamable_http.py",
        "matched template: parse JSON input and validate fields (sim=0.30)"
      ]
    },
    {
      "name": "test_json_validation",
      "description": "parse JSON input and validate fields. Function `test_json_validation`.",
      "predicted_filename": "tests\\shared\\test_streamable_http.py",
      "predicted_code_snippet": "def test_json_validation(basic_server: None, basic_server_url: str):\n    \"\"\"Test that JSON content is properly validated.\"\"\"\n    # Test with invalid JSON\n    response = requests.post(\n        f\"{basic_server_url}/mcp\",\n        headers={\n            \"Accept\": \"application/json, text/event-stream\",\n            \"Content-Type\": \"application/json\",\n        },\n        data=\"this is not valid json\",\n    )\n    assert response.status_code == 400\n    assert \"Parse error\" in response.text",
      "input_schema": {
        "type": "object",
        "properties": {
          "basic_server": {
            "type": "string",
            "required": true
          },
          "basic_server_url": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "basic_server",
          "basic_server_url"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "basic_server": "string",
          "basic_server_url": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_json_validation` in tests\\shared\\test_streamable_http.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        },
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.32,
      "evidence": [
        "function test_json_validation in tests\\shared\\test_streamable_http.py",
        "matched template: parse JSON input and validate fields (sim=0.41)"
      ]
    },
    {
      "name": "test_json_parsing",
      "description": "parse JSON input and validate fields. Function `test_json_parsing`.",
      "predicted_filename": "tests\\shared\\test_streamable_http.py",
      "predicted_code_snippet": "def test_json_parsing(basic_server: None, basic_server_url: str):\n    \"\"\"Test that JSON content is properly parse.\"\"\"\n    # Test with valid JSON but invalid JSON-RPC\n    response = requests.post(\n        f\"{basic_server_url}/mcp\",\n        headers={\n            \"Accept\": \"application/json, text/event-stream\",\n            \"Content-Type\": \"application/json\",\n        },\n        json={\"foo\": \"bar\"},\n    )\n    assert response.status_code == 400\n    assert \"Validation error\" in response.text",
      "input_schema": {
        "type": "object",
        "properties": {
          "basic_server": {
            "type": "string",
            "required": true
          },
          "basic_server_url": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "basic_server",
          "basic_server_url"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "basic_server": "string",
          "basic_server_url": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_json_parsing` in tests\\shared\\test_streamable_http.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        },
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.32,
      "evidence": [
        "function test_json_parsing in tests\\shared\\test_streamable_http.py",
        "matched template: parse JSON input and validate fields (sim=0.42)"
      ]
    },
    {
      "name": "test_method_not_allowed",
      "description": "make an HTTP request to an external API. Function `test_method_not_allowed`.",
      "predicted_filename": "tests\\shared\\test_streamable_http.py",
      "predicted_code_snippet": "def test_method_not_allowed(basic_server: None, basic_server_url: str):\n    \"\"\"Test that unsupported HTTP methods are rejected.\"\"\"\n    # Test with unsupported method (PUT)\n    response = requests.put(\n        f\"{basic_server_url}/mcp\",\n        headers={\n            \"Accept\": \"application/json, text/event-stream\",\n            \"Content-Type\": \"application/json\",\n        },\n        json={\"jsonrpc\": \"2.0\", \"method\": \"initialize\", \"id\": 1},\n    )\n    assert response.status_code == 405\n    assert \"Method Not Allowed\" in response.text",
      "input_schema": {
        "type": "object",
        "properties": {
          "basic_server": {
            "type": "string",
            "required": true
          },
          "basic_server_url": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "basic_server",
          "basic_server_url"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "basic_server": "string",
          "basic_server_url": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_method_not_allowed` in tests\\shared\\test_streamable_http.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        },
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.29,
      "evidence": [
        "function test_method_not_allowed in tests\\shared\\test_streamable_http.py",
        "matched template: make an HTTP request to an external API (sim=0.37)"
      ]
    },
    {
      "name": "test_session_validation",
      "description": "stream data over websocket. Function `test_session_validation`.",
      "predicted_filename": "tests\\shared\\test_streamable_http.py",
      "predicted_code_snippet": "def test_session_validation(basic_server: None, basic_server_url: str):\n    \"\"\"Test session ID validation.\"\"\"\n    # session_id not used directly in this test\n\n    # Test without session ID\n    response = requests.post(\n        f\"{basic_server_url}/mcp\",\n        headers={\n            \"Accept\": \"application/json, text/event-stream\",\n            \"Content-Type\": \"application/json\",\n        },\n        json={\"jsonrpc\": \"2.0\", \"method\": \"list_tools\", \"id\": 1},\n    )\n    assert response.status_code == 400\n    assert \"Missing session ID\" in response.text",
      "input_schema": {
        "type": "object",
        "properties": {
          "basic_server": {
            "type": "string",
            "required": true
          },
          "basic_server_url": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "basic_server",
          "basic_server_url"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "basic_server": "string",
          "basic_server_url": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_session_validation` in tests\\shared\\test_streamable_http.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        },
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.25,
      "evidence": [
        "function test_session_validation in tests\\shared\\test_streamable_http.py",
        "matched template: stream data over websocket (sim=0.31)"
      ]
    },
    {
      "name": "test_session_id_pattern",
      "description": "validate and sanitize user input. Function `test_session_id_pattern`.",
      "predicted_filename": "tests\\shared\\test_streamable_http.py",
      "predicted_code_snippet": "def test_session_id_pattern():\n    \"\"\"Test that SESSION_ID_PATTERN correctly validates session IDs.\"\"\"\n    # Valid session IDs (visible ASCII characters from 0x21 to 0x7E)\n    valid_session_ids = [\n        \"test-session-id\",\n        \"1234567890\",\n        \"session!@#$%^&*()_+-=[]{}|;:,.<>?/\",\n        \"~`\",\n    ]\n\n    for session_id in valid_session_ids:\n        assert SESSION_ID_PATTERN.match(session_id) is not None\n        # Ensure fullmatch matches too (whole string)\n        assert SESSION_ID_PATTERN.fullmatch(session_id) is not None\n\n    # Invalid session IDs\n    invalid_session_ids = [\n        \"\",  # Empty string\n        \" test\",  # Space (0x20)\n        \"test\\t\",  # Tab\n        \"test\\n\",  # Newline\n        \"test\\r\",  # Carriage return\n        \"test\" + chr(0x7F),  # DEL character\n        \"test\" + chr(0x80),  # Extended ASCII\n        \"test\" + chr(0x00),  # Null character\n        \"test\" + chr(0x20),  # Space (0x20)\n    ]\n\n    for session_id in invalid_session_ids:\n        # For invalid IDs, either match will fail or fullmatch will fail\n        if SESSION_ID_PATTERN.match(session_id) is not None:\n            # If match succeeds, fullmatch should fail (partial match case)\n            assert SESSION_ID_PATTERN.fullmatch(session_id) is None",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_session_id_pattern` in tests\\shared\\test_streamable_http.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        },
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.21,
      "evidence": [
        "function test_session_id_pattern in tests\\shared\\test_streamable_http.py",
        "matched template: validate and sanitize user input (sim=0.24)"
      ]
    },
    {
      "name": "test_streamable_http_transport_init_validation",
      "description": "validate and sanitize user input. Function `test_streamable_http_transport_init_validation`.",
      "predicted_filename": "tests\\shared\\test_streamable_http.py",
      "predicted_code_snippet": "def test_streamable_http_transport_init_validation():\n    \"\"\"Test that StreamableHTTPServerTransport validates session ID on init.\"\"\"\n    # Valid session ID should initialize without errors\n    valid_transport = StreamableHTTPServerTransport(mcp_session_id=\"valid-id\")\n    assert valid_transport.mcp_session_id == \"valid-id\"\n\n    # None should be accepted\n    none_transport = StreamableHTTPServerTransport(mcp_session_id=None)\n    assert none_transport.mcp_session_id is None\n\n    # Invalid session ID should raise ValueError\n    with pytest.raises(ValueError) as excinfo:\n        StreamableHTTPServerTransport(mcp_session_id=\"invalid id with space\")\n    assert \"Session ID must only contain visible ASCII characters\" in str(excinfo.value)\n\n    # Test with control characters\n    with pytest.raises(ValueError):\n        StreamableHTTPServerTransport(mcp_session_id=\"test\\nid\")\n\n    with pytest.raises(ValueError):\n        StreamableHTTPServerTransport(mcp_session_id=\"test\\n\")",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_streamable_http_transport_init_validation` in tests\\shared\\test_streamable_http.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        },
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.2,
      "evidence": [
        "function test_streamable_http_transport_init_validation in tests\\shared\\test_streamable_http.py",
        "matched template: validate and sanitize user input (sim=0.21)"
      ]
    },
    {
      "name": "test_session_termination",
      "description": "handle a HTTP route request and return response. Function `test_session_termination`.",
      "predicted_filename": "tests\\shared\\test_streamable_http.py",
      "predicted_code_snippet": "def test_session_termination(basic_server: None, basic_server_url: str):\n    \"\"\"Test session termination via DELETE and subsequent request handling.\"\"\"\n    response = requests.post(\n        f\"{basic_server_url}/mcp\",\n        headers={\n            \"Accept\": \"application/json, text/event-stream\",\n            \"Content-Type\": \"application/json\",\n        },\n        json=INIT_REQUEST,\n    )\n    assert response.status_code == 200\n\n    # Extract negotiated protocol version from SSE response\n    negotiated_version = extract_protocol_version_from_sse(response)\n\n    # Now terminate the session\n    session_id = response.headers.get(MCP_SESSION_ID_HEADER)\n    response = requests.delete(\n        f\"{basic_server_url}/mcp\",\n        headers={\n            MCP_SESSION_ID_HEADER: session_id,\n            MCP_PROTOCOL_VERSION_HEADER: negotiated_version,\n        },\n    )\n    assert response.status_code == 200\n\n    # Try to use the terminated session\n    response = requests.post(\n        f\"{basic_server_url}/mcp\",\n        headers={\n            \"Accept\": \"application/json, text/event-stream\",\n            \"Content-Type\": \"application/json\",\n            MCP_SESSION_ID_HEADER: session_id,\n        },\n        json={\"jsonrpc\": \"2.0\", \"method\": \"ping\", \"id\": 2},\n    )\n    assert response.status_code == 404\n    assert \"Session has been terminated\" in response.text",
      "input_schema": {
        "type": "object",
        "properties": {
          "basic_server": {
            "type": "string",
            "required": true
          },
          "basic_server_url": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "basic_server",
          "basic_server_url"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "basic_server": "string",
          "basic_server_url": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_session_termination` in tests\\shared\\test_streamable_http.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        },
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.25,
      "evidence": [
        "function test_session_termination in tests\\shared\\test_streamable_http.py",
        "matched template: handle a HTTP route request and return response (sim=0.31)"
      ]
    },
    {
      "name": "test_response",
      "description": "handle a HTTP route request and return response. Function `test_response`.",
      "predicted_filename": "tests\\shared\\test_streamable_http.py",
      "predicted_code_snippet": "def test_response(basic_server: None, basic_server_url: str):\n    \"\"\"Test response handling for a valid request.\"\"\"\n    mcp_url = f\"{basic_server_url}/mcp\"\n    response = requests.post(\n        mcp_url,\n        headers={\n            \"Accept\": \"application/json, text/event-stream\",\n            \"Content-Type\": \"application/json\",\n        },\n        json=INIT_REQUEST,\n    )\n    assert response.status_code == 200\n\n    # Extract negotiated protocol version from SSE response\n    negotiated_version = extract_protocol_version_from_sse(response)\n\n    # Now get the session ID\n    session_id = response.headers.get(MCP_SESSION_ID_HEADER)\n\n    # Try to use the session with proper headers\n    tools_response = requests.post(\n        mcp_url,\n        headers={\n            \"Accept\": \"application/json, text/event-stream\",\n            \"Content-Type\": \"application/json\",\n            MCP_SESSION_ID_HEADER: session_id,  # Use the session ID we got earlier\n            MCP_PROTOCOL_VERSION_HEADER: negotiated_version,\n        },\n        json={\"jsonrpc\": \"2.0\", \"method\": \"tools/list\", \"id\": \"tools-1\"},\n        stream=True,\n    )\n    assert tools_response.status_code == 200\n    assert tools_response.headers.get(\"Content-Type\") == \"text/event-stream\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "basic_server": {
            "type": "string",
            "required": true
          },
          "basic_server_url": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "basic_server",
          "basic_server_url"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "basic_server": "string",
          "basic_server_url": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_response` in tests\\shared\\test_streamable_http.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        },
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.25,
      "evidence": [
        "function test_response in tests\\shared\\test_streamable_http.py",
        "matched template: handle a HTTP route request and return response (sim=0.31)"
      ]
    },
    {
      "name": "test_json_response",
      "description": "stream data over websocket. Function `test_json_response`.",
      "predicted_filename": "tests\\shared\\test_streamable_http.py",
      "predicted_code_snippet": "def test_json_response(json_response_server: None, json_server_url: str):\n    \"\"\"Test response handling when is_json_response_enabled is True.\"\"\"\n    mcp_url = f\"{json_server_url}/mcp\"\n    response = requests.post(\n        mcp_url,\n        headers={\n            \"Accept\": \"application/json, text/event-stream\",\n            \"Content-Type\": \"application/json\",\n        },\n        json=INIT_REQUEST,\n    )\n    assert response.status_code == 200\n    assert response.headers.get(\"Content-Type\") == \"application/json\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "json_response_server": {
            "type": "string",
            "required": true
          },
          "json_server_url": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "json_response_server",
          "json_server_url"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "json_response_server": "string",
          "json_server_url": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_json_response` in tests\\shared\\test_streamable_http.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        },
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.26,
      "evidence": [
        "function test_json_response in tests\\shared\\test_streamable_http.py",
        "matched template: stream data over websocket (sim=0.32)"
      ]
    },
    {
      "name": "test_json_response_accept_json_only",
      "description": "make an HTTP request to an external API. Function `test_json_response_accept_json_only`.",
      "predicted_filename": "tests\\shared\\test_streamable_http.py",
      "predicted_code_snippet": "def test_json_response_accept_json_only(json_response_server: None, json_server_url: str):\n    \"\"\"Test that json_response servers only require application/json in Accept header.\"\"\"\n    mcp_url = f\"{json_server_url}/mcp\"\n    response = requests.post(\n        mcp_url,\n        headers={\n            \"Accept\": \"application/json\",\n            \"Content-Type\": \"application/json\",\n        },\n        json=INIT_REQUEST,\n    )\n    assert response.status_code == 200\n    assert response.headers.get(\"Content-Type\") == \"application/json\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "json_response_server": {
            "type": "string",
            "required": true
          },
          "json_server_url": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "json_response_server",
          "json_server_url"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "json_response_server": "string",
          "json_server_url": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_json_response_accept_json_only` in tests\\shared\\test_streamable_http.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        },
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.27,
      "evidence": [
        "function test_json_response_accept_json_only in tests\\shared\\test_streamable_http.py",
        "matched template: make an HTTP request to an external API (sim=0.34)"
      ]
    },
    {
      "name": "test_json_response_missing_accept_header",
      "description": "make an HTTP request to an external API. Function `test_json_response_missing_accept_header`.",
      "predicted_filename": "tests\\shared\\test_streamable_http.py",
      "predicted_code_snippet": "def test_json_response_missing_accept_header(json_response_server: None, json_server_url: str):\n    \"\"\"Test that json_response servers reject requests without Accept header.\"\"\"\n    mcp_url = f\"{json_server_url}/mcp\"\n    response = requests.post(\n        mcp_url,\n        headers={\n            \"Content-Type\": \"application/json\",\n        },\n        json=INIT_REQUEST,\n    )\n    assert response.status_code == 406\n    assert \"Not Acceptable\" in response.text",
      "input_schema": {
        "type": "object",
        "properties": {
          "json_response_server": {
            "type": "string",
            "required": true
          },
          "json_server_url": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "json_response_server",
          "json_server_url"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "json_response_server": "string",
          "json_server_url": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_json_response_missing_accept_header` in tests\\shared\\test_streamable_http.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        },
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.27,
      "evidence": [
        "function test_json_response_missing_accept_header in tests\\shared\\test_streamable_http.py",
        "matched template: make an HTTP request to an external API (sim=0.34)"
      ]
    },
    {
      "name": "test_json_response_incorrect_accept_header",
      "description": "make an HTTP request to an external API. Function `test_json_response_incorrect_accept_header`.",
      "predicted_filename": "tests\\shared\\test_streamable_http.py",
      "predicted_code_snippet": "def test_json_response_incorrect_accept_header(json_response_server: None, json_server_url: str):\n    \"\"\"Test that json_response servers reject requests with incorrect Accept header.\"\"\"\n    mcp_url = f\"{json_server_url}/mcp\"\n    # Test with only text/event-stream (wrong for JSON server)\n    response = requests.post(\n        mcp_url,\n        headers={\n            \"Accept\": \"text/event-stream\",\n            \"Content-Type\": \"application/json\",\n        },\n        json=INIT_REQUEST,\n    )\n    assert response.status_code == 406\n    assert \"Not Acceptable\" in response.text",
      "input_schema": {
        "type": "object",
        "properties": {
          "json_response_server": {
            "type": "string",
            "required": true
          },
          "json_server_url": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "json_response_server",
          "json_server_url"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "json_response_server": "string",
          "json_server_url": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_json_response_incorrect_accept_header` in tests\\shared\\test_streamable_http.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        },
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.26,
      "evidence": [
        "function test_json_response_incorrect_accept_header in tests\\shared\\test_streamable_http.py",
        "matched template: make an HTTP request to an external API (sim=0.32)"
      ]
    },
    {
      "name": "test_get_sse_stream",
      "description": "stream data over websocket. Function `test_get_sse_stream`.",
      "predicted_filename": "tests\\shared\\test_streamable_http.py",
      "predicted_code_snippet": "def test_get_sse_stream(basic_server: None, basic_server_url: str):\n    \"\"\"Test establishing an SSE stream via GET request.\"\"\"\n    # First, we need to initialize a session\n    mcp_url = f\"{basic_server_url}/mcp\"\n    init_response = requests.post(\n        mcp_url,\n        headers={\n            \"Accept\": \"application/json, text/event-stream\",\n            \"Content-Type\": \"application/json\",\n        },\n        json=INIT_REQUEST,\n    )\n    assert init_response.status_code == 200\n\n    # Get the session ID\n    session_id = init_response.headers.get(MCP_SESSION_ID_HEADER)\n    assert session_id is not None\n\n    # Extract negotiated protocol version from SSE response\n    init_data = None\n    assert init_response.headers.get(\"Content-Type\") == \"text/event-stream\"\n    for line in init_response.text.splitlines():  # pragma: no branch\n        if line.startswith(\"data: \"):  # pragma: no cover\n            init_data = json.loads(line[6:])\n            break\n    assert init_data is not None\n    negotiated_version = init_data[\"result\"][\"protocolVersion\"]\n\n    # Now attempt to establish an SSE stream via GET\n    get_response = requests.get(\n        mcp_url,\n        headers={\n            \"Accept\": \"text/event-stream\",\n            MCP_SESSION_ID_HEADER: session_id,\n            MCP_PROTOCOL_VERSION_HEADER: negotiated_version,\n        },\n        stream=True,\n    )\n\n    # Verify we got a successful response with the right content type\n    assert get_response.status_code == 200\n    assert get_response.headers.get(\"Content-Type\") == \"text/event-stream\"\n\n    # Test that a second GET request gets rejected (only one stream allowed)\n    second_get = requests.get(\n        mcp_url,\n        headers={\n            \"Accept\": \"text/event-stream\",\n            MCP_SESSION_ID_HEADER: session_id,\n            MCP_PROTOCOL_VERSION_HEADER: negotiated_version,\n        },\n        stream=True,\n    )\n\n    # Should get CONFLICT (409) since there's already a stream\n    # Note: This might fail if the first stream fully closed before this runs,\n    # but generally it should work in the test environment where it runs quickly\n    assert second_get.status_code == 409",
      "input_schema": {
        "type": "object",
        "properties": {
          "basic_server": {
            "type": "string",
            "required": true
          },
          "basic_server_url": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "basic_server",
          "basic_server_url"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "basic_server": "string",
          "basic_server_url": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_get_sse_stream` in tests\\shared\\test_streamable_http.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        },
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.23,
      "evidence": [
        "function test_get_sse_stream in tests\\shared\\test_streamable_http.py",
        "matched template: stream data over websocket (sim=0.27)"
      ]
    },
    {
      "name": "test_get_validation",
      "description": "parse JSON input and validate fields. Function `test_get_validation`.",
      "predicted_filename": "tests\\shared\\test_streamable_http.py",
      "predicted_code_snippet": "def test_get_validation(basic_server: None, basic_server_url: str):\n    \"\"\"Test validation for GET requests.\"\"\"\n    # First, we need to initialize a session\n    mcp_url = f\"{basic_server_url}/mcp\"\n    init_response = requests.post(\n        mcp_url,\n        headers={\n            \"Accept\": \"application/json, text/event-stream\",\n            \"Content-Type\": \"application/json\",\n        },\n        json=INIT_REQUEST,\n    )\n    assert init_response.status_code == 200\n\n    # Get the session ID\n    session_id = init_response.headers.get(MCP_SESSION_ID_HEADER)\n    assert session_id is not None\n\n    # Extract negotiated protocol version from SSE response\n    init_data = None\n    assert init_response.headers.get(\"Content-Type\") == \"text/event-stream\"\n    for line in init_response.text.splitlines():  # pragma: no branch\n        if line.startswith(\"data: \"):  # pragma: no cover\n            init_data = json.loads(line[6:])\n            break\n    assert init_data is not None\n    negotiated_version = init_data[\"result\"][\"protocolVersion\"]\n\n    # Test without Accept header\n    response = requests.get(\n        mcp_url,\n        headers={\n            MCP_SESSION_ID_HEADER: session_id,\n            MCP_PROTOCOL_VERSION_HEADER: negotiated_version,\n        },\n        stream=True,\n    )\n    assert response.status_code == 406\n    assert \"Not Acceptable\" in response.text\n\n    # Test with wrong Accept header\n    response = requests.get(\n        mcp_url,\n        headers={\n            \"Accept\": \"application/json\",\n            MCP_SESSION_ID_HEADER: session_id,\n            MCP_PROTOCOL_VERSION_HEADER: negotiated_version,\n        },\n    )\n    assert response.status_code == 406\n    assert \"Not Acceptable\" in response.text",
      "input_schema": {
        "type": "object",
        "properties": {
          "basic_server": {
            "type": "string",
            "required": true
          },
          "basic_server_url": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "basic_server",
          "basic_server_url"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "basic_server": "string",
          "basic_server_url": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_get_validation` in tests\\shared\\test_streamable_http.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        },
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.24,
      "evidence": [
        "function test_get_validation in tests\\shared\\test_streamable_http.py",
        "matched template: parse JSON input and validate fields (sim=0.29)"
      ]
    },
    {
      "name": "run_context_aware_server",
      "description": "stream data over websocket. Function `run_context_aware_server`.",
      "predicted_filename": "tests\\shared\\test_streamable_http.py",
      "predicted_code_snippet": "def run_context_aware_server(port: int):  # pragma: no cover\n    \"\"\"Run the context-aware test server.\"\"\"\n    server = ContextAwareServerTest()\n\n    session_manager = StreamableHTTPSessionManager(\n        app=server,\n        event_store=None,\n        json_response=False,\n    )\n\n    app = Starlette(\n        debug=True,\n        routes=[\n            Mount(\"/mcp\", app=session_manager.handle_request),\n        ],\n        lifespan=lambda app: session_manager.run(),\n    )\n\n    server_instance = uvicorn.Server(\n        config=uvicorn.Config(\n            app=app,\n            host=\"127.0.0.1\",\n            port=port,\n            log_level=\"error\",\n        )\n    )\n    server_instance.run()",
      "input_schema": {
        "type": "object",
        "properties": {
          "port": {
            "type": "integer",
            "required": true
          }
        },
        "required": [
          "port"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "port": "integer"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `run_context_aware_server` in tests\\shared\\test_streamable_http.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        },
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.28,
      "evidence": [
        "function run_context_aware_server in tests\\shared\\test_streamable_http.py",
        "matched template: stream data over websocket (sim=0.35)"
      ]
    },
    {
      "name": "context_aware_server",
      "description": "stream data over websocket. Function `context_aware_server`.",
      "predicted_filename": "tests\\shared\\test_streamable_http.py",
      "predicted_code_snippet": "def context_aware_server(basic_server_port: int) -> Generator[None, None, None]:\n    \"\"\"Start the context-aware server in a separate process.\"\"\"\n    proc = multiprocessing.Process(target=run_context_aware_server, args=(basic_server_port,), daemon=True)\n    proc.start()\n\n    # Wait for server to be running\n    wait_for_server(basic_server_port)\n\n    yield\n\n    proc.kill()\n    proc.join(timeout=2)\n    if proc.is_alive():  # pragma: no cover\n        print(\"Context-aware server process failed to terminate\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "basic_server_port": {
            "type": "integer",
            "required": true
          }
        },
        "required": [
          "basic_server_port"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "basic_server_port": "integer"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `context_aware_server` in tests\\shared\\test_streamable_http.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        },
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.27,
      "evidence": [
        "function context_aware_server in tests\\shared\\test_streamable_http.py",
        "matched template: stream data over websocket (sim=0.34)"
      ]
    },
    {
      "name": "test_server_validates_protocol_version_header",
      "description": "handle a HTTP route request and return response. Function `test_server_validates_protocol_version_header`.",
      "predicted_filename": "tests\\shared\\test_streamable_http.py",
      "predicted_code_snippet": "def test_server_validates_protocol_version_header(basic_server: None, basic_server_url: str):\n    \"\"\"Test that server returns 400 Bad Request version if header unsupported or invalid.\"\"\"\n    # First initialize a session to get a valid session ID\n    init_response = requests.post(\n        f\"{basic_server_url}/mcp\",\n        headers={\n            \"Accept\": \"application/json, text/event-stream\",\n            \"Content-Type\": \"application/json\",\n        },\n        json=INIT_REQUEST,\n    )\n    assert init_response.status_code == 200\n    session_id = init_response.headers.get(MCP_SESSION_ID_HEADER)\n\n    # Test request with invalid protocol version (should fail)\n    response = requests.post(\n        f\"{basic_server_url}/mcp\",\n        headers={\n            \"Accept\": \"application/json, text/event-stream\",\n            \"Content-Type\": \"application/json\",\n            MCP_SESSION_ID_HEADER: session_id,\n            MCP_PROTOCOL_VERSION_HEADER: \"invalid-version\",\n        },\n        json={\"jsonrpc\": \"2.0\", \"method\": \"tools/list\", \"id\": \"test-2\"},\n    )\n    assert response.status_code == 400\n    assert MCP_PROTOCOL_VERSION_HEADER in response.text or \"protocol version\" in response.text.lower()\n\n    # Test request with unsupported protocol version (should fail)\n    response = requests.post(\n        f\"{basic_server_url}/mcp\",\n        headers={\n            \"Accept\": \"application/json, text/event-stream\",\n            \"Content-Type\": \"application/json\",\n            MCP_SESSION_ID_HEADER: session_id,\n            MCP_PROTOCOL_VERSION_HEADER: \"1999-01-01\",  # Very old unsupported version\n        },\n        json={\"jsonrpc\": \"2.0\", \"method\": \"tools/list\", \"id\": \"test-3\"},\n    )\n    assert response.status_code == 400\n    assert MCP_PROTOCOL_VERSION_HEADER in response.text or \"protocol version\" in response.text.lower()\n\n    # Test request with valid protocol version (should succeed)\n    negotiated_version = extract_protocol_version_from_sse(init_response)\n\n    response = requests.post(\n        f\"{basic_server_url}/mcp\",\n        headers={\n            \"Accept\": \"application/json, text/event-stream\",\n            \"Content-Type\": \"application/json\",\n            MCP_SESSION_ID_HEADER: session_id,\n            MCP_PROTOCOL_VERSION_HEADER: negotiated_version,\n        },\n        json={\"jsonrpc\": \"2.0\", \"method\": \"tools/list\", \"id\": \"test-4\"},\n    )\n    assert response.status_code == 200",
      "input_schema": {
        "type": "object",
        "properties": {
          "basic_server": {
            "type": "string",
            "required": true
          },
          "basic_server_url": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "basic_server",
          "basic_server_url"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "basic_server": "string",
          "basic_server_url": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_server_validates_protocol_version_header` in tests\\shared\\test_streamable_http.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        },
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.26,
      "evidence": [
        "function test_server_validates_protocol_version_header in tests\\shared\\test_streamable_http.py",
        "matched template: handle a HTTP route request and return response (sim=0.32)"
      ]
    },
    {
      "name": "test_server_backwards_compatibility_no_protocol_version",
      "description": "handle a HTTP route request and return response. Function `test_server_backwards_compatibility_no_protocol_version`.",
      "predicted_filename": "tests\\shared\\test_streamable_http.py",
      "predicted_code_snippet": "def test_server_backwards_compatibility_no_protocol_version(basic_server: None, basic_server_url: str):\n    \"\"\"Test server accepts requests without protocol version header.\"\"\"\n    # First initialize a session to get a valid session ID\n    init_response = requests.post(\n        f\"{basic_server_url}/mcp\",\n        headers={\n            \"Accept\": \"application/json, text/event-stream\",\n            \"Content-Type\": \"application/json\",\n        },\n        json=INIT_REQUEST,\n    )\n    assert init_response.status_code == 200\n    session_id = init_response.headers.get(MCP_SESSION_ID_HEADER)\n\n    # Test request without mcp-protocol-version header (backwards compatibility)\n    response = requests.post(\n        f\"{basic_server_url}/mcp\",\n        headers={\n            \"Accept\": \"application/json, text/event-stream\",\n            \"Content-Type\": \"application/json\",\n            MCP_SESSION_ID_HEADER: session_id,\n        },\n        json={\"jsonrpc\": \"2.0\", \"method\": \"tools/list\", \"id\": \"test-backwards-compat\"},\n        stream=True,\n    )\n    assert response.status_code == 200  # Should succeed for backwards compatibility\n    assert response.headers.get(\"Content-Type\") == \"text/event-stream\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "basic_server": {
            "type": "string",
            "required": true
          },
          "basic_server_url": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "basic_server",
          "basic_server_url"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "basic_server": "string",
          "basic_server_url": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_server_backwards_compatibility_no_protocol_version` in tests\\shared\\test_streamable_http.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        },
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.23,
      "evidence": [
        "function test_server_backwards_compatibility_no_protocol_version in tests\\shared\\test_streamable_http.py",
        "matched template: handle a HTTP route request and return response (sim=0.28)"
      ]
    },
    {
      "name": "escape_path_for_python",
      "description": "validate and sanitize user input. Function `escape_path_for_python`.",
      "predicted_filename": "tests\\shared\\test_win32_utils.py",
      "predicted_code_snippet": "def escape_path_for_python(path: str) -> str:\n    \"\"\"Escape a file path for use in Python code strings.\n\n    Converts backslashes to forward slashes which work on all platforms\n    and don't need escaping in Python strings.\n    \"\"\"\n    return repr(path.replace(\"\\\\\", \"/\"))",
      "input_schema": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "path"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "path": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `escape_path_for_python` in tests\\shared\\test_win32_utils.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function escape_path_for_python in tests\\shared\\test_win32_utils.py",
        "matched template: validate and sanitize user input (sim=0.16)"
      ]
    },
    {
      "name": "server_port",
      "description": "stream data over websocket. Function `server_port`.",
      "predicted_filename": "tests\\shared\\test_ws.py",
      "predicted_code_snippet": "def server_port() -> int:\n    with socket.socket() as s:\n        s.bind((\"127.0.0.1\", 0))\n        return s.getsockname()[1]",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "integer"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "integer"
        }
      },
      "explanation": "Detected Python function `server_port` in tests\\shared\\test_ws.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        }
      ],
      "confidence": 0.33,
      "evidence": [
        "function server_port in tests\\shared\\test_ws.py",
        "matched template: stream data over websocket (sim=0.42)"
      ]
    },
    {
      "name": "server_url",
      "description": "stream data over websocket. Function `server_url`.",
      "predicted_filename": "tests\\shared\\test_ws.py",
      "predicted_code_snippet": "def server_url(server_port: int) -> str:\n    return f\"ws://127.0.0.1:{server_port}\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "server_port": {
            "type": "integer",
            "required": true
          }
        },
        "required": [
          "server_port"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "server_port": "integer"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `server_url` in tests\\shared\\test_ws.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        }
      ],
      "confidence": 0.3,
      "evidence": [
        "function server_url in tests\\shared\\test_ws.py",
        "matched template: stream data over websocket (sim=0.39)"
      ]
    },
    {
      "name": "make_server_app",
      "description": "stream data over websocket. Function `make_server_app`.",
      "predicted_filename": "tests\\shared\\test_ws.py",
      "predicted_code_snippet": "def make_server_app() -> Starlette:  # pragma: no cover\n    \"\"\"Create test Starlette app with WebSocket transport\"\"\"\n    server = ServerTest()\n\n    async def handle_ws(websocket: WebSocket):\n        async with websocket_server(websocket.scope, websocket.receive, websocket.send) as streams:\n            await server.run(streams[0], streams[1], server.create_initialization_options())\n\n    app = Starlette(\n        routes=[\n            WebSocketRoute(\"/ws\", endpoint=handle_ws),\n        ]\n    )\n\n    return app",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `make_server_app` in tests\\shared\\test_ws.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        }
      ],
      "confidence": 0.38,
      "evidence": [
        "function make_server_app in tests\\shared\\test_ws.py",
        "matched template: stream data over websocket (sim=0.49)"
      ]
    },
    {
      "name": "run_server",
      "description": "stream data over websocket. Function `run_server`.",
      "predicted_filename": "tests\\shared\\test_ws.py",
      "predicted_code_snippet": "def run_server(server_port: int) -> None:  # pragma: no cover\n    app = make_server_app()\n    server = uvicorn.Server(config=uvicorn.Config(app=app, host=\"127.0.0.1\", port=server_port, log_level=\"error\"))\n    print(f\"starting server on {server_port}\")\n    server.run()\n\n    # Give server time to start\n    while not server.started:\n        print(\"waiting for server to start\")\n        time.sleep(0.5)",
      "input_schema": {
        "type": "object",
        "properties": {
          "server_port": {
            "type": "integer",
            "required": true
          }
        },
        "required": [
          "server_port"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "server_port": "integer"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `run_server` in tests\\shared\\test_ws.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        }
      ],
      "confidence": 0.25,
      "evidence": [
        "function run_server in tests\\shared\\test_ws.py",
        "matched template: stream data over websocket (sim=0.31)"
      ]
    },
    {
      "name": "server",
      "description": "stream data over websocket. Function `server`.",
      "predicted_filename": "tests\\shared\\test_ws.py",
      "predicted_code_snippet": "def server(server_port: int) -> Generator[None, None, None]:\n    proc = multiprocessing.Process(target=run_server, kwargs={\"server_port\": server_port}, daemon=True)\n    print(\"starting process\")\n    proc.start()\n\n    # Wait for server to be running\n    print(\"waiting for server to start\")\n    wait_for_server(server_port)\n\n    yield\n\n    print(\"killing server\")\n    # Signal the server to stop\n    proc.kill()\n    proc.join(timeout=2)\n    if proc.is_alive():  # pragma: no cover\n        print(\"server process failed to terminate\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "server_port": {
            "type": "integer",
            "required": true
          }
        },
        "required": [
          "server_port"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "server_port": "integer"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `server` in tests\\shared\\test_ws.py",
      "possible_syscalls": [
        {
          "syscall": "socket",
          "reason": "socket operations found"
        }
      ],
      "confidence": 0.22,
      "evidence": [
        "function server in tests\\shared\\test_ws.py",
        "matched template: stream data over websocket (sim=0.25)"
      ]
    },
    {
      "name": "pyproject",
      "description": "authenticate a user and return a token. File `examples\\clients\\simple-auth-client\\pyproject.toml`.",
      "predicted_filename": "examples\\clients\\simple-auth-client\\pyproject.toml",
      "predicted_code_snippet": "[project]\nname = \"mcp-simple-auth-client\"\nversion = \"0.1.0\"\ndescription = \"A simple OAuth client for the MCP simple-auth server\"\nreadme = \"README.md\"\nrequires-python = \">=3.10\"\nauthors = [{ name = \"Anthropic\" }]\nkeywords = [\"mcp\", \"oauth\", \"client\", \"auth\"]\nlicense = { text = \"MIT\" }\nclassifiers = [\n    \"Development Status :: 4 - Beta\",\n    \"Intended Audience :: Developers\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Programming Language :: Python :: 3\",\n    \"Programming Language :: Python :: 3.10\",\n]\ndependencies = [\"click>=8.2.0\", \"mcp\"]\n\n[project.scripts]\nmcp-simple-auth-client = \"mcp_simple_auth_client.main:cli\"\n\n[build-system]\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n\n[tool.hatch.build.targets.wheel]\npackages = [\"mcp_simple_auth_client\"]\n\n[tool.pyright]\ninclude = [\"mcp_simple_auth_client\"]",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file examples\\clients\\simple-auth-client\\pyproject.toml",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "file examples\\clients\\simple-auth-client\\pyproject.toml exists under tools/"
      ]
    },
    {
      "name": "README",
      "description": "authenticate a user and return a token. File `examples\\clients\\simple-auth-client\\README.md`.",
      "predicted_filename": "examples\\clients\\simple-auth-client\\README.md",
      "predicted_code_snippet": "# Simple Auth Client Example\n\nA demonstration of how to use the MCP Python SDK with OAuth authentication over streamable HTTP or SSE transport.\n\n## Features\n\n- OAuth 2.0 authentication with PKCE\n- Support for both StreamableHTTP and SSE transports\n- Interactive command-line interface\n\n## Installation\n\n```bash\ncd examples/clients/simple-auth-client\nuv sync --reinstall \n```\n\n## Usage\n\n### 1. Start an MCP server with OAuth support\n\n```bash\n# Example with mcp-simple-auth\ncd path/to/mcp-simple-auth\nuv run mcp-simple-auth --transport streamable-http --port 3001\n```\n\n### 2. Run the client\n\n```bash",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file examples\\clients\\simple-auth-client\\README.md",
      "possible_syscalls": [],
      "confidence": 0.24,
      "evidence": [
        "file examples\\clients\\simple-auth-client\\README.md exists under tools/"
      ]
    },
    {
      "name": "__init__",
      "description": "authenticate a user and return a token. File `examples\\clients\\simple-auth-client\\mcp_simple_auth_client\\__init__.py`.",
      "predicted_filename": "examples\\clients\\simple-auth-client\\mcp_simple_auth_client\\__init__.py",
      "predicted_code_snippet": "\"\"\"Simple OAuth client for MCP simple-auth server.\"\"\"",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file examples\\clients\\simple-auth-client\\mcp_simple_auth_client\\__init__.py",
      "possible_syscalls": [],
      "confidence": 0.28,
      "evidence": [
        "file examples\\clients\\simple-auth-client\\mcp_simple_auth_client\\__init__.py exists under tools/"
      ]
    },
    {
      "name": ".python-version",
      "description": "send an email notification. File `examples\\clients\\simple-chatbot\\.python-version`.",
      "predicted_filename": "examples\\clients\\simple-chatbot\\.python-version",
      "predicted_code_snippet": "3.10",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file examples\\clients\\simple-chatbot\\.python-version",
      "possible_syscalls": [],
      "confidence": 0.15,
      "evidence": [
        "file examples\\clients\\simple-chatbot\\.python-version exists under tools/"
      ]
    },
    {
      "name": "pyproject",
      "description": "serialize object to JSON. File `examples\\clients\\simple-chatbot\\pyproject.toml`.",
      "predicted_filename": "examples\\clients\\simple-chatbot\\pyproject.toml",
      "predicted_code_snippet": "[project]\nname = \"mcp-simple-chatbot\"\nversion = \"0.1.0\"\ndescription = \"A simple CLI chatbot using the Model Context Protocol (MCP)\"\nreadme = \"README.md\"\nrequires-python = \">=3.10\"\nauthors = [{ name = \"Edoardo Cilia\" }]\nkeywords = [\"mcp\", \"llm\", \"chatbot\", \"cli\"]\nlicense = { text = \"MIT\" }\nclassifiers = [\n    \"Development Status :: 4 - Beta\",\n    \"Intended Audience :: Developers\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Programming Language :: Python :: 3\",\n    \"Programming Language :: Python :: 3.10\",\n]\ndependencies = [\n    \"python-dotenv>=1.0.0\",\n    \"requests>=2.31.0\",\n    \"mcp\",\n    \"uvicorn>=0.32.1\",\n]\n\n[project.scripts]\nmcp-simple-chatbot = \"mcp_simple_chatbot.main:main\"\n\n[build-system]\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file examples\\clients\\simple-chatbot\\pyproject.toml",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "file examples\\clients\\simple-chatbot\\pyproject.toml exists under tools/"
      ]
    },
    {
      "name": "README",
      "description": "make an HTTP request to an external API. File `examples\\clients\\simple-chatbot\\README.MD`.",
      "predicted_filename": "examples\\clients\\simple-chatbot\\README.MD",
      "predicted_code_snippet": "# MCP Simple Chatbot\n\nThis example demonstrates how to integrate the Model Context Protocol (MCP) into a simple CLI chatbot. The implementation showcases MCP's flexibility by supporting multiple tools through MCP servers and is compatible with any LLM provider that follows OpenAI API standards.\n\n## Requirements\n\n- Python 3.10\n- `python-dotenv`\n- `requests`\n- `mcp`\n- `uvicorn`\n\n## Installation\n\n1. **Install the dependencies:**\n\n   ```bash\n   pip install -r requirements.txt\n   ```\n\n2. **Set up environment variables:**\n\n   Create a `.env` file in the root directory and add your API key:\n\n   ```plaintext\n   LLM_API_KEY=your_api_key_here\n   ```\n\n   **Note:** The current implementation is configured to use the Groq API endpoint (`https://api.groq.com/openai/v1/chat/completions`) with the `llama-3.2-90b-vision-preview` model. If you plan to use a different LLM provider, you'll need to modify the `LLMClient` class in `main.py` to use the appropriate endpoint URL and model parameters.\n",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file examples\\clients\\simple-chatbot\\README.MD",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "file examples\\clients\\simple-chatbot\\README.MD exists under tools/"
      ]
    },
    {
      "name": ".env",
      "description": "make an HTTP request to an external API. File `examples\\clients\\simple-chatbot\\mcp_simple_chatbot\\.env.example`.",
      "predicted_filename": "examples\\clients\\simple-chatbot\\mcp_simple_chatbot\\.env.example",
      "predicted_code_snippet": "LLM_API_KEY=gsk_1234567890",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file examples\\clients\\simple-chatbot\\mcp_simple_chatbot\\.env.example",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "file examples\\clients\\simple-chatbot\\mcp_simple_chatbot\\.env.example exists under tools/"
      ]
    },
    {
      "name": "requirements",
      "description": "make an HTTP request to an external API. File `examples\\clients\\simple-chatbot\\mcp_simple_chatbot\\requirements.txt`.",
      "predicted_filename": "examples\\clients\\simple-chatbot\\mcp_simple_chatbot\\requirements.txt",
      "predicted_code_snippet": "python-dotenv>=1.0.0\nrequests>=2.31.0\nmcp>=1.0.0\nuvicorn>=0.32.1",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file examples\\clients\\simple-chatbot\\mcp_simple_chatbot\\requirements.txt",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "file examples\\clients\\simple-chatbot\\mcp_simple_chatbot\\requirements.txt exists under tools/"
      ]
    },
    {
      "name": "servers_config",
      "description": "execute a shell command. File `examples\\clients\\simple-chatbot\\mcp_simple_chatbot\\servers_config.json`.",
      "predicted_filename": "examples\\clients\\simple-chatbot\\mcp_simple_chatbot\\servers_config.json",
      "predicted_code_snippet": "{\n  \"mcpServers\": {\n    \"sqlite\": {\n      \"command\": \"uvx\",\n      \"args\": [\"mcp-server-sqlite\", \"--db-path\", \"./test.db\"]\n    },\n    \"puppeteer\": {\n      \"command\": \"npx\",\n      \"args\": [\"-y\", \"@modelcontextprotocol/server-puppeteer\"]\n    }\n  }\n}",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file examples\\clients\\simple-chatbot\\mcp_simple_chatbot\\servers_config.json",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "file examples\\clients\\simple-chatbot\\mcp_simple_chatbot\\servers_config.json exists under tools/"
      ]
    },
    {
      "name": "test",
      "description": "perform database query and return records. File `examples\\clients\\simple-chatbot\\mcp_simple_chatbot\\test.db`.",
      "predicted_filename": "examples\\clients\\simple-chatbot\\mcp_simple_chatbot\\test.db",
      "predicted_code_snippet": "SQLite format 3\u0000\u0010\u0000\u0001\u0001\u0000@  \u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0002\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0004\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0001\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0002\u0000.v\ufffd\n\u0000\u0000\u0000\u0001\u000f\ufffd\u0000\u000f\ufffd\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000j\u0001\u0007\u0017\n\n\u0001\ufffd'tableproductsproducts\u0002CREATE TABLE products (\n  id INTEGER PRIMARY KEY,\n  name TEXT,\n  price REAL\n)\n\u0000\u0000\u0000\u0014\u000e\u0007\u0000\u000f\ufffd\u000f\ufffd\u000f\ufffd\u000f\ufffd\u000f\ufffd\u000fp\u000fQ\u000f8\u000f\n\u000f\u0005\u000e\ufffd\u000e\ufffd\u000e\ufffd\u000e\ufffd\u000e\ufffd\u000ev\u000eZ\u000e>\u000e!\u000e\u0007\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0000\u0018\u0014\u0004\u0000%\u0007Portable SSD@f\u007f\ufffd\u0014z\ufffdH\u001b\u0013\u0004\u0000+\u0007Fitness Tracker@]\ufffd\\(\ufffd\u008f\u001a\u0012\u0004\u0000)\u0007Gaming Headset@c\ufffd\ufffd\u0014z\ufffdH\u001a\u0011\u0004\u0000)\u0007Travel Adapter@;\ufffdp\ufffd\ufffd\n=\n\u0010\u0004\u0000-\u0007Screen Protector@#\ufffd\ufffdG\ufffd\u0014{\u0012\u000f\u0004\u0000\u0019\u0007Webcam@Q\u007f\\(\ufffd\u008f\u0013\u000e\u0004\u0000\u001b\u0007USB Hub@H\ufffd\ufffdQ\ufffd\u001f\u0015\n\u0004\u0000\u001f\u0007Mouse Pad@)\ufffd\ufffdG\ufffd\u0014{\u0014\n\u0004\u0000\n\u0007Keyboard@`?\ufffd\u0014z\ufffdH\u0019\n\u0004\u0000'\u0007LED Desk Lamp@F\ufffd\ufffdQ\ufffd\u001f\u0016\n\u0004\u0000!\u0007Mini Drone@r\ufffd\ufffd\n=p\ufffd\u0019\t\u0004\u0000'\u0007Laptop Sleeve@A~\ufffdQ\ufffd\u001f\u0017\b\u0004\u0000#\u0007Phone Stand@/\ufffd\ufffdG\ufffd\u0014{\n\u0007\u0004\u0000/\u0007Bluetooth Speaker@S\ufffd\\(\ufffd\u008f\n\u0006\u0004\u0000-\u0007Portable Charger@8\ufffdp\ufffd\ufffd\n=\n\u0005\u0004\u0000-\u0007Wireless Earbuds@V\u007f\\(\ufffd\u008f\u0017\u0004\u0004\u0000#\u0007Smart Watch@h\ufffd\ufffd\u0014z\ufffdH\u0011\u0003\u0004\u0000\u0017\u0007Gizmo@C\ufffd\ufffdQ\ufffd\u001f\u0012\u0002\u0004\u0000\u0019\u0007Gadget@=\ufffdp\ufffd\ufffd\n=\u0012\u0001\u0004\u0000\u0019\u0007Widget@3\ufffdp\ufffd\ufffd\n=",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file examples\\clients\\simple-chatbot\\mcp_simple_chatbot\\test.db",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "file examples\\clients\\simple-chatbot\\mcp_simple_chatbot\\test.db exists under tools/"
      ]
    },
    {
      "name": "pagination_client",
      "description": "cache results to disk or memory. File `examples\\snippets\\clients\\pagination_client.py`.",
      "predicted_filename": "examples\\snippets\\clients\\pagination_client.py",
      "predicted_code_snippet": "\"\"\"\nExample of consuming paginated MCP endpoints from a client.\n\"\"\"\n\nimport asyncio\n\nfrom mcp.client.session import ClientSession\nfrom mcp.client.stdio import StdioServerParameters, stdio_client\nfrom mcp.types import PaginatedRequestParams, Resource\n\n\nasync def list_all_resources() -> None:\n    \"\"\"Fetch all resources using pagination.\"\"\"\n    async with stdio_client(StdioServerParameters(command=\"uv\", args=[\"run\", \"mcp-simple-pagination\"])) as (\n        read,\n        write,\n    ):\n        async with ClientSession(read, write) as session:\n            await session.initialize()\n\n            all_resources: list[Resource] = []\n            cursor = None\n\n            while True:\n                # Fetch a page of resources\n                result = await session.list_resources(params=PaginatedRequestParams(cursor=cursor))\n                all_resources.extend(result.resources)\n\n                print(f\"Fetched {len(result.resources)} resources\")\n",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file examples\\snippets\\clients\\pagination_client.py",
      "possible_syscalls": [],
      "confidence": 0.24,
      "evidence": [
        "file examples\\snippets\\clients\\pagination_client.py exists under tools/"
      ]
    },
    {
      "name": "parsing_tool_results",
      "description": "parse JSON input and validate fields. File `examples\\snippets\\clients\\parsing_tool_results.py`.",
      "predicted_filename": "examples\\snippets\\clients\\parsing_tool_results.py",
      "predicted_code_snippet": "\"\"\"examples/snippets/clients/parsing_tool_results.py\"\"\"\n\nimport asyncio\n\nfrom mcp import ClientSession, StdioServerParameters, types\nfrom mcp.client.stdio import stdio_client\n\n\nasync def parse_tool_results():\n    \"\"\"Demonstrates how to parse different types of content in CallToolResult.\"\"\"\n    server_params = StdioServerParameters(command=\"python\", args=[\"path/to/mcp_server.py\"])\n\n    async with stdio_client(server_params) as (read, write):\n        async with ClientSession(read, write) as session:\n            await session.initialize()\n\n            # Example 1: Parsing text content\n            result = await session.call_tool(\"get_data\", {\"format\": \"text\"})\n            for content in result.content:\n                if isinstance(content, types.TextContent):\n                    print(f\"Text: {content.text}\")\n\n            # Example 2: Parsing structured content from JSON tools\n            result = await session.call_tool(\"get_user\", {\"id\": \"123\"})\n            if hasattr(result, \"structuredContent\") and result.structuredContent:\n                # Access structured data directly\n                user_data = result.structuredContent\n                print(f\"User: {user_data.get('name')}, Age: {user_data.get('age')}\")\n\n            # Example 3: Parsing embedded resources",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file examples\\snippets\\clients\\parsing_tool_results.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "file examples\\snippets\\clients\\parsing_tool_results.py exists under tools/"
      ]
    },
    {
      "name": "streamable_basic",
      "description": "stream data over websocket. File `examples\\snippets\\clients\\streamable_basic.py`.",
      "predicted_filename": "examples\\snippets\\clients\\streamable_basic.py",
      "predicted_code_snippet": "\"\"\"\nRun from the repository root:\n    uv run examples/snippets/clients/streamable_basic.py\n\"\"\"\n\nimport asyncio\n\nfrom mcp import ClientSession\nfrom mcp.client.streamable_http import streamablehttp_client\n\n\nasync def main():\n    # Connect to a streamable HTTP server\n    async with streamablehttp_client(\"http://localhost:8000/mcp\") as (\n        read_stream,\n        write_stream,\n        _,\n    ):\n        # Create a session using the client streams\n        async with ClientSession(read_stream, write_stream) as session:\n            # Initialize the connection\n            await session.initialize()\n            # List available tools\n            tools = await session.list_tools()\n            print(f\"Available tools: {[tool.name for tool in tools.tools]}\")\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file examples\\snippets\\clients\\streamable_basic.py",
      "possible_syscalls": [],
      "confidence": 0.3,
      "evidence": [
        "file examples\\snippets\\clients\\streamable_basic.py exists under tools/"
      ]
    },
    {
      "name": "__init__",
      "description": "send an email notification. File `examples\\snippets\\clients\\__init__.py`.",
      "predicted_filename": "examples\\snippets\\clients\\__init__.py",
      "predicted_code_snippet": "",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file examples\\snippets\\clients\\__init__.py",
      "possible_syscalls": [],
      "confidence": 0.16,
      "evidence": [
        "file examples\\snippets\\clients\\__init__.py exists under tools/"
      ]
    },
    {
      "name": "__init__",
      "description": "execute a shell command. File `src\\mcp\\cli\\__init__.py`.",
      "predicted_filename": "src\\mcp\\cli\\__init__.py",
      "predicted_code_snippet": "\"\"\"FastMCP CLI package.\"\"\"\n\nfrom .cli import app\n\nif __name__ == \"__main__\":  # pragma: no cover\n    app()",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file src\\mcp\\cli\\__init__.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "file src\\mcp\\cli\\__init__.py exists under tools/"
      ]
    },
    {
      "name": "session",
      "description": "stream data over websocket. File `src\\mcp\\client\\session.py`.",
      "predicted_filename": "src\\mcp\\client\\session.py",
      "predicted_code_snippet": "import logging\nfrom datetime import timedelta\nfrom typing import Any, Protocol, overload\n\nimport anyio.lowlevel\nfrom anyio.streams.memory import MemoryObjectReceiveStream, MemoryObjectSendStream\nfrom pydantic import AnyUrl, TypeAdapter\nfrom typing_extensions import deprecated\n\nimport mcp.types as types\nfrom mcp.shared.context import RequestContext\nfrom mcp.shared.message import SessionMessage\nfrom mcp.shared.session import BaseSession, ProgressFnT, RequestResponder\nfrom mcp.shared.version import SUPPORTED_PROTOCOL_VERSIONS\n\nDEFAULT_CLIENT_INFO = types.Implementation(name=\"mcp\", version=\"0.1.0\")\n\nlogger = logging.getLogger(\"client\")\n\n\nclass SamplingFnT(Protocol):\n    async def __call__(\n        self,\n        context: RequestContext[\"ClientSession\", Any],\n        params: types.CreateMessageRequestParams,\n    ) -> types.CreateMessageResult | types.ErrorData: ...  # pragma: no branch\n\n\nclass ElicitationFnT(Protocol):\n    async def __call__(",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file src\\mcp\\client\\session.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "file src\\mcp\\client\\session.py exists under tools/"
      ]
    },
    {
      "name": "session_group",
      "description": "cache results to disk or memory. File `src\\mcp\\client\\session_group.py`.",
      "predicted_filename": "src\\mcp\\client\\session_group.py",
      "predicted_code_snippet": "\"\"\"\nSessionGroup concurrently manages multiple MCP session connections.\n\nTools, resources, and prompts are aggregated across servers. Servers may\nbe connected to or disconnected from at any point after initialization.\n\nThis abstractions can handle naming collisions using a custom user-provided\nhook.\n\"\"\"\n\nimport contextlib\nimport logging\nfrom collections.abc import Callable\nfrom dataclasses import dataclass\nfrom datetime import timedelta\nfrom types import TracebackType\nfrom typing import Any, TypeAlias, overload\n\nimport anyio\nfrom pydantic import BaseModel\nfrom typing_extensions import Self, deprecated\n\nimport mcp\nfrom mcp import types\nfrom mcp.client.session import ElicitationFnT, ListRootsFnT, LoggingFnT, MessageHandlerFnT, SamplingFnT\nfrom mcp.client.sse import sse_client\nfrom mcp.client.stdio import StdioServerParameters\nfrom mcp.client.streamable_http import streamablehttp_client\nfrom mcp.shared.exceptions import McpError\nfrom mcp.shared.session import ProgressFnT",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file src\\mcp\\client\\session_group.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "file src\\mcp\\client\\session_group.py exists under tools/"
      ]
    },
    {
      "name": "streamable_http",
      "description": "stream data over websocket. File `src\\mcp\\client\\streamable_http.py`.",
      "predicted_filename": "src\\mcp\\client\\streamable_http.py",
      "predicted_code_snippet": "\"\"\"\nStreamableHTTP Client Transport Module\n\nThis module implements the StreamableHTTP transport for MCP clients,\nproviding support for HTTP POST requests with optional SSE streaming responses\nand session management.\n\"\"\"\n\nimport logging\nfrom collections.abc import AsyncGenerator, Awaitable, Callable\nfrom contextlib import asynccontextmanager\nfrom dataclasses import dataclass\nfrom datetime import timedelta\n\nimport anyio\nimport httpx\nfrom anyio.abc import TaskGroup\nfrom anyio.streams.memory import MemoryObjectReceiveStream, MemoryObjectSendStream\nfrom httpx_sse import EventSource, ServerSentEvent, aconnect_sse\n\nfrom mcp.shared._httpx_utils import McpHttpClientFactory, create_mcp_http_client\nfrom mcp.shared.message import ClientMessageMetadata, SessionMessage\nfrom mcp.types import (\n    ErrorData,\n    InitializeResult,\n    JSONRPCError,\n    JSONRPCMessage,\n    JSONRPCNotification,\n    JSONRPCRequest,\n    JSONRPCResponse,",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file src\\mcp\\client\\streamable_http.py",
      "possible_syscalls": [],
      "confidence": 0.39,
      "evidence": [
        "file src\\mcp\\client\\streamable_http.py exists under tools/"
      ]
    },
    {
      "name": "websocket",
      "description": "stream data over websocket. File `src\\mcp\\client\\websocket.py`.",
      "predicted_filename": "src\\mcp\\client\\websocket.py",
      "predicted_code_snippet": "import json\nimport logging\nfrom collections.abc import AsyncGenerator\nfrom contextlib import asynccontextmanager\n\nimport anyio\nfrom anyio.streams.memory import MemoryObjectReceiveStream, MemoryObjectSendStream\nfrom pydantic import ValidationError\nfrom websockets.asyncio.client import connect as ws_connect\nfrom websockets.typing import Subprotocol\n\nimport mcp.types as types\nfrom mcp.shared.message import SessionMessage\n\nlogger = logging.getLogger(__name__)\n\n\n@asynccontextmanager\nasync def websocket_client(\n    url: str,\n) -> AsyncGenerator[\n    tuple[MemoryObjectReceiveStream[SessionMessage | Exception], MemoryObjectSendStream[SessionMessage]],\n    None,\n]:\n    \"\"\"\n    WebSocket client transport for MCP, symmetrical to the server version.\n\n    Connects to 'url' using the 'mcp' subprotocol, then yields:\n        (read_stream, write_stream)\n",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file src\\mcp\\client\\websocket.py",
      "possible_syscalls": [],
      "confidence": 0.36,
      "evidence": [
        "file src\\mcp\\client\\websocket.py exists under tools/"
      ]
    },
    {
      "name": "__init__",
      "description": "send an email notification. File `src\\mcp\\client\\__init__.py`.",
      "predicted_filename": "src\\mcp\\client\\__init__.py",
      "predicted_code_snippet": "",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file src\\mcp\\client\\__init__.py",
      "possible_syscalls": [],
      "confidence": 0.16,
      "evidence": [
        "file src\\mcp\\client\\__init__.py exists under tools/"
      ]
    },
    {
      "name": "exceptions",
      "description": "authenticate a user and return a token. File `src\\mcp\\client\\auth\\exceptions.py`.",
      "predicted_filename": "src\\mcp\\client\\auth\\exceptions.py",
      "predicted_code_snippet": "class OAuthFlowError(Exception):\n    \"\"\"Base exception for OAuth flow errors.\"\"\"\n\n\nclass OAuthTokenError(OAuthFlowError):\n    \"\"\"Raised when token operations fail.\"\"\"\n\n\nclass OAuthRegistrationError(OAuthFlowError):\n    \"\"\"Raised when client registration fails.\"\"\"",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file src\\mcp\\client\\auth\\exceptions.py",
      "possible_syscalls": [],
      "confidence": 0.26,
      "evidence": [
        "file src\\mcp\\client\\auth\\exceptions.py exists under tools/"
      ]
    },
    {
      "name": "oauth2",
      "description": "authenticate a user and return a token. File `src\\mcp\\client\\auth\\oauth2.py`.",
      "predicted_filename": "src\\mcp\\client\\auth\\oauth2.py",
      "predicted_code_snippet": "\"\"\"\nOAuth2 Authentication implementation for HTTPX.\n\nImplements authorization code flow with PKCE and automatic token refresh.\n\"\"\"\n\nimport base64\nimport hashlib\nimport logging\nimport secrets\nimport string\nimport time\nfrom collections.abc import AsyncGenerator, Awaitable, Callable\nfrom dataclasses import dataclass, field\nfrom typing import Any, Protocol\nfrom urllib.parse import urlencode, urljoin, urlparse\n\nimport anyio\nimport httpx\nfrom pydantic import BaseModel, Field, ValidationError\n\nfrom mcp.client.auth import OAuthFlowError, OAuthTokenError\nfrom mcp.client.auth.utils import (\n    build_oauth_authorization_server_metadata_discovery_urls,\n    build_protected_resource_metadata_discovery_urls,\n    create_client_registration_request,\n    create_oauth_metadata_request,\n    extract_field_from_www_auth,\n    extract_resource_metadata_from_www_auth,\n    extract_scope_from_www_auth,",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file src\\mcp\\client\\auth\\oauth2.py",
      "possible_syscalls": [
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.29,
      "evidence": [
        "file src\\mcp\\client\\auth\\oauth2.py exists under tools/"
      ]
    },
    {
      "name": "__init__",
      "description": "authenticate a user and return a token. File `src\\mcp\\client\\auth\\__init__.py`.",
      "predicted_filename": "src\\mcp\\client\\auth\\__init__.py",
      "predicted_code_snippet": "\"\"\"\nOAuth2 Authentication implementation for HTTPX.\n\nImplements authorization code flow with PKCE and automatic token refresh.\n\"\"\"\n\nfrom mcp.client.auth.exceptions import OAuthFlowError, OAuthRegistrationError, OAuthTokenError\nfrom mcp.client.auth.oauth2 import (\n    OAuthClientProvider,\n    PKCEParameters,\n    TokenStorage,\n)\n\n__all__ = [\n    \"OAuthClientProvider\",\n    \"OAuthFlowError\",\n    \"OAuthRegistrationError\",\n    \"OAuthTokenError\",\n    \"PKCEParameters\",\n    \"TokenStorage\",\n]",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file src\\mcp\\client\\auth\\__init__.py",
      "possible_syscalls": [],
      "confidence": 0.35,
      "evidence": [
        "file src\\mcp\\client\\auth\\__init__.py exists under tools/"
      ]
    },
    {
      "name": "client_credentials",
      "description": "authenticate a user and return a token. File `src\\mcp\\client\\auth\\extensions\\client_credentials.py`.",
      "predicted_filename": "src\\mcp\\client\\auth\\extensions\\client_credentials.py",
      "predicted_code_snippet": "import time\nfrom collections.abc import Awaitable, Callable\nfrom typing import Any\nfrom uuid import uuid4\n\nimport httpx\nimport jwt\nfrom pydantic import BaseModel, Field\n\nfrom mcp.client.auth import OAuthClientProvider, OAuthFlowError, OAuthTokenError, TokenStorage\nfrom mcp.shared.auth import OAuthClientMetadata\n\n\nclass JWTParameters(BaseModel):\n    \"\"\"JWT parameters.\"\"\"\n\n    assertion: str | None = Field(\n        default=None,\n        description=\"JWT assertion for JWT authentication. \"\n        \"Will be used instead of generating a new assertion if provided.\",\n    )\n\n    issuer: str | None = Field(default=None, description=\"Issuer for JWT assertions.\")\n    subject: str | None = Field(default=None, description=\"Subject identifier for JWT assertions.\")\n    audience: str | None = Field(default=None, description=\"Audience for JWT assertions.\")\n    claims: dict[str, Any] | None = Field(default=None, description=\"Additional claims for JWT assertions.\")\n    jwt_signing_algorithm: str | None = Field(default=\"RS256\", description=\"Algorithm for signing JWT assertions.\")\n    jwt_signing_key: str | None = Field(default=None, description=\"Private key for JWT signing.\")\n    jwt_lifetime_seconds: int = Field(default=300, description=\"Lifetime of generated JWT in seconds.\")\n",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file src\\mcp\\client\\auth\\extensions\\client_credentials.py",
      "possible_syscalls": [],
      "confidence": 0.27,
      "evidence": [
        "file src\\mcp\\client\\auth\\extensions\\client_credentials.py exists under tools/"
      ]
    },
    {
      "name": "__init__",
      "description": "send an email notification. File `src\\mcp\\client\\auth\\extensions\\__init__.py`.",
      "predicted_filename": "src\\mcp\\client\\auth\\extensions\\__init__.py",
      "predicted_code_snippet": "",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file src\\mcp\\client\\auth\\extensions\\__init__.py",
      "possible_syscalls": [],
      "confidence": 0.16,
      "evidence": [
        "file src\\mcp\\client\\auth\\extensions\\__init__.py exists under tools/"
      ]
    },
    {
      "name": "client_auth",
      "description": "authenticate a user and return a token. File `src\\mcp\\server\\auth\\middleware\\client_auth.py`.",
      "predicted_filename": "src\\mcp\\server\\auth\\middleware\\client_auth.py",
      "predicted_code_snippet": "import time\nfrom typing import Any\n\nfrom mcp.server.auth.provider import OAuthAuthorizationServerProvider\nfrom mcp.shared.auth import OAuthClientInformationFull\n\n\nclass AuthenticationError(Exception):\n    def __init__(self, message: str):\n        self.message = message  # pragma: no cover\n\n\nclass ClientAuthenticator:\n    \"\"\"\n    ClientAuthenticator is a callable which validates requests from a client\n    application, used to verify /token calls.\n    If, during registration, the client requested to be issued a secret, the\n    authenticator asserts that /token calls must be authenticated with\n    that same token.\n    NOTE: clients can opt for no authentication during registration, in which case this\n    logic is skipped.\n    \"\"\"\n\n    def __init__(self, provider: OAuthAuthorizationServerProvider[Any, Any, Any]):\n        \"\"\"\n        Initialize the dependency.\n\n        Args:\n            provider: Provider to look up client information\n        \"\"\"",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file src\\mcp\\server\\auth\\middleware\\client_auth.py",
      "possible_syscalls": [],
      "confidence": 0.32,
      "evidence": [
        "file src\\mcp\\server\\auth\\middleware\\client_auth.py exists under tools/"
      ]
    },
    {
      "name": "__init__",
      "description": "send an email notification. File `tests\\cli\\__init__.py`.",
      "predicted_filename": "tests\\cli\\__init__.py",
      "predicted_code_snippet": "",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file tests\\cli\\__init__.py",
      "possible_syscalls": [],
      "confidence": 0.16,
      "evidence": [
        "file tests\\cli\\__init__.py exists under tools/"
      ]
    },
    {
      "name": "test_list_methods_cursor",
      "description": "stream data over websocket. File `tests\\client\\test_list_methods_cursor.py`.",
      "predicted_filename": "tests\\client\\test_list_methods_cursor.py",
      "predicted_code_snippet": "from collections.abc import Callable\n\nimport pytest\n\nimport mcp.types as types\nfrom mcp.server import Server\nfrom mcp.server.fastmcp import FastMCP\nfrom mcp.shared.memory import create_connected_server_and_client_session as create_session\nfrom mcp.types import ListToolsRequest, ListToolsResult\n\nfrom .conftest import StreamSpyCollection\n\npytestmark = pytest.mark.anyio\n\n\n@pytest.fixture\nasync def full_featured_server():\n    \"\"\"Create a server with tools, resources, prompts, and templates.\"\"\"\n    server = FastMCP(\"test\")\n\n    @server.tool(name=\"test_tool_1\")\n    async def test_tool_1() -> str:  # pragma: no cover\n        \"\"\"First test tool\"\"\"\n        return \"Result 1\"\n\n    @server.tool(name=\"test_tool_2\")\n    async def test_tool_2() -> str:  # pragma: no cover\n        \"\"\"Second test tool\"\"\"\n        return \"Result 2\"\n",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file tests\\client\\test_list_methods_cursor.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "file tests\\client\\test_list_methods_cursor.py exists under tools/"
      ]
    },
    {
      "name": "test_list_roots_callback",
      "description": "write data to a file. File `tests\\client\\test_list_roots_callback.py`.",
      "predicted_filename": "tests\\client\\test_list_roots_callback.py",
      "predicted_code_snippet": "import pytest\nfrom pydantic import FileUrl\n\nfrom mcp.client.session import ClientSession\nfrom mcp.server.fastmcp.server import Context\nfrom mcp.server.session import ServerSession\nfrom mcp.shared.context import RequestContext\nfrom mcp.shared.memory import (\n    create_connected_server_and_client_session as create_session,\n)\nfrom mcp.types import ListRootsResult, Root, TextContent\n\n\n@pytest.mark.anyio\nasync def test_list_roots_callback():\n    from mcp.server.fastmcp import FastMCP\n\n    server = FastMCP(\"test\")\n\n    callback_return = ListRootsResult(\n        roots=[\n            Root(\n                uri=FileUrl(\"file://users/fake/test\"),\n                name=\"Test Root 1\",\n            ),\n            Root(\n                uri=FileUrl(\"file://users/fake/test/2\"),\n                name=\"Test Root 2\",\n            ),\n        ]",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file tests\\client\\test_list_roots_callback.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "file tests\\client\\test_list_roots_callback.py exists under tools/"
      ]
    },
    {
      "name": "test_logging_callback",
      "description": "stream data over websocket. File `tests\\client\\test_logging_callback.py`.",
      "predicted_filename": "tests\\client\\test_logging_callback.py",
      "predicted_code_snippet": "from typing import Literal\n\nimport pytest\n\nimport mcp.types as types\nfrom mcp.shared.memory import (\n    create_connected_server_and_client_session as create_session,\n)\nfrom mcp.shared.session import RequestResponder\nfrom mcp.types import (\n    LoggingMessageNotificationParams,\n    TextContent,\n)\n\n\nclass LoggingCollector:\n    def __init__(self):\n        self.log_messages: list[LoggingMessageNotificationParams] = []\n\n    async def __call__(self, params: LoggingMessageNotificationParams) -> None:\n        self.log_messages.append(params)\n\n\n@pytest.mark.anyio\nasync def test_logging_callback():\n    from mcp.server.fastmcp import FastMCP\n\n    server = FastMCP(\"test\")\n    logging_collector = LoggingCollector()\n",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file tests\\client\\test_logging_callback.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "file tests\\client\\test_logging_callback.py exists under tools/"
      ]
    },
    {
      "name": "test_resource_cleanup",
      "description": "stream data over websocket. File `tests\\client\\test_resource_cleanup.py`.",
      "predicted_filename": "tests\\client\\test_resource_cleanup.py",
      "predicted_code_snippet": "from typing import Any\nfrom unittest.mock import patch\n\nimport anyio\nimport pytest\n\nfrom mcp.shared.message import SessionMessage\nfrom mcp.shared.session import BaseSession, RequestId, SendResultT\nfrom mcp.types import ClientNotification, ClientRequest, ClientResult, EmptyResult, ErrorData, PingRequest\n\n\n@pytest.mark.anyio\nasync def test_send_request_stream_cleanup():\n    \"\"\"\n    Test that send_request properly cleans up streams when an exception occurs.\n\n    This test mocks out most of the session functionality to focus on stream cleanup.\n    \"\"\"\n\n    # Create a mock session with the minimal required functionality\n    class TestSession(BaseSession[ClientRequest, ClientNotification, ClientResult, Any, Any]):\n        async def _send_response(\n            self, request_id: RequestId, response: SendResultT | ErrorData\n        ) -> None:  # pragma: no cover\n            pass\n\n    # Create streams\n    write_stream_send, write_stream_receive = anyio.create_memory_object_stream[SessionMessage](1)\n    read_stream_send, read_stream_receive = anyio.create_memory_object_stream[SessionMessage](1)\n",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file tests\\client\\test_resource_cleanup.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "file tests\\client\\test_resource_cleanup.py exists under tools/"
      ]
    },
    {
      "name": "test_sampling_callback",
      "description": "stream data over websocket. File `tests\\client\\test_sampling_callback.py`.",
      "predicted_filename": "tests\\client\\test_sampling_callback.py",
      "predicted_code_snippet": "import pytest\n\nfrom mcp.client.session import ClientSession\nfrom mcp.shared.context import RequestContext\nfrom mcp.shared.memory import (\n    create_connected_server_and_client_session as create_session,\n)\nfrom mcp.types import (\n    CreateMessageRequestParams,\n    CreateMessageResult,\n    SamplingMessage,\n    TextContent,\n)\n\n\n@pytest.mark.anyio\nasync def test_sampling_callback():\n    from mcp.server.fastmcp import FastMCP\n\n    server = FastMCP(\"test\")\n\n    callback_return = CreateMessageResult(\n        role=\"assistant\",\n        content=TextContent(type=\"text\", text=\"This is a response from the sampling callback\"),\n        model=\"test-model\",\n        stopReason=\"endTurn\",\n    )\n\n    async def sampling_callback(\n        context: RequestContext[ClientSession, None],",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file tests\\client\\test_sampling_callback.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "file tests\\client\\test_sampling_callback.py exists under tools/"
      ]
    },
    {
      "name": "test_scope_bug_1630",
      "description": "authenticate a user and return a token. File `tests\\client\\test_scope_bug_1630.py`.",
      "predicted_filename": "tests\\client\\test_scope_bug_1630.py",
      "predicted_code_snippet": "\"\"\"\nRegression test for issue #1630: OAuth2 scope incorrectly set to resource_metadata URL.\n\nThis test verifies that when a 401 response contains both resource_metadata and scope\nin the WWW-Authenticate header, the actual scope is used (not the resource_metadata URL).\n\"\"\"\n\nfrom unittest import mock\n\nimport httpx\nimport pytest\nfrom pydantic import AnyUrl\n\nfrom mcp.client.auth import OAuthClientProvider\nfrom mcp.shared.auth import OAuthClientInformationFull, OAuthClientMetadata, OAuthToken\n\n\nclass MockTokenStorage:\n    \"\"\"Mock token storage for testing.\"\"\"\n\n    def __init__(self) -> None:\n        self._tokens: OAuthToken | None = None\n        self._client_info: OAuthClientInformationFull | None = None\n\n    async def get_tokens(self) -> OAuthToken | None:\n        return self._tokens  # pragma: no cover\n\n    async def set_tokens(self, tokens: OAuthToken) -> None:\n        self._tokens = tokens\n",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file tests\\client\\test_scope_bug_1630.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "file tests\\client\\test_scope_bug_1630.py exists under tools/"
      ]
    },
    {
      "name": "test_session",
      "description": "make an HTTP request to an external API. File `tests\\client\\test_session.py`.",
      "predicted_filename": "tests\\client\\test_session.py",
      "predicted_code_snippet": "from typing import Any\n\nimport anyio\nimport pytest\n\nimport mcp.types as types\nfrom mcp.client.session import DEFAULT_CLIENT_INFO, ClientSession\nfrom mcp.shared.context import RequestContext\nfrom mcp.shared.message import SessionMessage\nfrom mcp.shared.session import RequestResponder\nfrom mcp.shared.version import SUPPORTED_PROTOCOL_VERSIONS\nfrom mcp.types import (\n    LATEST_PROTOCOL_VERSION,\n    CallToolResult,\n    ClientNotification,\n    ClientRequest,\n    Implementation,\n    InitializedNotification,\n    InitializeRequest,\n    InitializeResult,\n    JSONRPCMessage,\n    JSONRPCNotification,\n    JSONRPCRequest,\n    JSONRPCResponse,\n    ServerCapabilities,\n    ServerResult,\n    TextContent,\n)\n\n",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file tests\\client\\test_session.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "file tests\\client\\test_session.py exists under tools/"
      ]
    },
    {
      "name": "test_stdio",
      "description": "execute a shell command. File `tests\\client\\test_stdio.py`.",
      "predicted_filename": "tests\\client\\test_stdio.py",
      "predicted_code_snippet": "import errno\nimport os\nimport shutil\nimport sys\nimport tempfile\nimport textwrap\nimport time\n\nimport anyio\nimport pytest\n\nfrom mcp.client.session import ClientSession\nfrom mcp.client.stdio import StdioServerParameters, _create_platform_compatible_process, stdio_client\nfrom mcp.shared.exceptions import McpError\nfrom mcp.shared.message import SessionMessage\nfrom mcp.types import CONNECTION_CLOSED, JSONRPCMessage, JSONRPCRequest, JSONRPCResponse\n\nfrom ..shared.test_win32_utils import escape_path_for_python\n\n# Timeout for cleanup of processes that ignore SIGTERM\n# This timeout ensures the test fails quickly if the cleanup logic doesn't have\n# proper fallback mechanisms (SIGINT/SIGKILL) for processes that ignore SIGTERM\nSIGTERM_IGNORING_PROCESS_TIMEOUT = 5.0\n\ntee = shutil.which(\"tee\")\n\n\n@pytest.mark.anyio\n@pytest.mark.skipif(tee is None, reason=\"could not find tee command\")\nasync def test_stdio_context_manager_exiting():",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file tests\\client\\test_stdio.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "file tests\\client\\test_stdio.py exists under tools/"
      ]
    },
    {
      "name": "__init__",
      "description": "send an email notification. File `tests\\client\\__init__.py`.",
      "predicted_filename": "tests\\client\\__init__.py",
      "predicted_code_snippet": "",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file tests\\client\\__init__.py",
      "possible_syscalls": [],
      "confidence": 0.16,
      "evidence": [
        "file tests\\client\\__init__.py exists under tools/"
      ]
    }
  ],
  "run_template": {
    "cmd": "uvicorn main:app --host 0.0.0.0 --port 8000",
    "confidence": 0.85,
    "evidence": [
      "uvicorn reference"
    ]
  },
  "notes": [
    "Prototype analyzer using heuristics."
  ]
}