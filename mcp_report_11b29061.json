{
  "repo": "https://github.com/pallets/flask.git",
  "analysis_time": "2025-11-19T20:04:29.410684",
  "transport": {
    "type": "http",
    "confidence": 1.0,
    "evidence": [
      "HTTP pattern in CHANGES.rst",
      "HTTP pattern in LICENSE.txt",
      "HTTP pattern in pyproject.toml",
      "HTTP pattern in README.md",
      "HTTP pattern in uv.lock",
      "WS pattern in uv.lock",
      "HTTP pattern in .devcontainer\\devcontainer.json",
      "HTTP pattern in .git\\config",
      "HTTP pattern in .git\\index",
      "HTTP pattern in .git\\hooks\\fsmonitor-watchman.sample",
      "HTTP pattern in .git\\logs\\HEAD",
      "HTTP pattern in .git\\logs\\refs\\heads\\main",
      "HTTP pattern in .git\\logs\\refs\\remotes\\origin\\HEAD",
      "HTTP pattern in .git\\objects\\pack\\pack-d4f8df72fda63ed941cdcfea87cf40b37451b74f.pack",
      "HTTP pattern in .github\\ISSUE_TEMPLATE\\bug-report.md",
      "HTTP pattern in .github\\ISSUE_TEMPLATE\\config.yml",
      "HTTP pattern in .github\\ISSUE_TEMPLATE\\feature-request.md",
      "HTTP pattern in .github\\workflows\\publish.yaml",
      "HTTP pattern in docs\\api.rst",
      "HTTP pattern in docs\\appcontext.rst",
      "HTTP pattern in docs\\async-await.rst",
      "WS pattern in docs\\async-await.rst",
      "HTTP pattern in docs\\blueprints.rst",
      "HTTP pattern in docs\\cli.rst",
      "HTTP pattern in docs\\conf.py",
      "HTTP pattern in docs\\config.rst",
      "HTTP pattern in docs\\debugging.rst",
      "HTTP pattern in docs\\design.rst",
      "HTTP pattern in docs\\errorhandling.rst",
      "HTTP pattern in docs\\extensiondev.rst",
      "HTTP pattern in docs\\extensions.rst",
      "HTTP pattern in docs\\index.rst",
      "HTTP pattern in docs\\installation.rst",
      "HTTP pattern in docs\\lifecycle.rst",
      "HTTP pattern in docs\\logging.rst",
      "HTTP pattern in docs\\quickstart.rst",
      "HTTP pattern in docs\\server.rst",
      "HTTP pattern in docs\\shell.rst",
      "HTTP pattern in docs\\signals.rst",
      "HTTP pattern in docs\\templating.rst",
      "HTTP pattern in docs\\testing.rst",
      "HTTP pattern in docs\\views.rst",
      "HTTP pattern in docs\\web-security.rst",
      "HTTP pattern in docs\\deploying\\asgi.rst",
      "HTTP pattern in docs\\deploying\\gunicorn.rst",
      "HTTP pattern in docs\\deploying\\index.rst",
      "HTTP pattern in docs\\deploying\\mod_wsgi.rst",
      "HTTP pattern in docs\\deploying\\proxy_fix.rst",
      "HTTP pattern in docs\\deploying\\waitress.rst",
      "HTTP pattern in docs\\patterns\\appdispatch.rst",
      "HTTP pattern in docs\\patterns\\appfactories.rst",
      "HTTP pattern in docs\\patterns\\caching.rst",
      "HTTP pattern in docs\\patterns\\celery.rst",
      "HTTP pattern in docs\\patterns\\deferredcallbacks.rst",
      "HTTP pattern in docs\\patterns\\favicon.rst",
      "HTTP pattern in docs\\patterns\\fileuploads.rst",
      "HTTP pattern in docs\\patterns\\flashing.rst",
      "HTTP pattern in docs\\patterns\\index.rst",
      "HTTP pattern in docs\\patterns\\javascript.rst",
      "HTTP pattern in docs\\patterns\\lazyloading.rst",
      "HTTP pattern in docs\\patterns\\methodoverrides.rst",
      "HTTP pattern in docs\\patterns\\mongoengine.rst",
      "HTTP pattern in docs\\patterns\\packages.rst",
      "HTTP pattern in docs\\patterns\\singlepageapplications.rst",
      "HTTP pattern in docs\\patterns\\sqlalchemy.rst",
      "HTTP pattern in docs\\patterns\\sqlite3.rst",
      "HTTP pattern in docs\\patterns\\streaming.rst",
      "HTTP pattern in docs\\patterns\\subclassing.rst",
      "HTTP pattern in docs\\patterns\\urlprocessors.rst",
      "HTTP pattern in docs\\patterns\\viewdecorators.rst",
      "HTTP pattern in docs\\patterns\\wtforms.rst",
      "HTTP pattern in docs\\tutorial\\blog.rst",
      "HTTP pattern in docs\\tutorial\\database.rst",
      "HTTP pattern in docs\\tutorial\\deploy.rst",
      "HTTP pattern in docs\\tutorial\\factory.rst",
      "HTTP pattern in docs\\tutorial\\index.rst",
      "HTTP pattern in docs\\tutorial\\install.rst",
      "HTTP pattern in docs\\tutorial\\layout.rst",
      "HTTP pattern in docs\\tutorial\\next.rst",
      "HTTP pattern in docs\\tutorial\\static.rst",
      "HTTP pattern in docs\\tutorial\\templates.rst",
      "HTTP pattern in docs\\tutorial\\tests.rst",
      "HTTP pattern in docs\\tutorial\\views.rst",
      "HTTP pattern in examples\\celery\\make_celery.py",
      "HTTP pattern in examples\\celery\\pyproject.toml",
      "HTTP pattern in examples\\celery\\README.md",
      "HTTP pattern in examples\\celery\\requirements.txt",
      "HTTP pattern in examples\\celery\\src\\task_app\\views.py",
      "HTTP pattern in examples\\celery\\src\\task_app\\__init__.py",
      "HTTP pattern in examples\\javascript\\LICENSE.txt",
      "HTTP pattern in examples\\javascript\\pyproject.toml",
      "HTTP pattern in examples\\javascript\\README.rst",
      "HTTP pattern in examples\\javascript\\js_example\\views.py",
      "HTTP pattern in examples\\javascript\\js_example\\__init__.py",
      "HTTP pattern in examples\\javascript\\tests\\test_js_example.py",
      "HTTP pattern in examples\\tutorial\\LICENSE.txt",
      "HTTP pattern in examples\\tutorial\\pyproject.toml",
      "HTTP pattern in examples\\tutorial\\README.rst",
      "HTTP pattern in examples\\tutorial\\flaskr\\auth.py",
      "HTTP pattern in examples\\tutorial\\flaskr\\blog.py",
      "HTTP pattern in examples\\tutorial\\flaskr\\db.py",
      "HTTP pattern in examples\\tutorial\\flaskr\\__init__.py",
      "HTTP pattern in examples\\tutorial\\flaskr\\templates\\base.html",
      "HTTP pattern in examples\\tutorial\\tests\\conftest.py",
      "HTTP pattern in examples\\tutorial\\tests\\test_auth.py",
      "HTTP pattern in examples\\tutorial\\tests\\test_blog.py",
      "HTTP pattern in examples\\tutorial\\tests\\test_db.py",
      "HTTP pattern in examples\\tutorial\\tests\\test_factory.py",
      "HTTP pattern in src\\flask\\app.py",
      "HTTP pattern in src\\flask\\blueprints.py",
      "HTTP pattern in src\\flask\\cli.py",
      "HTTP pattern in src\\flask\\config.py",
      "HTTP pattern in src\\flask\\ctx.py",
      "HTTP pattern in src\\flask\\debughelpers.py",
      "HTTP pattern in src\\flask\\globals.py",
      "HTTP pattern in src\\flask\\helpers.py",
      "HTTP pattern in src\\flask\\logging.py",
      "HTTP pattern in src\\flask\\sessions.py",
      "HTTP pattern in src\\flask\\signals.py",
      "HTTP pattern in src\\flask\\templating.py",
      "HTTP pattern in src\\flask\\testing.py",
      "HTTP pattern in src\\flask\\typing.py",
      "HTTP pattern in src\\flask\\views.py",
      "HTTP pattern in src\\flask\\wrappers.py",
      "HTTP pattern in src\\flask\\__init__.py",
      "HTTP pattern in src\\flask\\json\\provider.py",
      "HTTP pattern in src\\flask\\json\\tag.py",
      "HTTP pattern in src\\flask\\json\\__init__.py",
      "HTTP pattern in src\\flask\\sansio\\app.py",
      "HTTP pattern in src\\flask\\sansio\\blueprints.py",
      "HTTP pattern in src\\flask\\sansio\\README.md",
      "HTTP pattern in src\\flask\\sansio\\scaffold.py",
      "HTTP pattern in tests\\conftest.py",
      "HTTP pattern in tests\\test_appctx.py",
      "HTTP pattern in tests\\test_async.py",
      "HTTP pattern in tests\\test_basic.py",
      "HTTP pattern in tests\\test_blueprints.py",
      "HTTP pattern in tests\\test_cli.py",
      "HTTP pattern in tests\\test_config.py",
      "HTTP pattern in tests\\test_converters.py",
      "HTTP pattern in tests\\test_helpers.py",
      "HTTP pattern in tests\\test_instance_config.py",
      "HTTP pattern in tests\\test_json.py",
      "HTTP pattern in tests\\test_json_tag.py",
      "HTTP pattern in tests\\test_logging.py",
      "HTTP pattern in tests\\test_regression.py",
      "HTTP pattern in tests\\test_reqctx.py",
      "HTTP pattern in tests\\test_request.py",
      "HTTP pattern in tests\\test_session_interface.py",
      "HTTP pattern in tests\\test_signals.py",
      "HTTP pattern in tests\\test_subclassing.py",
      "HTTP pattern in tests\\test_templating.py",
      "HTTP pattern in tests\\test_testing.py",
      "HTTP pattern in tests\\test_user_error_handler.py",
      "HTTP pattern in tests\\test_views.py",
      "HTTP pattern in tests\\test_apps\\.flaskenv",
      "HTTP pattern in tests\\test_apps\\blueprintapp\\__init__.py",
      "HTTP pattern in tests\\test_apps\\blueprintapp\\apps\\admin\\__init__.py",
      "HTTP pattern in tests\\test_apps\\blueprintapp\\apps\\frontend\\__init__.py",
      "HTTP pattern in tests\\test_apps\\cliapp\\app.py",
      "HTTP pattern in tests\\test_apps\\cliapp\\factory.py",
      "HTTP pattern in tests\\test_apps\\cliapp\\importerrorapp.py",
      "HTTP pattern in tests\\test_apps\\cliapp\\multiapp.py",
      "HTTP pattern in tests\\test_apps\\cliapp\\inner1\\__init__.py",
      "HTTP pattern in tests\\test_apps\\cliapp\\inner1\\inner2\\flask.py",
      "HTTP pattern in tests\\test_apps\\helloworld\\hello.py",
      "HTTP pattern in tests\\test_apps\\subdomaintestmodule\\__init__.py",
      "HTTP pattern in tests\\type_check\\typing_app_decorators.py",
      "HTTP pattern in tests\\type_check\\typing_error_handler.py",
      "HTTP pattern in tests\\type_check\\typing_route.py"
    ]
  },
  "tools": [
    {
      "name": "github_link",
      "description": "write data to a file. Function `github_link`.",
      "predicted_filename": "docs\\conf.py",
      "predicted_code_snippet": "def github_link(name, rawtext, text, lineno, inliner, options=None, content=None):\n    app = inliner.document.settings.env.app\n    release = app.config.release\n    base_url = \"https://github.com/pallets/flask/tree/\"\n\n    if text.endswith(\">\"):\n        words, text = text[:-1].rsplit(\"<\", 1)\n        words = words.strip()\n    else:\n        words = None\n\n    if packaging.version.parse(release).is_devrelease:\n        url = f\"{base_url}main/{text}\"\n    else:\n        url = f\"{base_url}{release}/{text}\"\n\n    if words is None:\n        words = url\n\n    from docutils.nodes import reference\n    from docutils.parsers.rst.roles import set_classes\n\n    options = options or {}\n    set_classes(options)\n    node = reference(rawtext, words, refuri=url, **options)\n    return [node], []",
      "input_schema": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "required": true
          },
          "rawtext": {
            "type": "string",
            "required": true
          },
          "text": {
            "type": "string",
            "required": true
          },
          "lineno": {
            "type": "string",
            "required": true
          },
          "inliner": {
            "type": "string",
            "required": true
          },
          "options": {
            "type": "string",
            "required": false
          },
          "content": {
            "type": "string",
            "required": false
          }
        },
        "required": [
          "name",
          "rawtext",
          "text",
          "lineno",
          "inliner"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "name": "string",
          "rawtext": "string",
          "text": "string",
          "lineno": "string",
          "inliner": "string",
          "options": "string",
          "content": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `github_link` in docs\\conf.py",
      "possible_syscalls": [],
      "confidence": 0.16,
      "evidence": [
        "function github_link in docs\\conf.py",
        "matched template: write data to a file (sim=0.08)"
      ]
    },
    {
      "name": "setup",
      "description": "make an HTTP request to an external API. Function `setup`.",
      "predicted_filename": "docs\\conf.py",
      "predicted_code_snippet": "def setup(app):\n    app.add_role(\"gh\", github_link)",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `setup` in docs\\conf.py",
      "possible_syscalls": [],
      "confidence": 0.16,
      "evidence": [
        "function setup in docs\\conf.py",
        "matched template: make an HTTP request to an external API (sim=0.08)"
      ]
    },
    {
      "name": "add",
      "description": "cache results to disk or memory. Function `add`.",
      "predicted_filename": "examples\\celery\\src\\task_app\\tasks.py",
      "predicted_code_snippet": "def add(a: int, b: int) -> int:\n    return a + b",
      "input_schema": {
        "type": "object",
        "properties": {
          "a": {
            "type": "integer",
            "required": true
          },
          "b": {
            "type": "integer",
            "required": true
          }
        },
        "required": [
          "a",
          "b"
        ]
      },
      "output_schema": {
        "type": "integer"
      },
      "payload_shape": {
        "request": {
          "a": "integer",
          "b": "integer"
        },
        "response": {
          "type": "integer"
        }
      },
      "explanation": "Detected Python function `add` in examples\\celery\\src\\task_app\\tasks.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function add in examples\\celery\\src\\task_app\\tasks.py",
        "matched template: cache results to disk or memory (sim=0.17)"
      ]
    },
    {
      "name": "block",
      "description": "cache results to disk or memory. Function `block`.",
      "predicted_filename": "examples\\celery\\src\\task_app\\tasks.py",
      "predicted_code_snippet": "def block() -> None:\n    time.sleep(5)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `block` in examples\\celery\\src\\task_app\\tasks.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function block in examples\\celery\\src\\task_app\\tasks.py",
        "matched template: cache results to disk or memory (sim=0.17)"
      ]
    },
    {
      "name": "process",
      "description": "cache results to disk or memory. Function `process`.",
      "predicted_filename": "examples\\celery\\src\\task_app\\tasks.py",
      "predicted_code_snippet": "def process(self: Task, total: int) -> object:\n    for i in range(total):\n        self.update_state(state=\"PROGRESS\", meta={\"current\": i + 1, \"total\": total})\n        time.sleep(1)\n\n    return {\"current\": total, \"total\": total}",
      "input_schema": {
        "type": "object",
        "properties": {
          "total": {
            "type": "integer",
            "required": true
          }
        },
        "required": [
          "total"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "total": "integer"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `process` in examples\\celery\\src\\task_app\\tasks.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function process in examples\\celery\\src\\task_app\\tasks.py",
        "matched template: cache results to disk or memory (sim=0.17)"
      ]
    },
    {
      "name": "result",
      "description": "perform database query and return records. Function `result`.",
      "predicted_filename": "examples\\celery\\src\\task_app\\views.py",
      "predicted_code_snippet": "def result(id: str) -> dict[str, object]:\n    result = AsyncResult(id)\n    ready = result.ready()\n    return {\n        \"ready\": ready,\n        \"successful\": result.successful() if ready else None,\n        \"value\": result.get() if ready else result.result,\n    }",
      "input_schema": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "id"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "id": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `result` in examples\\celery\\src\\task_app\\views.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function result in examples\\celery\\src\\task_app\\views.py",
        "matched template: perform database query and return records (sim=0.23)"
      ]
    },
    {
      "name": "add",
      "description": "make an HTTP request to an external API. Function `add`.",
      "predicted_filename": "examples\\celery\\src\\task_app\\views.py",
      "predicted_code_snippet": "def add() -> dict[str, object]:\n    a = request.form.get(\"a\", type=int)\n    b = request.form.get(\"b\", type=int)\n    result = tasks.add.delay(a, b)\n    return {\"result_id\": result.id}",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `add` in examples\\celery\\src\\task_app\\views.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function add in examples\\celery\\src\\task_app\\views.py",
        "matched template: make an HTTP request to an external API (sim=0.22)"
      ]
    },
    {
      "name": "block",
      "description": "make an HTTP request to an external API. Function `block`.",
      "predicted_filename": "examples\\celery\\src\\task_app\\views.py",
      "predicted_code_snippet": "def block() -> dict[str, object]:\n    result = tasks.block.delay()\n    return {\"result_id\": result.id}",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `block` in examples\\celery\\src\\task_app\\views.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function block in examples\\celery\\src\\task_app\\views.py",
        "matched template: make an HTTP request to an external API (sim=0.21)"
      ]
    },
    {
      "name": "process",
      "description": "make an HTTP request to an external API. Function `process`.",
      "predicted_filename": "examples\\celery\\src\\task_app\\views.py",
      "predicted_code_snippet": "def process() -> dict[str, object]:\n    result = tasks.process.delay(total=request.form.get(\"total\", type=int))\n    return {\"result_id\": result.id}",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `process` in examples\\celery\\src\\task_app\\views.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function process in examples\\celery\\src\\task_app\\views.py",
        "matched template: make an HTTP request to an external API (sim=0.21)"
      ]
    },
    {
      "name": "create_app",
      "description": "make an HTTP request to an external API. Function `create_app`.",
      "predicted_filename": "examples\\celery\\src\\task_app\\__init__.py",
      "predicted_code_snippet": "def create_app() -> Flask:\n    app = Flask(__name__)\n    app.config.from_mapping(\n        CELERY=dict(\n            broker_url=\"redis://localhost\",\n            result_backend=\"redis://localhost\",\n            task_ignore_result=True,\n        ),\n    )\n    app.config.from_prefixed_env()\n    celery_init_app(app)\n\n    @app.route(\"/\")\n    def index() -> str:\n        return render_template(\"index.html\")\n\n    from . import views\n\n    app.register_blueprint(views.bp)\n    return app",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `create_app` in examples\\celery\\src\\task_app\\__init__.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function create_app in examples\\celery\\src\\task_app\\__init__.py",
        "matched template: make an HTTP request to an external API (sim=0.19)"
      ]
    },
    {
      "name": "celery_init_app",
      "description": "send an email notification. Function `celery_init_app`.",
      "predicted_filename": "examples\\celery\\src\\task_app\\__init__.py",
      "predicted_code_snippet": "def celery_init_app(app: Flask) -> Celery:\n    class FlaskTask(Task):\n        def __call__(self, *args: object, **kwargs: object) -> object:\n            with app.app_context():\n                return self.run(*args, **kwargs)\n\n    celery_app = Celery(app.name, task_cls=FlaskTask)\n    celery_app.config_from_object(app.config[\"CELERY\"])\n    celery_app.set_default()\n    app.extensions[\"celery\"] = celery_app\n    return celery_app",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `celery_init_app` in examples\\celery\\src\\task_app\\__init__.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function celery_init_app in examples\\celery\\src\\task_app\\__init__.py",
        "matched template: send an email notification (sim=0.12)"
      ]
    },
    {
      "name": "index",
      "description": "handle a HTTP route request and return response. Function `index`.",
      "predicted_filename": "examples\\javascript\\js_example\\views.py",
      "predicted_code_snippet": "def index(js):\n    return render_template(f\"{js}.html\", js=js)",
      "input_schema": {
        "type": "object",
        "properties": {
          "js": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "js"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "js": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `index` in examples\\javascript\\js_example\\views.py",
      "possible_syscalls": [],
      "confidence": 0.24,
      "evidence": [
        "function index in examples\\javascript\\js_example\\views.py",
        "matched template: handle a HTTP route request and return response (sim=0.28)"
      ]
    },
    {
      "name": "add",
      "description": "handle a HTTP route request and return response. Function `add`.",
      "predicted_filename": "examples\\javascript\\js_example\\views.py",
      "predicted_code_snippet": "def add():\n    a = request.form.get(\"a\", 0, type=float)\n    b = request.form.get(\"b\", 0, type=float)\n    return jsonify(result=a + b)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `add` in examples\\javascript\\js_example\\views.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function add in examples\\javascript\\js_example\\views.py",
        "matched template: handle a HTTP route request and return response (sim=0.27)"
      ]
    },
    {
      "name": "fixture_app",
      "description": "stream data over websocket. Function `fixture_app`.",
      "predicted_filename": "examples\\javascript\\tests\\conftest.py",
      "predicted_code_snippet": "def fixture_app():\n    app.testing = True\n    yield app\n    app.testing = False",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `fixture_app` in examples\\javascript\\tests\\conftest.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function fixture_app in examples\\javascript\\tests\\conftest.py",
        "matched template: stream data over websocket (sim=0.12)"
      ]
    },
    {
      "name": "client",
      "description": "stream data over websocket. Function `client`.",
      "predicted_filename": "examples\\javascript\\tests\\conftest.py",
      "predicted_code_snippet": "def client(app):\n    return app.test_client()",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `client` in examples\\javascript\\tests\\conftest.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function client in examples\\javascript\\tests\\conftest.py",
        "matched template: stream data over websocket (sim=0.15)"
      ]
    },
    {
      "name": "test_index",
      "description": "handle a HTTP route request and return response. Function `test_index`.",
      "predicted_filename": "examples\\javascript\\tests\\test_js_example.py",
      "predicted_code_snippet": "def test_index(app, client, path, template_name):\n    def check(sender, template, context):\n        assert template.name == template_name\n\n    with template_rendered.connected_to(check, app):\n        client.get(path)",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          },
          "path": {
            "type": "string",
            "required": true
          },
          "template_name": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client",
          "path",
          "template_name"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string",
          "path": "string",
          "template_name": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_index` in examples\\javascript\\tests\\test_js_example.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function test_index in examples\\javascript\\tests\\test_js_example.py",
        "matched template: handle a HTTP route request and return response (sim=0.20)"
      ]
    },
    {
      "name": "test_add",
      "description": "handle a HTTP route request and return response. Function `test_add`.",
      "predicted_filename": "examples\\javascript\\tests\\test_js_example.py",
      "predicted_code_snippet": "def test_add(client, a, b, result):\n    response = client.post(\"/add\", data={\"a\": a, \"b\": b})\n    assert response.get_json()[\"result\"] == result",
      "input_schema": {
        "type": "object",
        "properties": {
          "client": {
            "type": "string",
            "required": true
          },
          "a": {
            "type": "string",
            "required": true
          },
          "b": {
            "type": "string",
            "required": true
          },
          "result": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "client",
          "a",
          "b",
          "result"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "client": "string",
          "a": "string",
          "b": "string",
          "result": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_add` in examples\\javascript\\tests\\test_js_example.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function test_add in examples\\javascript\\tests\\test_js_example.py",
        "matched template: handle a HTTP route request and return response (sim=0.26)"
      ]
    },
    {
      "name": "login_required",
      "description": "authenticate a user and return a token. Function `login_required`.",
      "predicted_filename": "examples\\tutorial\\flaskr\\auth.py",
      "predicted_code_snippet": "def login_required(view):\n    \"\"\"View decorator that redirects anonymous users to the login page.\"\"\"\n\n    @functools.wraps(view)\n    def wrapped_view(**kwargs):\n        if g.user is None:\n            return redirect(url_for(\"auth.login\"))\n\n        return view(**kwargs)\n\n    return wrapped_view",
      "input_schema": {
        "type": "object",
        "properties": {
          "view": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "view"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "view": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `login_required` in examples\\tutorial\\flaskr\\auth.py",
      "possible_syscalls": [],
      "confidence": 0.26,
      "evidence": [
        "function login_required in examples\\tutorial\\flaskr\\auth.py",
        "matched template: authenticate a user and return a token (sim=0.33)"
      ]
    },
    {
      "name": "load_logged_in_user",
      "description": "authenticate a user and return a token. Function `load_logged_in_user`.",
      "predicted_filename": "examples\\tutorial\\flaskr\\auth.py",
      "predicted_code_snippet": "def load_logged_in_user():\n    \"\"\"If a user id is stored in the session, load the user object from\n    the database into ``g.user``.\"\"\"\n    user_id = session.get(\"user_id\")\n\n    if user_id is None:\n        g.user = None\n    else:\n        g.user = (\n            get_db().execute(\"SELECT * FROM user WHERE id = ?\", (user_id,)).fetchone()\n        )",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `load_logged_in_user` in examples\\tutorial\\flaskr\\auth.py",
      "possible_syscalls": [],
      "confidence": 0.3,
      "evidence": [
        "function load_logged_in_user in examples\\tutorial\\flaskr\\auth.py",
        "matched template: authenticate a user and return a token (sim=0.39)"
      ]
    },
    {
      "name": "register",
      "description": "authenticate a user and return a token. Function `register`.",
      "predicted_filename": "examples\\tutorial\\flaskr\\auth.py",
      "predicted_code_snippet": "def register():\n    \"\"\"Register a new user.\n\n    Validates that the username is not already taken. Hashes the\n    password for security.\n    \"\"\"\n    if request.method == \"POST\":\n        username = request.form[\"username\"]\n        password = request.form[\"password\"]\n        db = get_db()\n        error = None\n\n        if not username:\n            error = \"Username is required.\"\n        elif not password:\n            error = \"Password is required.\"\n\n        if error is None:\n            try:\n                db.execute(\n                    \"INSERT INTO user (username, password) VALUES (?, ?)\",\n                    (username, generate_password_hash(password)),\n                )\n                db.commit()\n            except db.IntegrityError:\n                # The username was already taken, which caused the\n                # commit to fail. Show a validation error.\n                error = f\"User {username} is already registered.\"\n            else:\n                # Success, go to the login page.\n                return redirect(url_for(\"auth.login\"))\n\n        flash(error)\n\n    return render_template(\"auth/register.html\")",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `register` in examples\\tutorial\\flaskr\\auth.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function register in examples\\tutorial\\flaskr\\auth.py",
        "matched template: authenticate a user and return a token (sim=0.28)"
      ]
    },
    {
      "name": "login",
      "description": "authenticate a user and return a token. Function `login`.",
      "predicted_filename": "examples\\tutorial\\flaskr\\auth.py",
      "predicted_code_snippet": "def login():\n    \"\"\"Log in a registered user by adding the user id to the session.\"\"\"\n    if request.method == \"POST\":\n        username = request.form[\"username\"]\n        password = request.form[\"password\"]\n        db = get_db()\n        error = None\n        user = db.execute(\n            \"SELECT * FROM user WHERE username = ?\", (username,)\n        ).fetchone()\n\n        if user is None:\n            error = \"Incorrect username.\"\n        elif not check_password_hash(user[\"password\"], password):\n            error = \"Incorrect password.\"\n\n        if error is None:\n            # store the user id in a new session and return to the index\n            session.clear()\n            session[\"user_id\"] = user[\"id\"]\n            return redirect(url_for(\"index\"))\n\n        flash(error)\n\n    return render_template(\"auth/login.html\")",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `login` in examples\\tutorial\\flaskr\\auth.py",
      "possible_syscalls": [],
      "confidence": 0.27,
      "evidence": [
        "function login in examples\\tutorial\\flaskr\\auth.py",
        "matched template: authenticate a user and return a token (sim=0.35)"
      ]
    },
    {
      "name": "logout",
      "description": "authenticate a user and return a token. Function `logout`.",
      "predicted_filename": "examples\\tutorial\\flaskr\\auth.py",
      "predicted_code_snippet": "def logout():\n    \"\"\"Clear the current session, including the stored user id.\"\"\"\n    session.clear()\n    return redirect(url_for(\"index\"))",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `logout` in examples\\tutorial\\flaskr\\auth.py",
      "possible_syscalls": [],
      "confidence": 0.27,
      "evidence": [
        "function logout in examples\\tutorial\\flaskr\\auth.py",
        "matched template: authenticate a user and return a token (sim=0.34)"
      ]
    },
    {
      "name": "index",
      "description": "perform database query and return records. Function `index`.",
      "predicted_filename": "examples\\tutorial\\flaskr\\blog.py",
      "predicted_code_snippet": "def index():\n    \"\"\"Show all the posts, most recent first.\"\"\"\n    db = get_db()\n    posts = db.execute(\n        \"SELECT p.id, title, body, created, author_id, username\"\n        \" FROM post p JOIN user u ON p.author_id = u.id\"\n        \" ORDER BY created DESC\"\n    ).fetchall()\n    return render_template(\"blog/index.html\", posts=posts)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `index` in examples\\tutorial\\flaskr\\blog.py",
      "possible_syscalls": [],
      "confidence": 0.26,
      "evidence": [
        "function index in examples\\tutorial\\flaskr\\blog.py",
        "matched template: perform database query and return records (sim=0.33)"
      ]
    },
    {
      "name": "get_post",
      "description": "authenticate a user and return a token. Function `get_post`.",
      "predicted_filename": "examples\\tutorial\\flaskr\\blog.py",
      "predicted_code_snippet": "def get_post(id, check_author=True):\n    \"\"\"Get a post and its author by id.\n\n    Checks that the id exists and optionally that the current user is\n    the author.\n\n    :param id: id of post to get\n    :param check_author: require the current user to be the author\n    :return: the post with author information\n    :raise 404: if a post with the given id doesn't exist\n    :raise 403: if the current user isn't the author\n    \"\"\"\n    post = (\n        get_db()\n        .execute(\n            \"SELECT p.id, title, body, created, author_id, username\"\n            \" FROM post p JOIN user u ON p.author_id = u.id\"\n            \" WHERE p.id = ?\",\n            (id,),\n        )\n        .fetchone()\n    )\n\n    if post is None:\n        abort(404, f\"Post id {id} doesn't exist.\")\n\n    if check_author and post[\"author_id\"] != g.user[\"id\"]:\n        abort(403)\n\n    return post",
      "input_schema": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "required": true
          },
          "check_author": {
            "type": "string",
            "required": false
          }
        },
        "required": [
          "id"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "id": "string",
          "check_author": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `get_post` in examples\\tutorial\\flaskr\\blog.py",
      "possible_syscalls": [],
      "confidence": 0.24,
      "evidence": [
        "function get_post in examples\\tutorial\\flaskr\\blog.py",
        "matched template: authenticate a user and return a token (sim=0.29)"
      ]
    },
    {
      "name": "create",
      "description": "perform database query and return records. Function `create`.",
      "predicted_filename": "examples\\tutorial\\flaskr\\blog.py",
      "predicted_code_snippet": "def create():\n    \"\"\"Create a new post for the current user.\"\"\"\n    if request.method == \"POST\":\n        title = request.form[\"title\"]\n        body = request.form[\"body\"]\n        error = None\n\n        if not title:\n            error = \"Title is required.\"\n\n        if error is not None:\n            flash(error)\n        else:\n            db = get_db()\n            db.execute(\n                \"INSERT INTO post (title, body, author_id) VALUES (?, ?, ?)\",\n                (title, body, g.user[\"id\"]),\n            )\n            db.commit()\n            return redirect(url_for(\"blog.index\"))\n\n    return render_template(\"blog/create.html\")",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `create` in examples\\tutorial\\flaskr\\blog.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function create in examples\\tutorial\\flaskr\\blog.py",
        "matched template: perform database query and return records (sim=0.25)"
      ]
    },
    {
      "name": "update",
      "description": "perform database query and return records. Function `update`.",
      "predicted_filename": "examples\\tutorial\\flaskr\\blog.py",
      "predicted_code_snippet": "def update(id):\n    \"\"\"Update a post if the current user is the author.\"\"\"\n    post = get_post(id)\n\n    if request.method == \"POST\":\n        title = request.form[\"title\"]\n        body = request.form[\"body\"]\n        error = None\n\n        if not title:\n            error = \"Title is required.\"\n\n        if error is not None:\n            flash(error)\n        else:\n            db = get_db()\n            db.execute(\n                \"UPDATE post SET title = ?, body = ? WHERE id = ?\", (title, body, id)\n            )\n            db.commit()\n            return redirect(url_for(\"blog.index\"))\n\n    return render_template(\"blog/update.html\", post=post)",
      "input_schema": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "id"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "id": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `update` in examples\\tutorial\\flaskr\\blog.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function update in examples\\tutorial\\flaskr\\blog.py",
        "matched template: perform database query and return records (sim=0.22)"
      ]
    },
    {
      "name": "delete",
      "description": "perform database query and return records. Function `delete`.",
      "predicted_filename": "examples\\tutorial\\flaskr\\blog.py",
      "predicted_code_snippet": "def delete(id):\n    \"\"\"Delete a post.\n\n    Ensures that the post exists and that the logged in user is the\n    author of the post.\n    \"\"\"\n    get_post(id)\n    db = get_db()\n    db.execute(\"DELETE FROM post WHERE id = ?\", (id,))\n    db.commit()\n    return redirect(url_for(\"blog.index\"))",
      "input_schema": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "id"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "id": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `delete` in examples\\tutorial\\flaskr\\blog.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function delete in examples\\tutorial\\flaskr\\blog.py",
        "matched template: perform database query and return records (sim=0.26)"
      ]
    },
    {
      "name": "get_db",
      "description": "perform database query and return records. Function `get_db`.",
      "predicted_filename": "examples\\tutorial\\flaskr\\db.py",
      "predicted_code_snippet": "def get_db():\n    \"\"\"Connect to the application's configured database. The connection\n    is unique for each request and will be reused if this is called\n    again.\n    \"\"\"\n    if \"db\" not in g:\n        g.db = sqlite3.connect(\n            current_app.config[\"DATABASE\"], detect_types=sqlite3.PARSE_DECLTYPES\n        )\n        g.db.row_factory = sqlite3.Row\n\n    return g.db",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `get_db` in examples\\tutorial\\flaskr\\db.py",
      "possible_syscalls": [],
      "confidence": 0.25,
      "evidence": [
        "function get_db in examples\\tutorial\\flaskr\\db.py",
        "matched template: perform database query and return records (sim=0.31)"
      ]
    },
    {
      "name": "close_db",
      "description": "perform database query and return records. Function `close_db`.",
      "predicted_filename": "examples\\tutorial\\flaskr\\db.py",
      "predicted_code_snippet": "def close_db(e=None):\n    \"\"\"If this request connected to the database, close the\n    connection.\n    \"\"\"\n    db = g.pop(\"db\", None)\n\n    if db is not None:\n        db.close()",
      "input_schema": {
        "type": "object",
        "properties": {
          "e": {
            "type": "string",
            "required": false
          }
        },
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "e": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `close_db` in examples\\tutorial\\flaskr\\db.py",
      "possible_syscalls": [],
      "confidence": 0.25,
      "evidence": [
        "function close_db in examples\\tutorial\\flaskr\\db.py",
        "matched template: perform database query and return records (sim=0.31)"
      ]
    },
    {
      "name": "init_db",
      "description": "perform database query and return records. Function `init_db`.",
      "predicted_filename": "examples\\tutorial\\flaskr\\db.py",
      "predicted_code_snippet": "def init_db():\n    \"\"\"Clear existing data and create new tables.\"\"\"\n    db = get_db()\n\n    with current_app.open_resource(\"schema.sql\") as f:\n        db.executescript(f.read().decode(\"utf8\"))",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `init_db` in examples\\tutorial\\flaskr\\db.py",
      "possible_syscalls": [],
      "confidence": 0.25,
      "evidence": [
        "function init_db in examples\\tutorial\\flaskr\\db.py",
        "matched template: perform database query and return records (sim=0.30)"
      ]
    },
    {
      "name": "init_db_command",
      "description": "perform database query and return records. Function `init_db_command`.",
      "predicted_filename": "examples\\tutorial\\flaskr\\db.py",
      "predicted_code_snippet": "def init_db_command():\n    \"\"\"Clear existing data and create new tables.\"\"\"\n    init_db()\n    click.echo(\"Initialized the database.\")",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `init_db_command` in examples\\tutorial\\flaskr\\db.py",
      "possible_syscalls": [],
      "confidence": 0.25,
      "evidence": [
        "function init_db_command in examples\\tutorial\\flaskr\\db.py",
        "matched template: perform database query and return records (sim=0.30)"
      ]
    },
    {
      "name": "init_app",
      "description": "perform database query and return records. Function `init_app`.",
      "predicted_filename": "examples\\tutorial\\flaskr\\db.py",
      "predicted_code_snippet": "def init_app(app):\n    \"\"\"Register database functions with the Flask app. This is called by\n    the application factory.\n    \"\"\"\n    app.teardown_appcontext(close_db)\n    app.cli.add_command(init_db_command)",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `init_app` in examples\\tutorial\\flaskr\\db.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function init_app in examples\\tutorial\\flaskr\\db.py",
        "matched template: perform database query and return records (sim=0.26)"
      ]
    },
    {
      "name": "create_app",
      "description": "write data to a file. Function `create_app`.",
      "predicted_filename": "examples\\tutorial\\flaskr\\__init__.py",
      "predicted_code_snippet": "def create_app(test_config=None):\n    \"\"\"Create and configure an instance of the Flask application.\"\"\"\n    app = Flask(__name__, instance_relative_config=True)\n    app.config.from_mapping(\n        # a default secret that should be overridden by instance config\n        SECRET_KEY=\"dev\",\n        # store the database in the instance folder\n        DATABASE=os.path.join(app.instance_path, \"flaskr.sqlite\"),\n    )\n\n    if test_config is None:\n        # load the instance config, if it exists, when not testing\n        app.config.from_pyfile(\"config.py\", silent=True)\n    else:\n        # load the test config if passed in\n        app.config.update(test_config)\n\n    # ensure the instance folder exists\n    try:\n        os.makedirs(app.instance_path)\n    except OSError:\n        pass\n\n    @app.route(\"/hello\")\n    def hello():\n        return \"Hello, World!\"\n\n    # register the database commands\n    from . import db\n\n    db.init_app(app)\n\n    # apply the blueprints to the app\n    from . import auth\n    from . import blog\n\n    app.register_blueprint(auth.bp)\n    app.register_blueprint(blog.bp)\n\n    # make url_for('index') == url_for('blog.index')\n    # in another app, you might define a separate main index here with\n    # app.route, while giving the blog blueprint a url_prefix, but for\n    # the tutorial the blog will be the main index\n    app.add_url_rule(\"/\", endpoint=\"index\")\n\n    return app",
      "input_schema": {
        "type": "object",
        "properties": {
          "test_config": {
            "type": "string",
            "required": false
          }
        },
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "test_config": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `create_app` in examples\\tutorial\\flaskr\\__init__.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function create_app in examples\\tutorial\\flaskr\\__init__.py",
        "matched template: write data to a file (sim=0.12)"
      ]
    },
    {
      "name": "app",
      "description": "write data to a file. Function `app`.",
      "predicted_filename": "examples\\tutorial\\tests\\conftest.py",
      "predicted_code_snippet": "def app():\n    \"\"\"Create and configure a new app instance for each test.\"\"\"\n    # create a temporary file to isolate the database for each test\n    db_fd, db_path = tempfile.mkstemp()\n    # create the app with common test config\n    app = create_app({\"TESTING\": True, \"DATABASE\": db_path})\n\n    # create the database and load test data\n    with app.app_context():\n        init_db()\n        get_db().executescript(_data_sql)\n\n    yield app\n\n    # close and remove the temporary database\n    os.close(db_fd)\n    os.unlink(db_path)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `app` in examples\\tutorial\\tests\\conftest.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.2,
      "evidence": [
        "function app in examples\\tutorial\\tests\\conftest.py",
        "matched template: write data to a file (sim=0.20)"
      ]
    },
    {
      "name": "client",
      "description": "write data to a file. Function `client`.",
      "predicted_filename": "examples\\tutorial\\tests\\conftest.py",
      "predicted_code_snippet": "def client(app):\n    \"\"\"A test client for the app.\"\"\"\n    return app.test_client()",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `client` in examples\\tutorial\\tests\\conftest.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.2,
      "evidence": [
        "function client in examples\\tutorial\\tests\\conftest.py",
        "matched template: write data to a file (sim=0.21)"
      ]
    },
    {
      "name": "runner",
      "description": "write data to a file. Function `runner`.",
      "predicted_filename": "examples\\tutorial\\tests\\conftest.py",
      "predicted_code_snippet": "def runner(app):\n    \"\"\"A test runner for the app's Click commands.\"\"\"\n    return app.test_cli_runner()",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `runner` in examples\\tutorial\\tests\\conftest.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.2,
      "evidence": [
        "function runner in examples\\tutorial\\tests\\conftest.py",
        "matched template: write data to a file (sim=0.21)"
      ]
    },
    {
      "name": "auth",
      "description": "authenticate a user and return a token. Function `auth`.",
      "predicted_filename": "examples\\tutorial\\tests\\conftest.py",
      "predicted_code_snippet": "def auth(client):\n    return AuthActions(client)",
      "input_schema": {
        "type": "object",
        "properties": {
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `auth` in examples\\tutorial\\tests\\conftest.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.2,
      "evidence": [
        "function auth in examples\\tutorial\\tests\\conftest.py",
        "matched template: authenticate a user and return a token (sim=0.20)"
      ]
    },
    {
      "name": "test_register",
      "description": "authenticate a user and return a token. Function `test_register`.",
      "predicted_filename": "examples\\tutorial\\tests\\test_auth.py",
      "predicted_code_snippet": "def test_register(client, app):\n    # test that viewing the page renders without template errors\n    assert client.get(\"/auth/register\").status_code == 200\n\n    # test that successful registration redirects to the login page\n    response = client.post(\"/auth/register\", data={\"username\": \"a\", \"password\": \"a\"})\n    assert response.headers[\"Location\"] == \"/auth/login\"\n\n    # test that the user was inserted into the database\n    with app.app_context():\n        assert (\n            get_db().execute(\"SELECT * FROM user WHERE username = 'a'\").fetchone()\n            is not None\n        )",
      "input_schema": {
        "type": "object",
        "properties": {
          "client": {
            "type": "string",
            "required": true
          },
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "client",
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "client": "string",
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_register` in examples\\tutorial\\tests\\test_auth.py",
      "possible_syscalls": [],
      "confidence": 0.28,
      "evidence": [
        "function test_register in examples\\tutorial\\tests\\test_auth.py",
        "matched template: authenticate a user and return a token (sim=0.35)"
      ]
    },
    {
      "name": "test_register_validate_input",
      "description": "authenticate a user and return a token. Function `test_register_validate_input`.",
      "predicted_filename": "examples\\tutorial\\tests\\test_auth.py",
      "predicted_code_snippet": "def test_register_validate_input(client, username, password, message):\n    response = client.post(\n        \"/auth/register\", data={\"username\": username, \"password\": password}\n    )\n    assert message in response.data",
      "input_schema": {
        "type": "object",
        "properties": {
          "client": {
            "type": "string",
            "required": true
          },
          "username": {
            "type": "string",
            "required": true
          },
          "password": {
            "type": "string",
            "required": true
          },
          "message": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "client",
          "username",
          "password",
          "message"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "client": "string",
          "username": "string",
          "password": "string",
          "message": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_register_validate_input` in examples\\tutorial\\tests\\test_auth.py",
      "possible_syscalls": [],
      "confidence": 0.28,
      "evidence": [
        "function test_register_validate_input in examples\\tutorial\\tests\\test_auth.py",
        "matched template: authenticate a user and return a token (sim=0.35)"
      ]
    },
    {
      "name": "test_login",
      "description": "authenticate a user and return a token. Function `test_login`.",
      "predicted_filename": "examples\\tutorial\\tests\\test_auth.py",
      "predicted_code_snippet": "def test_login(client, auth):\n    # test that viewing the page renders without template errors\n    assert client.get(\"/auth/login\").status_code == 200\n\n    # test that successful login redirects to the index page\n    response = auth.login()\n    assert response.headers[\"Location\"] == \"/\"\n\n    # login request set the user_id in the session\n    # check that the user is loaded from the session\n    with client:\n        client.get(\"/\")\n        assert session[\"user_id\"] == 1\n        assert g.user[\"username\"] == \"test\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "client": {
            "type": "string",
            "required": true
          },
          "auth": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "client",
          "auth"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "client": "string",
          "auth": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_login` in examples\\tutorial\\tests\\test_auth.py",
      "possible_syscalls": [],
      "confidence": 0.3,
      "evidence": [
        "function test_login in examples\\tutorial\\tests\\test_auth.py",
        "matched template: authenticate a user and return a token (sim=0.39)"
      ]
    },
    {
      "name": "test_login_validate_input",
      "description": "authenticate a user and return a token. Function `test_login_validate_input`.",
      "predicted_filename": "examples\\tutorial\\tests\\test_auth.py",
      "predicted_code_snippet": "def test_login_validate_input(auth, username, password, message):\n    response = auth.login(username, password)\n    assert message in response.data",
      "input_schema": {
        "type": "object",
        "properties": {
          "auth": {
            "type": "string",
            "required": true
          },
          "username": {
            "type": "string",
            "required": true
          },
          "password": {
            "type": "string",
            "required": true
          },
          "message": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "auth",
          "username",
          "password",
          "message"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "auth": "string",
          "username": "string",
          "password": "string",
          "message": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_login_validate_input` in examples\\tutorial\\tests\\test_auth.py",
      "possible_syscalls": [],
      "confidence": 0.29,
      "evidence": [
        "function test_login_validate_input in examples\\tutorial\\tests\\test_auth.py",
        "matched template: authenticate a user and return a token (sim=0.37)"
      ]
    },
    {
      "name": "test_logout",
      "description": "authenticate a user and return a token. Function `test_logout`.",
      "predicted_filename": "examples\\tutorial\\tests\\test_auth.py",
      "predicted_code_snippet": "def test_logout(client, auth):\n    auth.login()\n\n    with client:\n        auth.logout()\n        assert \"user_id\" not in session",
      "input_schema": {
        "type": "object",
        "properties": {
          "client": {
            "type": "string",
            "required": true
          },
          "auth": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "client",
          "auth"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "client": "string",
          "auth": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_logout` in examples\\tutorial\\tests\\test_auth.py",
      "possible_syscalls": [],
      "confidence": 0.3,
      "evidence": [
        "function test_logout in examples\\tutorial\\tests\\test_auth.py",
        "matched template: authenticate a user and return a token (sim=0.39)"
      ]
    },
    {
      "name": "test_index",
      "description": "authenticate a user and return a token. Function `test_index`.",
      "predicted_filename": "examples\\tutorial\\tests\\test_blog.py",
      "predicted_code_snippet": "def test_index(client, auth):\n    response = client.get(\"/\")\n    assert b\"Log In\" in response.data\n    assert b\"Register\" in response.data\n\n    auth.login()\n    response = client.get(\"/\")\n    assert b\"test title\" in response.data\n    assert b\"by test on 2018-01-01\" in response.data\n    assert b\"test\\nbody\" in response.data\n    assert b'href=\"/1/update\"' in response.data",
      "input_schema": {
        "type": "object",
        "properties": {
          "client": {
            "type": "string",
            "required": true
          },
          "auth": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "client",
          "auth"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "client": "string",
          "auth": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_index` in examples\\tutorial\\tests\\test_blog.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_index in examples\\tutorial\\tests\\test_blog.py",
        "matched template: authenticate a user and return a token (sim=0.18)"
      ]
    },
    {
      "name": "test_login_required",
      "description": "authenticate a user and return a token. Function `test_login_required`.",
      "predicted_filename": "examples\\tutorial\\tests\\test_blog.py",
      "predicted_code_snippet": "def test_login_required(client, path):\n    response = client.post(path)\n    assert response.headers[\"Location\"] == \"/auth/login\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "client": {
            "type": "string",
            "required": true
          },
          "path": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "client",
          "path"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "client": "string",
          "path": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_login_required` in examples\\tutorial\\tests\\test_blog.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function test_login_required in examples\\tutorial\\tests\\test_blog.py",
        "matched template: authenticate a user and return a token (sim=0.28)"
      ]
    },
    {
      "name": "test_author_required",
      "description": "authenticate a user and return a token. Function `test_author_required`.",
      "predicted_filename": "examples\\tutorial\\tests\\test_blog.py",
      "predicted_code_snippet": "def test_author_required(app, client, auth):\n    # change the post author to another user\n    with app.app_context():\n        db = get_db()\n        db.execute(\"UPDATE post SET author_id = 2 WHERE id = 1\")\n        db.commit()\n\n    auth.login()\n    # current user can't modify other user's post\n    assert client.post(\"/1/update\").status_code == 403\n    assert client.post(\"/1/delete\").status_code == 403\n    # current user doesn't see edit link\n    assert b'href=\"/1/update\"' not in client.get(\"/\").data",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          },
          "auth": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client",
          "auth"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string",
          "auth": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_author_required` in examples\\tutorial\\tests\\test_blog.py",
      "possible_syscalls": [],
      "confidence": 0.24,
      "evidence": [
        "function test_author_required in examples\\tutorial\\tests\\test_blog.py",
        "matched template: authenticate a user and return a token (sim=0.29)"
      ]
    },
    {
      "name": "test_exists_required",
      "description": "authenticate a user and return a token. Function `test_exists_required`.",
      "predicted_filename": "examples\\tutorial\\tests\\test_blog.py",
      "predicted_code_snippet": "def test_exists_required(client, auth, path):\n    auth.login()\n    assert client.post(path).status_code == 404",
      "input_schema": {
        "type": "object",
        "properties": {
          "client": {
            "type": "string",
            "required": true
          },
          "auth": {
            "type": "string",
            "required": true
          },
          "path": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "client",
          "auth",
          "path"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "client": "string",
          "auth": "string",
          "path": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_exists_required` in examples\\tutorial\\tests\\test_blog.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function test_exists_required in examples\\tutorial\\tests\\test_blog.py",
        "matched template: authenticate a user and return a token (sim=0.27)"
      ]
    },
    {
      "name": "test_create",
      "description": "perform database query and return records. Function `test_create`.",
      "predicted_filename": "examples\\tutorial\\tests\\test_blog.py",
      "predicted_code_snippet": "def test_create(client, auth, app):\n    auth.login()\n    assert client.get(\"/create\").status_code == 200\n    client.post(\"/create\", data={\"title\": \"created\", \"body\": \"\"})\n\n    with app.app_context():\n        db = get_db()\n        count = db.execute(\"SELECT COUNT(id) FROM post\").fetchone()[0]\n        assert count == 2",
      "input_schema": {
        "type": "object",
        "properties": {
          "client": {
            "type": "string",
            "required": true
          },
          "auth": {
            "type": "string",
            "required": true
          },
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "client",
          "auth",
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "client": "string",
          "auth": "string",
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_create` in examples\\tutorial\\tests\\test_blog.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function test_create in examples\\tutorial\\tests\\test_blog.py",
        "matched template: perform database query and return records (sim=0.21)"
      ]
    },
    {
      "name": "test_update",
      "description": "authenticate a user and return a token. Function `test_update`.",
      "predicted_filename": "examples\\tutorial\\tests\\test_blog.py",
      "predicted_code_snippet": "def test_update(client, auth, app):\n    auth.login()\n    assert client.get(\"/1/update\").status_code == 200\n    client.post(\"/1/update\", data={\"title\": \"updated\", \"body\": \"\"})\n\n    with app.app_context():\n        db = get_db()\n        post = db.execute(\"SELECT * FROM post WHERE id = 1\").fetchone()\n        assert post[\"title\"] == \"updated\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "client": {
            "type": "string",
            "required": true
          },
          "auth": {
            "type": "string",
            "required": true
          },
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "client",
          "auth",
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "client": "string",
          "auth": "string",
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_update` in examples\\tutorial\\tests\\test_blog.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function test_update in examples\\tutorial\\tests\\test_blog.py",
        "matched template: authenticate a user and return a token (sim=0.17)"
      ]
    },
    {
      "name": "test_create_update_validate",
      "description": "authenticate a user and return a token. Function `test_create_update_validate`.",
      "predicted_filename": "examples\\tutorial\\tests\\test_blog.py",
      "predicted_code_snippet": "def test_create_update_validate(client, auth, path):\n    auth.login()\n    response = client.post(path, data={\"title\": \"\", \"body\": \"\"})\n    assert b\"Title is required.\" in response.data",
      "input_schema": {
        "type": "object",
        "properties": {
          "client": {
            "type": "string",
            "required": true
          },
          "auth": {
            "type": "string",
            "required": true
          },
          "path": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "client",
          "auth",
          "path"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "client": "string",
          "auth": "string",
          "path": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_create_update_validate` in examples\\tutorial\\tests\\test_blog.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function test_create_update_validate in examples\\tutorial\\tests\\test_blog.py",
        "matched template: authenticate a user and return a token (sim=0.23)"
      ]
    },
    {
      "name": "test_delete",
      "description": "handle a HTTP route request and return response. Function `test_delete`.",
      "predicted_filename": "examples\\tutorial\\tests\\test_blog.py",
      "predicted_code_snippet": "def test_delete(client, auth, app):\n    auth.login()\n    response = client.post(\"/1/delete\")\n    assert response.headers[\"Location\"] == \"/\"\n\n    with app.app_context():\n        db = get_db()\n        post = db.execute(\"SELECT * FROM post WHERE id = 1\").fetchone()\n        assert post is None",
      "input_schema": {
        "type": "object",
        "properties": {
          "client": {
            "type": "string",
            "required": true
          },
          "auth": {
            "type": "string",
            "required": true
          },
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "client",
          "auth",
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "client": "string",
          "auth": "string",
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_delete` in examples\\tutorial\\tests\\test_blog.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function test_delete in examples\\tutorial\\tests\\test_blog.py",
        "matched template: handle a HTTP route request and return response (sim=0.20)"
      ]
    },
    {
      "name": "test_get_close_db",
      "description": "execute a shell command. Function `test_get_close_db`.",
      "predicted_filename": "examples\\tutorial\\tests\\test_db.py",
      "predicted_code_snippet": "def test_get_close_db(app):\n    with app.app_context():\n        db = get_db()\n        assert db is get_db()\n\n    with pytest.raises(sqlite3.ProgrammingError) as e:\n        db.execute(\"SELECT 1\")\n\n    assert \"closed\" in str(e.value)",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_get_close_db` in examples\\tutorial\\tests\\test_db.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_get_close_db in examples\\tutorial\\tests\\test_db.py",
        "matched template: execute a shell command (sim=0.20)"
      ]
    },
    {
      "name": "test_init_db_command",
      "description": "execute a shell command. Function `test_init_db_command`.",
      "predicted_filename": "examples\\tutorial\\tests\\test_db.py",
      "predicted_code_snippet": "def test_init_db_command(runner, monkeypatch):\n    class Recorder:\n        called = False\n\n    def fake_init_db():\n        Recorder.called = True\n\n    monkeypatch.setattr(\"flaskr.db.init_db\", fake_init_db)\n    result = runner.invoke(args=[\"init-db\"])\n    assert \"Initialized\" in result.output\n    assert Recorder.called",
      "input_schema": {
        "type": "object",
        "properties": {
          "runner": {
            "type": "string",
            "required": true
          },
          "monkeypatch": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "runner",
          "monkeypatch"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "runner": "string",
          "monkeypatch": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_init_db_command` in examples\\tutorial\\tests\\test_db.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_init_db_command in examples\\tutorial\\tests\\test_db.py",
        "matched template: execute a shell command (sim=0.19)"
      ]
    },
    {
      "name": "test_config",
      "description": "make an HTTP request to an external API. Function `test_config`.",
      "predicted_filename": "examples\\tutorial\\tests\\test_factory.py",
      "predicted_code_snippet": "def test_config():\n    \"\"\"Test create_app without passing test config.\"\"\"\n    assert not create_app().testing\n    assert create_app({\"TESTING\": True}).testing",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_config` in examples\\tutorial\\tests\\test_factory.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function test_config in examples\\tutorial\\tests\\test_factory.py",
        "matched template: make an HTTP request to an external API (sim=0.14)"
      ]
    },
    {
      "name": "test_hello",
      "description": "handle a HTTP route request and return response. Function `test_hello`.",
      "predicted_filename": "examples\\tutorial\\tests\\test_factory.py",
      "predicted_code_snippet": "def test_hello(client):\n    response = client.get(\"/hello\")\n    assert response.data == b\"Hello, World!\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_hello` in examples\\tutorial\\tests\\test_factory.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function test_hello in examples\\tutorial\\tests\\test_factory.py",
        "matched template: handle a HTTP route request and return response (sim=0.20)"
      ]
    },
    {
      "name": "_make_timedelta",
      "description": "compute cryptographic hash of input data. Function `_make_timedelta`.",
      "predicted_filename": "src\\flask\\app.py",
      "predicted_code_snippet": "def _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)",
      "input_schema": {
        "type": "object",
        "properties": {
          "value": {
            "type": "integer",
            "required": true
          }
        },
        "required": [
          "value"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "value": "integer"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `_make_timedelta` in src\\flask\\app.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        },
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.18,
      "evidence": [
        "function _make_timedelta in src\\flask\\app.py",
        "matched template: compute cryptographic hash of input data (sim=0.16)"
      ]
    },
    {
      "name": "remove_ctx",
      "description": "validate and sanitize user input. Function `remove_ctx`.",
      "predicted_filename": "src\\flask\\app.py",
      "predicted_code_snippet": "def remove_ctx(f: F) -> F:\n    def wrapper(self: Flask, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        if args and isinstance(args[0], AppContext):\n            args = args[1:]\n\n        return f(self, *args, **kwargs)\n\n    return update_wrapper(wrapper, f)",
      "input_schema": {
        "type": "object",
        "properties": {
          "f": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "f"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "f": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `remove_ctx` in src\\flask\\app.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        },
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.18,
      "evidence": [
        "function remove_ctx in src\\flask\\app.py",
        "matched template: validate and sanitize user input (sim=0.15)"
      ]
    },
    {
      "name": "add_ctx",
      "description": "write data to a file. Function `add_ctx`.",
      "predicted_filename": "src\\flask\\app.py",
      "predicted_code_snippet": "def add_ctx(f: F) -> F:\n    def wrapper(self: Flask, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        if not args:\n            args = (app_ctx._get_current_object(),)\n        elif not isinstance(args[0], AppContext):\n            args = (app_ctx._get_current_object(), *args)\n\n        return f(self, *args, **kwargs)\n\n    return update_wrapper(wrapper, f)",
      "input_schema": {
        "type": "object",
        "properties": {
          "f": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "f"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "f": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `add_ctx` in src\\flask\\app.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        },
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.17,
      "evidence": [
        "function add_ctx in src\\flask\\app.py",
        "matched template: write data to a file (sim=0.14)"
      ]
    },
    {
      "name": "find_best_app",
      "description": "parse JSON input and validate fields. Function `find_best_app`.",
      "predicted_filename": "src\\flask\\cli.py",
      "predicted_code_snippet": "def find_best_app(module: ModuleType) -> Flask:\n    \"\"\"Given a module instance this tries to find the best possible\n    application in the module or raises an exception.\n    \"\"\"\n    from . import Flask\n\n    # Search for the most common names first.\n    for attr_name in (\"app\", \"application\"):\n        app = getattr(module, attr_name, None)\n\n        if isinstance(app, Flask):\n            return app\n\n    # Otherwise find the only object that is a Flask instance.\n    matches = [v for v in module.__dict__.values() if isinstance(v, Flask)]\n\n    if len(matches) == 1:\n        return matches[0]\n    elif len(matches) > 1:\n        raise NoAppException(\n            \"Detected multiple Flask applications in module\"\n            f\" '{module.__name__}'. Use '{module.__name__}:name'\"\n            \" to specify the correct one.\"\n        )\n\n    # Search for app factory functions.\n    for attr_name in (\"create_app\", \"make_app\"):\n        app_factory = getattr(module, attr_name, None)\n\n        if inspect.isfunction(app_factory):\n            try:\n                app = app_factory()\n\n                if isinstance(app, Flask):\n                    return app\n            except TypeError as e:\n                if not _called_with_wrong_args(app_factory):\n                    raise\n\n                raise NoAppException(\n                    f\"Detected factory '{attr_name}' in module '{module.__name__}',\"\n                    \" but could not call it without arguments. Use\"\n                    f\" '{module.__name__}:{attr_name}(args)'\"\n                    \" to specify arguments.\"\n                ) from e\n\n    raise NoAppException(\n        \"Failed to find Flask application or factory in module\"\n        f\" '{module.__name__}'. Use '{module.__name__}:name'\"\n        \" to specify one.\"\n    )",
      "input_schema": {
        "type": "object",
        "properties": {
          "module": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "module"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "module": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `find_best_app` in src\\flask\\cli.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.16,
      "evidence": [
        "function find_best_app in src\\flask\\cli.py",
        "matched template: parse JSON input and validate fields (sim=0.08)"
      ]
    },
    {
      "name": "_called_with_wrong_args",
      "description": "execute a shell command. Function `_called_with_wrong_args`.",
      "predicted_filename": "src\\flask\\cli.py",
      "predicted_code_snippet": "def _called_with_wrong_args(f: t.Callable[..., Flask]) -> bool:\n    \"\"\"Check whether calling a function raised a ``TypeError`` because\n    the call failed or because something in the factory raised the\n    error.\n\n    :param f: The function that was called.\n    :return: ``True`` if the call failed.\n    \"\"\"\n    tb = sys.exc_info()[2]\n\n    try:\n        while tb is not None:\n            if tb.tb_frame.f_code is f.__code__:\n                # In the function, it was called successfully.\n                return False\n\n            tb = tb.tb_next\n\n        # Didn't reach the function.\n        return True\n    finally:\n        # Delete tb to break a circular reference.\n        # https://docs.python.org/2/library/sys.html#sys.exc_info\n        del tb",
      "input_schema": {
        "type": "object",
        "properties": {
          "f": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "f"
        ]
      },
      "output_schema": {
        "type": "boolean"
      },
      "payload_shape": {
        "request": {
          "f": "string"
        },
        "response": {
          "type": "boolean"
        }
      },
      "explanation": "Detected Python function `_called_with_wrong_args` in src\\flask\\cli.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.17,
      "evidence": [
        "function _called_with_wrong_args in src\\flask\\cli.py",
        "matched template: execute a shell command (sim=0.12)"
      ]
    },
    {
      "name": "find_app_by_string",
      "description": "parse JSON input and validate fields. Function `find_app_by_string`.",
      "predicted_filename": "src\\flask\\cli.py",
      "predicted_code_snippet": "def find_app_by_string(module: ModuleType, app_name: str) -> Flask:\n    \"\"\"Check if the given string is a variable name or a function. Call\n    a function to get the app instance, or return the variable directly.\n    \"\"\"\n    from . import Flask\n\n    # Parse app_name as a single expression to determine if it's a valid\n    # attribute name or function call.\n    try:\n        expr = ast.parse(app_name.strip(), mode=\"eval\").body\n    except SyntaxError:\n        raise NoAppException(\n            f\"Failed to parse {app_name!r} as an attribute name or function call.\"\n        ) from None\n\n    if isinstance(expr, ast.Name):\n        name = expr.id\n        args = []\n        kwargs = {}\n    elif isinstance(expr, ast.Call):\n        # Ensure the function name is an attribute name only.\n        if not isinstance(expr.func, ast.Name):\n            raise NoAppException(\n                f\"Function reference must be a simple name: {app_name!r}.\"\n            )\n\n        name = expr.func.id\n\n        # Parse the positional and keyword arguments as literals.\n        try:\n            args = [ast.literal_eval(arg) for arg in expr.args]\n            kwargs = {\n                kw.arg: ast.literal_eval(kw.value)\n                for kw in expr.keywords\n                if kw.arg is not None\n            }\n        except ValueError:\n            # literal_eval gives cryptic error messages, show a generic\n            # message with the full expression instead.\n            raise NoAppException(\n                f\"Failed to parse arguments as literal values: {app_name!r}.\"\n            ) from None\n    else:\n        raise NoAppException(\n            f\"Failed to parse {app_name!r} as an attribute name or function call.\"\n        )\n\n    try:\n        attr = getattr(module, name)\n    except AttributeError as e:\n        raise NoAppException(\n            f\"Failed to find attribute {name!r} in {module.__name__!r}.\"\n        ) from e\n\n    # If the attribute is a function, call it with any args and kwargs\n    # to get the real application.\n    if inspect.isfunction(attr):\n        try:\n            app = attr(*args, **kwargs)\n        except TypeError as e:\n            if not _called_with_wrong_args(attr):\n                raise\n\n            raise NoAppException(\n                f\"The factory {app_name!r} in module\"\n                f\" {module.__name__!r} could not be called with the\"\n                \" specified arguments.\"\n            ) from e\n    else:\n        app = attr\n\n    if isinstance(app, Flask):\n        return app\n\n    raise NoAppException(\n        \"A valid Flask application was not obtained from\"\n        f\" '{module.__name__}:{app_name}'.\"\n    )",
      "input_schema": {
        "type": "object",
        "properties": {
          "module": {
            "type": "string",
            "required": true
          },
          "app_name": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "module",
          "app_name"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "module": "string",
          "app_name": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `find_app_by_string` in src\\flask\\cli.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.2,
      "evidence": [
        "function find_app_by_string in src\\flask\\cli.py",
        "matched template: parse JSON input and validate fields (sim=0.20)"
      ]
    },
    {
      "name": "prepare_import",
      "description": "list files in a directory. Function `prepare_import`.",
      "predicted_filename": "src\\flask\\cli.py",
      "predicted_code_snippet": "def prepare_import(path: str) -> str:\n    \"\"\"Given a filename this will try to calculate the python path, add it\n    to the search path and return the actual module name that is expected.\n    \"\"\"\n    path = os.path.realpath(path)\n\n    fname, ext = os.path.splitext(path)\n    if ext == \".py\":\n        path = fname\n\n    if os.path.basename(path) == \"__init__\":\n        path = os.path.dirname(path)\n\n    module_name = []\n\n    # move up until outside package structure (no __init__.py)\n    while True:\n        path, name = os.path.split(path)\n        module_name.append(name)\n\n        if not os.path.exists(os.path.join(path, \"__init__.py\")):\n            break\n\n    if sys.path[0] != path:\n        sys.path.insert(0, path)\n\n    return \".\".join(module_name[::-1])",
      "input_schema": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "path"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "path": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `prepare_import` in src\\flask\\cli.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.19,
      "evidence": [
        "function prepare_import in src\\flask\\cli.py",
        "matched template: list files in a directory (sim=0.19)"
      ]
    },
    {
      "name": "locate_app",
      "description": "execute a shell command. Function `locate_app`.",
      "predicted_filename": "src\\flask\\cli.py",
      "predicted_code_snippet": "def locate_app(\n    module_name: str, app_name: str | None, raise_if_not_found: t.Literal[True] = True\n) -> Flask: ...",
      "input_schema": {
        "type": "object",
        "properties": {
          "module_name": {
            "type": "string",
            "required": true
          },
          "app_name": {
            "type": "string",
            "required": true
          },
          "raise_if_not_found": {
            "type": "string",
            "required": false
          }
        },
        "required": [
          "module_name",
          "app_name"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "module_name": "string",
          "app_name": "string",
          "raise_if_not_found": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `locate_app` in src\\flask\\cli.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.16,
      "evidence": [
        "function locate_app in src\\flask\\cli.py",
        "matched template: execute a shell command (sim=0.11)"
      ]
    },
    {
      "name": "locate_app",
      "description": "execute a shell command. Function `locate_app`.",
      "predicted_filename": "src\\flask\\cli.py",
      "predicted_code_snippet": "def locate_app(\n    module_name: str, app_name: str | None, raise_if_not_found: t.Literal[False] = ...\n) -> Flask | None: ...",
      "input_schema": {
        "type": "object",
        "properties": {
          "module_name": {
            "type": "string",
            "required": true
          },
          "app_name": {
            "type": "string",
            "required": true
          },
          "raise_if_not_found": {
            "type": "string",
            "required": false
          }
        },
        "required": [
          "module_name",
          "app_name"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "module_name": "string",
          "app_name": "string",
          "raise_if_not_found": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `locate_app` in src\\flask\\cli.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.16,
      "evidence": [
        "function locate_app in src\\flask\\cli.py",
        "matched template: execute a shell command (sim=0.11)"
      ]
    },
    {
      "name": "locate_app",
      "description": "list files in a directory. Function `locate_app`.",
      "predicted_filename": "src\\flask\\cli.py",
      "predicted_code_snippet": "def locate_app(\n    module_name: str, app_name: str | None, raise_if_not_found: bool = True\n) -> Flask | None:\n    try:\n        __import__(module_name)\n    except ImportError:\n        # Reraise the ImportError if it occurred within the imported module.\n        # Determine this by checking whether the trace has a depth > 1.\n        if sys.exc_info()[2].tb_next:  # type: ignore[union-attr]\n            raise NoAppException(\n                f\"While importing {module_name!r}, an ImportError was\"\n                f\" raised:\\n\\n{traceback.format_exc()}\"\n            ) from None\n        elif raise_if_not_found:\n            raise NoAppException(f\"Could not import {module_name!r}.\") from None\n        else:\n            return None\n\n    module = sys.modules[module_name]\n\n    if app_name is None:\n        return find_best_app(module)\n    else:\n        return find_app_by_string(module, app_name)",
      "input_schema": {
        "type": "object",
        "properties": {
          "module_name": {
            "type": "string",
            "required": true
          },
          "app_name": {
            "type": "string",
            "required": true
          },
          "raise_if_not_found": {
            "type": "boolean",
            "required": false
          }
        },
        "required": [
          "module_name",
          "app_name"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "module_name": "string",
          "app_name": "string",
          "raise_if_not_found": "boolean"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `locate_app` in src\\flask\\cli.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.16,
      "evidence": [
        "function locate_app in src\\flask\\cli.py",
        "matched template: list files in a directory (sim=0.09)"
      ]
    },
    {
      "name": "get_version",
      "description": "execute a shell command. Function `get_version`.",
      "predicted_filename": "src\\flask\\cli.py",
      "predicted_code_snippet": "def get_version(ctx: click.Context, param: click.Parameter, value: t.Any) -> None:\n    if not value or ctx.resilient_parsing:\n        return\n\n    flask_version = importlib.metadata.version(\"flask\")\n    werkzeug_version = importlib.metadata.version(\"werkzeug\")\n\n    click.echo(\n        f\"Python {platform.python_version()}\\n\"\n        f\"Flask {flask_version}\\n\"\n        f\"Werkzeug {werkzeug_version}\",\n        color=ctx.color,\n    )\n    ctx.exit()",
      "input_schema": {
        "type": "object",
        "properties": {
          "ctx": {
            "type": "string",
            "required": true
          },
          "param": {
            "type": "string",
            "required": true
          },
          "value": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "ctx",
          "param",
          "value"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "ctx": "string",
          "param": "string",
          "value": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `get_version` in src\\flask\\cli.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.17,
      "evidence": [
        "function get_version in src\\flask\\cli.py",
        "matched template: execute a shell command (sim=0.13)"
      ]
    },
    {
      "name": "with_appcontext",
      "description": "execute a shell command. Function `with_appcontext`.",
      "predicted_filename": "src\\flask\\cli.py",
      "predicted_code_snippet": "def with_appcontext(f: F) -> F:\n    \"\"\"Wraps a callback so that it's guaranteed to be executed with the\n    script's application context.\n\n    Custom commands (and their options) registered under ``app.cli`` or\n    ``blueprint.cli`` will always have an app context available, this\n    decorator is not required in that case.\n\n    .. versionchanged:: 2.2\n        The app context is active for subcommands as well as the\n        decorated callback. The app context is always available to\n        ``app.cli`` command and parameter callbacks.\n    \"\"\"\n\n    @click.pass_context\n    def decorator(ctx: click.Context, /, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        if not current_app:\n            app = ctx.ensure_object(ScriptInfo).load_app()\n            ctx.with_resource(app.app_context())\n\n        return ctx.invoke(f, *args, **kwargs)\n\n    return update_wrapper(decorator, f)",
      "input_schema": {
        "type": "object",
        "properties": {
          "f": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "f"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "f": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `with_appcontext` in src\\flask\\cli.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.19,
      "evidence": [
        "function with_appcontext in src\\flask\\cli.py",
        "matched template: execute a shell command (sim=0.18)"
      ]
    },
    {
      "name": "_set_app",
      "description": "execute a shell command. Function `_set_app`.",
      "predicted_filename": "src\\flask\\cli.py",
      "predicted_code_snippet": "def _set_app(ctx: click.Context, param: click.Option, value: str | None) -> str | None:\n    if value is None:\n        return None\n\n    info = ctx.ensure_object(ScriptInfo)\n    info.app_import_path = value\n    return value",
      "input_schema": {
        "type": "object",
        "properties": {
          "ctx": {
            "type": "string",
            "required": true
          },
          "param": {
            "type": "string",
            "required": true
          },
          "value": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "ctx",
          "param",
          "value"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "ctx": "string",
          "param": "string",
          "value": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `_set_app` in src\\flask\\cli.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.19,
      "evidence": [
        "function _set_app in src\\flask\\cli.py",
        "matched template: execute a shell command (sim=0.18)"
      ]
    },
    {
      "name": "_set_debug",
      "description": "execute a shell command. Function `_set_debug`.",
      "predicted_filename": "src\\flask\\cli.py",
      "predicted_code_snippet": "def _set_debug(ctx: click.Context, param: click.Option, value: bool) -> bool | None:\n    # If the flag isn't provided, it will default to False. Don't use\n    # that, let debug be set by env in that case.\n    source = ctx.get_parameter_source(param.name)  # type: ignore[arg-type]\n\n    if source is not None and source in (\n        ParameterSource.DEFAULT,\n        ParameterSource.DEFAULT_MAP,\n    ):\n        return None\n\n    # Set with env var instead of ScriptInfo.load so that it can be\n    # accessed early during a factory function.\n    os.environ[\"FLASK_DEBUG\"] = \"1\" if value else \"0\"\n    return value",
      "input_schema": {
        "type": "object",
        "properties": {
          "ctx": {
            "type": "string",
            "required": true
          },
          "param": {
            "type": "string",
            "required": true
          },
          "value": {
            "type": "boolean",
            "required": true
          }
        },
        "required": [
          "ctx",
          "param",
          "value"
        ]
      },
      "output_schema": {
        "type": "boolean"
      },
      "payload_shape": {
        "request": {
          "ctx": "string",
          "param": "string",
          "value": "boolean"
        },
        "response": {
          "type": "boolean"
        }
      },
      "explanation": "Detected Python function `_set_debug` in src\\flask\\cli.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.16,
      "evidence": [
        "function _set_debug in src\\flask\\cli.py",
        "matched template: execute a shell command (sim=0.10)"
      ]
    },
    {
      "name": "_env_file_callback",
      "description": "validate and sanitize user input. Function `_env_file_callback`.",
      "predicted_filename": "src\\flask\\cli.py",
      "predicted_code_snippet": "def _env_file_callback(\n    ctx: click.Context, param: click.Option, value: str | None\n) -> str | None:\n    try:\n        import dotenv  # noqa: F401\n    except ImportError:\n        # Only show an error if a value was passed, otherwise we still want to\n        # call load_dotenv and show a message without exiting.\n        if value is not None:\n            raise click.BadParameter(\n                \"python-dotenv must be installed to load an env file.\",\n                ctx=ctx,\n                param=param,\n            ) from None\n\n    # Load if a value was passed, or we want to load default files, or both.\n    if value is not None or ctx.obj.load_dotenv_defaults:\n        load_dotenv(value, load_defaults=ctx.obj.load_dotenv_defaults)\n\n    return value",
      "input_schema": {
        "type": "object",
        "properties": {
          "ctx": {
            "type": "string",
            "required": true
          },
          "param": {
            "type": "string",
            "required": true
          },
          "value": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "ctx",
          "param",
          "value"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "ctx": "string",
          "param": "string",
          "value": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `_env_file_callback` in src\\flask\\cli.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.19,
      "evidence": [
        "function _env_file_callback in src\\flask\\cli.py",
        "matched template: validate and sanitize user input (sim=0.19)"
      ]
    },
    {
      "name": "_path_is_ancestor",
      "description": "list files in a directory. Function `_path_is_ancestor`.",
      "predicted_filename": "src\\flask\\cli.py",
      "predicted_code_snippet": "def _path_is_ancestor(path: str, other: str) -> bool:\n    \"\"\"Take ``other`` and remove the length of ``path`` from it. Then join it\n    to ``path``. If it is the original value, ``path`` is an ancestor of\n    ``other``.\"\"\"\n    return os.path.join(path, other[len(path) :].lstrip(os.sep)) == other",
      "input_schema": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "required": true
          },
          "other": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "path",
          "other"
        ]
      },
      "output_schema": {
        "type": "boolean"
      },
      "payload_shape": {
        "request": {
          "path": "string",
          "other": "string"
        },
        "response": {
          "type": "boolean"
        }
      },
      "explanation": "Detected Python function `_path_is_ancestor` in src\\flask\\cli.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.21,
      "evidence": [
        "function _path_is_ancestor in src\\flask\\cli.py",
        "matched template: list files in a directory (sim=0.22)"
      ]
    },
    {
      "name": "load_dotenv",
      "description": "execute a shell command. Function `load_dotenv`.",
      "predicted_filename": "src\\flask\\cli.py",
      "predicted_code_snippet": "def load_dotenv(\n    path: str | os.PathLike[str] | None = None, load_defaults: bool = True\n) -> bool:\n    \"\"\"Load \"dotenv\" files to set environment variables. A given path takes\n    precedence over ``.env``, which takes precedence over ``.flaskenv``. After\n    loading and combining these files, values are only set if the key is not\n    already set in ``os.environ``.\n\n    This is a no-op if `python-dotenv`_ is not installed.\n\n    .. _python-dotenv: https://github.com/theskumar/python-dotenv#readme\n\n    :param path: Load the file at this location.\n    :param load_defaults: Search for and load the default ``.flaskenv`` and\n        ``.env`` files.\n    :return: ``True`` if at least one env var was loaded.\n\n    .. versionchanged:: 3.1\n        Added the ``load_defaults`` parameter. A given path takes precedence\n        over default files.\n\n    .. versionchanged:: 2.0\n        The current directory is not changed to the location of the\n        loaded file.\n\n    .. versionchanged:: 2.0\n        When loading the env files, set the default encoding to UTF-8.\n\n    .. versionchanged:: 1.1.0\n        Returns ``False`` when python-dotenv is not installed, or when\n        the given path isn't a file.\n\n    .. versionadded:: 1.0\n    \"\"\"\n    try:\n        import dotenv\n    except ImportError:\n        if path or os.path.isfile(\".env\") or os.path.isfile(\".flaskenv\"):\n            click.secho(\n                \" * Tip: There are .env files present. Install python-dotenv\"\n                \" to use them.\",\n                fg=\"yellow\",\n                err=True,\n            )\n\n        return False\n\n    data: dict[str, str | None] = {}\n\n    if load_defaults:\n        for default_name in (\".flaskenv\", \".env\"):\n            if not (default_path := dotenv.find_dotenv(default_name, usecwd=True)):\n                continue\n\n            data |= dotenv.dotenv_values(default_path, encoding=\"utf-8\")\n\n    if path is not None and os.path.isfile(path):\n        data |= dotenv.dotenv_values(path, encoding=\"utf-8\")\n\n    for key, value in data.items():\n        if key in os.environ or value is None:\n            continue\n\n        os.environ[key] = value\n\n    return bool(data)",
      "input_schema": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "required": false
          },
          "load_defaults": {
            "type": "boolean",
            "required": false
          }
        },
        "required": []
      },
      "output_schema": {
        "type": "boolean"
      },
      "payload_shape": {
        "request": {
          "path": "string",
          "load_defaults": "boolean"
        },
        "response": {
          "type": "boolean"
        }
      },
      "explanation": "Detected Python function `load_dotenv` in src\\flask\\cli.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.17,
      "evidence": [
        "function load_dotenv in src\\flask\\cli.py",
        "matched template: execute a shell command (sim=0.12)"
      ]
    },
    {
      "name": "show_server_banner",
      "description": "execute a shell command. Function `show_server_banner`.",
      "predicted_filename": "src\\flask\\cli.py",
      "predicted_code_snippet": "def show_server_banner(debug: bool, app_import_path: str | None) -> None:\n    \"\"\"Show extra startup messages the first time the server is run,\n    ignoring the reloader.\n    \"\"\"\n    if is_running_from_reloader():\n        return\n\n    if app_import_path is not None:\n        click.echo(f\" * Serving Flask app '{app_import_path}'\")\n\n    if debug is not None:\n        click.echo(f\" * Debug mode: {'on' if debug else 'off'}\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "debug": {
            "type": "boolean",
            "required": true
          },
          "app_import_path": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "debug",
          "app_import_path"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "debug": "boolean",
          "app_import_path": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `show_server_banner` in src\\flask\\cli.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.19,
      "evidence": [
        "function show_server_banner in src\\flask\\cli.py",
        "matched template: execute a shell command (sim=0.17)"
      ]
    },
    {
      "name": "_validate_key",
      "description": "validate and sanitize user input. Function `_validate_key`.",
      "predicted_filename": "src\\flask\\cli.py",
      "predicted_code_snippet": "def _validate_key(ctx: click.Context, param: click.Parameter, value: t.Any) -> t.Any:\n    \"\"\"The ``--key`` option must be specified when ``--cert`` is a file.\n    Modifies the ``cert`` param to be a ``(cert, key)`` pair if needed.\n    \"\"\"\n    cert = ctx.params.get(\"cert\")\n    is_adhoc = cert == \"adhoc\"\n\n    try:\n        import ssl\n    except ImportError:\n        is_context = False\n    else:\n        is_context = isinstance(cert, ssl.SSLContext)\n\n    if value is not None:\n        if is_adhoc:\n            raise click.BadParameter(\n                'When \"--cert\" is \"adhoc\", \"--key\" is not used.', ctx, param\n            )\n\n        if is_context:\n            raise click.BadParameter(\n                'When \"--cert\" is an SSLContext object, \"--key\" is not used.',\n                ctx,\n                param,\n            )\n\n        if not cert:\n            raise click.BadParameter('\"--cert\" must also be specified.', ctx, param)\n\n        ctx.params[\"cert\"] = cert, value\n\n    else:\n        if cert and not (is_adhoc or is_context):\n            raise click.BadParameter('Required when using \"--cert\".', ctx, param)\n\n    return value",
      "input_schema": {
        "type": "object",
        "properties": {
          "ctx": {
            "type": "string",
            "required": true
          },
          "param": {
            "type": "string",
            "required": true
          },
          "value": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "ctx",
          "param",
          "value"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "ctx": "string",
          "param": "string",
          "value": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `_validate_key` in src\\flask\\cli.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.22,
      "evidence": [
        "function _validate_key in src\\flask\\cli.py",
        "matched template: validate and sanitize user input (sim=0.26)"
      ]
    },
    {
      "name": "run_command",
      "description": "execute a shell command. Function `run_command`.",
      "predicted_filename": "src\\flask\\cli.py",
      "predicted_code_snippet": "def run_command(\n    info: ScriptInfo,\n    host: str,\n    port: int,\n    reload: bool,\n    debugger: bool,\n    with_threads: bool,\n    cert: ssl.SSLContext | tuple[str, str | None] | t.Literal[\"adhoc\"] | None,\n    extra_files: list[str] | None,\n    exclude_patterns: list[str] | None,\n) -> None:\n    \"\"\"Run a local development server.\n\n    This server is for development purposes only. It does not provide\n    the stability, security, or performance of production WSGI servers.\n\n    The reloader and debugger are enabled by default with the '--debug'\n    option.\n    \"\"\"\n    try:\n        app: WSGIApplication = info.load_app()  # pyright: ignore\n    except Exception as e:\n        if is_running_from_reloader():\n            # When reloading, print out the error immediately, but raise\n            # it later so the debugger or server can handle it.\n            traceback.print_exc()\n            err = e\n\n            def app(\n                environ: WSGIEnvironment, start_response: StartResponse\n            ) -> cabc.Iterable[bytes]:\n                raise err from None\n\n        else:\n            # When not reloading, raise the error immediately so the\n            # command fails.\n            raise e from None\n\n    debug = get_debug_flag()\n\n    if reload is None:\n        reload = debug\n\n    if debugger is None:\n        debugger = debug\n\n    show_server_banner(debug, info.app_import_path)\n\n    run_simple(\n        host,\n        port,\n        app,\n        use_reloader=reload,\n        use_debugger=debugger,\n        threaded=with_threads,\n        ssl_context=cert,\n        extra_files=extra_files,\n        exclude_patterns=exclude_patterns,\n    )",
      "input_schema": {
        "type": "object",
        "properties": {
          "info": {
            "type": "string",
            "required": true
          },
          "host": {
            "type": "string",
            "required": true
          },
          "port": {
            "type": "integer",
            "required": true
          },
          "reload": {
            "type": "boolean",
            "required": true
          },
          "debugger": {
            "type": "boolean",
            "required": true
          },
          "with_threads": {
            "type": "boolean",
            "required": true
          },
          "cert": {
            "type": "string",
            "required": true
          },
          "extra_files": {
            "type": "string",
            "required": true
          },
          "exclude_patterns": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "info",
          "host",
          "port",
          "reload",
          "debugger",
          "with_threads",
          "cert",
          "extra_files",
          "exclude_patterns"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "info": "string",
          "host": "string",
          "port": "integer",
          "reload": "boolean",
          "debugger": "boolean",
          "with_threads": "boolean",
          "cert": "string",
          "extra_files": "string",
          "exclude_patterns": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `run_command` in src\\flask\\cli.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.19,
      "evidence": [
        "function run_command in src\\flask\\cli.py",
        "matched template: execute a shell command (sim=0.18)"
      ]
    },
    {
      "name": "shell_command",
      "description": "execute a shell command. Function `shell_command`.",
      "predicted_filename": "src\\flask\\cli.py",
      "predicted_code_snippet": "def shell_command() -> None:\n    \"\"\"Run an interactive Python shell in the context of a given\n    Flask application.  The application will populate the default\n    namespace of this shell according to its configuration.\n\n    This is useful for executing small snippets of management code\n    without having to manually configure the application.\n    \"\"\"\n    import code\n\n    banner = (\n        f\"Python {sys.version} on {sys.platform}\\n\"\n        f\"App: {current_app.import_name}\\n\"\n        f\"Instance: {current_app.instance_path}\"\n    )\n    ctx: dict[str, t.Any] = {}\n\n    # Support the regular Python interpreter startup script if someone\n    # is using it.\n    startup = os.environ.get(\"PYTHONSTARTUP\")\n    if startup and os.path.isfile(startup):\n        with open(startup) as f:\n            eval(compile(f.read(), startup, \"exec\"), ctx)\n\n    ctx.update(current_app.make_shell_context())\n\n    # Site, customize, or startup script can set a hook to call when\n    # entering interactive mode. The default one sets up readline with\n    # tab and history completion.\n    interactive_hook = getattr(sys, \"__interactivehook__\", None)\n\n    if interactive_hook is not None:\n        try:\n            import readline\n            from rlcompleter import Completer\n        except ImportError:\n            pass\n        else:\n            # rlcompleter uses __main__.__dict__ by default, which is\n            # flask.__main__. Use the shell context instead.\n            readline.set_completer(Completer(ctx).complete)\n\n        interactive_hook()\n\n    code.interact(banner=banner, local=ctx)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `shell_command` in src\\flask\\cli.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.29,
      "evidence": [
        "function shell_command in src\\flask\\cli.py",
        "matched template: execute a shell command (sim=0.37)"
      ]
    },
    {
      "name": "routes_command",
      "description": "handle a HTTP route request and return response. Function `routes_command`.",
      "predicted_filename": "src\\flask\\cli.py",
      "predicted_code_snippet": "def routes_command(sort: str, all_methods: bool) -> None:\n    \"\"\"Show all registered routes with endpoints and methods.\"\"\"\n    rules = list(current_app.url_map.iter_rules())\n\n    if not rules:\n        click.echo(\"No routes were registered.\")\n        return\n\n    ignored_methods = set() if all_methods else {\"HEAD\", \"OPTIONS\"}\n    host_matching = current_app.url_map.host_matching\n    has_domain = any(rule.host if host_matching else rule.subdomain for rule in rules)\n    rows = []\n\n    for rule in rules:\n        row = [\n            rule.endpoint,\n            \", \".join(sorted((rule.methods or set()) - ignored_methods)),\n        ]\n\n        if has_domain:\n            row.append((rule.host if host_matching else rule.subdomain) or \"\")\n\n        row.append(rule.rule)\n        rows.append(row)\n\n    headers = [\"Endpoint\", \"Methods\"]\n    sorts = [\"endpoint\", \"methods\"]\n\n    if has_domain:\n        headers.append(\"Host\" if host_matching else \"Subdomain\")\n        sorts.append(\"domain\")\n\n    headers.append(\"Rule\")\n    sorts.append(\"rule\")\n\n    try:\n        rows.sort(key=itemgetter(sorts.index(sort)))\n    except ValueError:\n        pass\n\n    rows.insert(0, headers)\n    widths = [max(len(row[i]) for row in rows) for i in range(len(headers))]\n    rows.insert(1, [\"-\" * w for w in widths])\n    template = \"  \".join(f\"{{{i}:<{w}}}\" for i, w in enumerate(widths))\n\n    for row in rows:\n        click.echo(template.format(*row))",
      "input_schema": {
        "type": "object",
        "properties": {
          "sort": {
            "type": "string",
            "required": true
          },
          "all_methods": {
            "type": "boolean",
            "required": true
          }
        },
        "required": [
          "sort",
          "all_methods"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "sort": "string",
          "all_methods": "boolean"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `routes_command` in src\\flask\\cli.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.25,
      "evidence": [
        "function routes_command in src\\flask\\cli.py",
        "matched template: handle a HTTP route request and return response (sim=0.31)"
      ]
    },
    {
      "name": "main",
      "description": "execute a shell command. Function `main`.",
      "predicted_filename": "src\\flask\\cli.py",
      "predicted_code_snippet": "def main() -> None:\n    cli.main()",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `main` in src\\flask\\cli.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.16,
      "evidence": [
        "function main in src\\flask\\cli.py",
        "matched template: execute a shell command (sim=0.10)"
      ]
    },
    {
      "name": "after_this_request",
      "description": "handle a HTTP route request and return response. Function `after_this_request`.",
      "predicted_filename": "src\\flask\\ctx.py",
      "predicted_code_snippet": "def after_this_request(\n    f: ft.AfterRequestCallable[t.Any],\n) -> ft.AfterRequestCallable[t.Any]:\n    \"\"\"Decorate a function to run after the current request. The behavior is the\n    same as :meth:`.Flask.after_request`, except it only applies to the current\n    request, rather than every request. Therefore, it must be used within a\n    request context, rather than during setup.\n\n    .. code-block:: python\n\n        @app.route(\"/\")\n        def index():\n            @after_this_request\n            def add_header(response):\n                response.headers[\"X-Foo\"] = \"Parachute\"\n                return response\n\n            return \"Hello, World!\"\n\n    .. versionadded:: 0.9\n    \"\"\"\n    ctx = _cv_app.get(None)\n\n    if ctx is None or not ctx.has_request:\n        raise RuntimeError(\n            \"'after_this_request' can only be used when a request\"\n            \" context is active, such as in a view function.\"\n        )\n\n    ctx._after_request_functions.append(f)\n    return f",
      "input_schema": {
        "type": "object",
        "properties": {
          "f": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "f"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "f": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `after_this_request` in src\\flask\\ctx.py",
      "possible_syscalls": [],
      "confidence": 0.31,
      "evidence": [
        "function after_this_request in src\\flask\\ctx.py",
        "matched template: handle a HTTP route request and return response (sim=0.40)"
      ]
    },
    {
      "name": "copy_current_request_context",
      "description": "stream data over websocket. Function `copy_current_request_context`.",
      "predicted_filename": "src\\flask\\ctx.py",
      "predicted_code_snippet": "def copy_current_request_context(f: F) -> F:\n    \"\"\"Decorate a function to run inside the current request context. This can\n    be used when starting a background task, otherwise it will not see the app\n    and request objects that were active in the parent.\n\n    .. warning::\n\n        Due to the following caveats, it is often safer (and simpler) to pass\n        the data you need when starting the task, rather than using this and\n        relying on the context objects.\n\n    In order to avoid execution switching partially though reading data, either\n    read the request body (access ``form``, ``json``, ``data``, etc) before\n    starting the task, or use a lock. This can be an issue when using threading,\n    but shouldn't be an issue when using greenlet/gevent or asyncio.\n\n    If the task will access ``session``, be sure to do so in the parent as well\n    so that the ``Vary: cookie`` header will be set. Modifying ``session`` in\n    the task should be avoided, as it may execute after the response cookie has\n    already been written.\n\n    .. code-block:: python\n\n        import gevent\n        from flask import copy_current_request_context\n\n        @app.route('/')\n        def index():\n            @copy_current_request_context\n            def do_some_work():\n                # do some work here, it can access flask.request or\n                # flask.session like you would otherwise in the view function.\n                ...\n            gevent.spawn(do_some_work)\n            return 'Regular response'\n\n    .. versionadded:: 0.10\n    \"\"\"\n    ctx = _cv_app.get(None)\n\n    if ctx is None:\n        raise RuntimeError(\n            \"'copy_current_request_context' can only be used when a\"\n            \" request context is active, such as in a view function.\"\n        )\n\n    ctx = ctx.copy()\n\n    def wrapper(*args: t.Any, **kwargs: t.Any) -> t.Any:\n        with ctx:\n            return ctx.app.ensure_sync(f)(*args, **kwargs)\n\n    return update_wrapper(wrapper, f)",
      "input_schema": {
        "type": "object",
        "properties": {
          "f": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "f"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "f": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `copy_current_request_context` in src\\flask\\ctx.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function copy_current_request_context in src\\flask\\ctx.py",
        "matched template: stream data over websocket (sim=0.25)"
      ]
    },
    {
      "name": "has_request_context",
      "description": "handle a HTTP route request and return response. Function `has_request_context`.",
      "predicted_filename": "src\\flask\\ctx.py",
      "predicted_code_snippet": "def has_request_context() -> bool:\n    \"\"\"Test if an app context is active and if it has request information.\n\n    .. code-block:: python\n\n        from flask import has_request_context, request\n\n        if has_request_context():\n            remote_addr = request.remote_addr\n\n    If a request context is active, the :data:`.request` and :data:`.session`\n    context proxies will available and ``True``, otherwise ``False``. You can\n    use that to test the data you use, rather than using this function.\n\n    .. code-block:: python\n\n        from flask import request\n\n        if request:\n            remote_addr = request.remote_addr\n\n    .. versionadded:: 0.7\n    \"\"\"\n    return (ctx := _cv_app.get(None)) is not None and ctx.has_request",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "boolean"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "boolean"
        }
      },
      "explanation": "Detected Python function `has_request_context` in src\\flask\\ctx.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function has_request_context in src\\flask\\ctx.py",
        "matched template: handle a HTTP route request and return response (sim=0.25)"
      ]
    },
    {
      "name": "has_app_context",
      "description": "cache results to disk or memory. Function `has_app_context`.",
      "predicted_filename": "src\\flask\\ctx.py",
      "predicted_code_snippet": "def has_app_context() -> bool:\n    \"\"\"Test if an app context is active. Unlike :func:`has_request_context`\n    this can be true outside a request, such as in a CLI command.\n\n    .. code-block:: python\n\n        from flask import has_app_context, g\n\n        if has_app_context():\n            g.cached_data = ...\n\n    If an app context is active, the :data:`.g` and :data:`.current_app` context\n    proxies will available and ``True``, otherwise ``False``. You can use that\n    to test the data you use, rather than using this function.\n\n        from flask import g\n\n        if g:\n            g.cached_data = ...\n\n    .. versionadded:: 0.9\n    \"\"\"\n    return _cv_app.get(None) is not None",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "boolean"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "boolean"
        }
      },
      "explanation": "Detected Python function `has_app_context` in src\\flask\\ctx.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function has_app_context in src\\flask\\ctx.py",
        "matched template: cache results to disk or memory (sim=0.21)"
      ]
    },
    {
      "name": "__getattr__",
      "description": "handle a HTTP route request and return response. Function `__getattr__`.",
      "predicted_filename": "src\\flask\\ctx.py",
      "predicted_code_snippet": "def __getattr__(name: str) -> t.Any:\n    import warnings\n\n    if name == \"RequestContext\":\n        warnings.warn(\n            \"'RequestContext' has merged with 'AppContext', and will be removed\"\n            \" in Flask 4.0. Use 'AppContext' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return AppContext\n\n    raise AttributeError(name)",
      "input_schema": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "name"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "name": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `__getattr__` in src\\flask\\ctx.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function __getattr__ in src\\flask\\ctx.py",
        "matched template: handle a HTTP route request and return response (sim=0.17)"
      ]
    },
    {
      "name": "attach_enctype_error_multidict",
      "description": "make an HTTP request to an external API. Function `attach_enctype_error_multidict`.",
      "predicted_filename": "src\\flask\\debughelpers.py",
      "predicted_code_snippet": "def attach_enctype_error_multidict(request: Request) -> None:\n    \"\"\"Patch ``request.files.__getitem__`` to raise a descriptive error\n    about ``enctype=multipart/form-data``.\n\n    :param request: The request to patch.\n    :meta private:\n    \"\"\"\n    oldcls = request.files.__class__\n\n    class newcls(oldcls):  # type: ignore[valid-type, misc]\n        def __getitem__(self, key: str) -> t.Any:\n            try:\n                return super().__getitem__(key)\n            except KeyError as e:\n                if key not in request.form:\n                    raise\n\n                raise DebugFilesKeyError(request, key).with_traceback(\n                    e.__traceback__\n                ) from None\n\n    newcls.__name__ = oldcls.__name__\n    newcls.__module__ = oldcls.__module__\n    request.files.__class__ = newcls",
      "input_schema": {
        "type": "object",
        "properties": {
          "request": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "request"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "request": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `attach_enctype_error_multidict` in src\\flask\\debughelpers.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function attach_enctype_error_multidict in src\\flask\\debughelpers.py",
        "matched template: make an HTTP request to an external API (sim=0.15)"
      ]
    },
    {
      "name": "_dump_loader_info",
      "description": "compute cryptographic hash of input data. Function `_dump_loader_info`.",
      "predicted_filename": "src\\flask\\debughelpers.py",
      "predicted_code_snippet": "def _dump_loader_info(loader: BaseLoader) -> t.Iterator[str]:\n    yield f\"class: {type(loader).__module__}.{type(loader).__name__}\"\n    for key, value in sorted(loader.__dict__.items()):\n        if key.startswith(\"_\"):\n            continue\n        if isinstance(value, (tuple, list)):\n            if not all(isinstance(x, str) for x in value):\n                continue\n            yield f\"{key}:\"\n            for item in value:\n                yield f\"  - {item}\"\n            continue\n        elif not isinstance(value, (str, int, float, bool)):\n            continue\n        yield f\"{key}: {value!r}\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "loader": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "loader"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "loader": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `_dump_loader_info` in src\\flask\\debughelpers.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function _dump_loader_info in src\\flask\\debughelpers.py",
        "matched template: compute cryptographic hash of input data (sim=0.24)"
      ]
    },
    {
      "name": "explain_template_loading_attempts",
      "description": "validate and sanitize user input. Function `explain_template_loading_attempts`.",
      "predicted_filename": "src\\flask\\debughelpers.py",
      "predicted_code_snippet": "def explain_template_loading_attempts(\n    app: App,\n    template: str,\n    attempts: list[\n        tuple[\n            BaseLoader,\n            Scaffold,\n            tuple[str, str | None, t.Callable[[], bool] | None] | None,\n        ]\n    ],\n) -> None:\n    \"\"\"This should help developers understand what failed\"\"\"\n    info = [f\"Locating template {template!r}:\"]\n    total_found = 0\n    blueprint = None\n\n    if (ctx := _cv_app.get(None)) is not None and ctx.has_request:\n        blueprint = ctx.request.blueprint\n\n    for idx, (loader, srcobj, triple) in enumerate(attempts):\n        if isinstance(srcobj, App):\n            src_info = f\"application {srcobj.import_name!r}\"\n        elif isinstance(srcobj, Blueprint):\n            src_info = f\"blueprint {srcobj.name!r} ({srcobj.import_name})\"\n        else:\n            src_info = repr(srcobj)\n\n        info.append(f\"{idx + 1:5}: trying loader of {src_info}\")\n\n        for line in _dump_loader_info(loader):\n            info.append(f\"       {line}\")\n\n        if triple is None:\n            detail = \"no match\"\n        else:\n            detail = f\"found ({triple[1] or '<string>'!r})\"\n            total_found += 1\n        info.append(f\"       -> {detail}\")\n\n    seems_fishy = False\n    if total_found == 0:\n        info.append(\"Error: the template could not be found.\")\n        seems_fishy = True\n    elif total_found > 1:\n        info.append(\"Warning: multiple loaders returned a match for the template.\")\n        seems_fishy = True\n\n    if blueprint is not None and seems_fishy:\n        info.append(\n            \"  The template was looked up from an endpoint that belongs\"\n            f\" to the blueprint {blueprint!r}.\"\n        )\n        info.append(\"  Maybe you did not place a template in the right folder?\")\n        info.append(\"  See https://flask.palletsprojects.com/blueprints/#templates\")\n\n    app.logger.info(\"\\n\".join(info))",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "template": {
            "type": "string",
            "required": true
          },
          "attempts": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "template",
          "attempts"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "template": "string",
          "attempts": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `explain_template_loading_attempts` in src\\flask\\debughelpers.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function explain_template_loading_attempts in src\\flask\\debughelpers.py",
        "matched template: validate and sanitize user input (sim=0.13)"
      ]
    },
    {
      "name": "__getattr__",
      "description": "handle a HTTP route request and return response. Function `__getattr__`.",
      "predicted_filename": "src\\flask\\globals.py",
      "predicted_code_snippet": "def __getattr__(name: str) -> t.Any:\n    import warnings\n\n    if name == \"request_ctx\":\n        warnings.warn(\n            \"'request_ctx' has merged with 'app_ctx', and will be removed\"\n            \" in Flask 4.0. Use 'app_ctx' instead.\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        return app_ctx\n\n    raise AttributeError(name)",
      "input_schema": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "name"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "name": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `__getattr__` in src\\flask\\globals.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function __getattr__ in src\\flask\\globals.py",
        "matched template: handle a HTTP route request and return response (sim=0.15)"
      ]
    },
    {
      "name": "get_debug_flag",
      "description": "send an email notification. Function `get_debug_flag`.",
      "predicted_filename": "src\\flask\\helpers.py",
      "predicted_code_snippet": "def get_debug_flag() -> bool:\n    \"\"\"Get whether debug mode should be enabled for the app, indicated by the\n    :envvar:`FLASK_DEBUG` environment variable. The default is ``False``.\n    \"\"\"\n    val = os.environ.get(\"FLASK_DEBUG\")\n    return bool(val and val.lower() not in {\"0\", \"false\", \"no\"})",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "boolean"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "boolean"
        }
      },
      "explanation": "Detected Python function `get_debug_flag` in src\\flask\\helpers.py",
      "possible_syscalls": [],
      "confidence": 0.16,
      "evidence": [
        "function get_debug_flag in src\\flask\\helpers.py",
        "matched template: send an email notification (sim=0.10)"
      ]
    },
    {
      "name": "get_load_dotenv",
      "description": "execute a shell command. Function `get_load_dotenv`.",
      "predicted_filename": "src\\flask\\helpers.py",
      "predicted_code_snippet": "def get_load_dotenv(default: bool = True) -> bool:\n    \"\"\"Get whether the user has disabled loading default dotenv files by\n    setting :envvar:`FLASK_SKIP_DOTENV`. The default is ``True``, load\n    the files.\n\n    :param default: What to return if the env var isn't set.\n    \"\"\"\n    val = os.environ.get(\"FLASK_SKIP_DOTENV\")\n\n    if not val:\n        return default\n\n    return val.lower() in (\"0\", \"false\", \"no\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "default": {
            "type": "boolean",
            "required": false
          }
        },
        "required": []
      },
      "output_schema": {
        "type": "boolean"
      },
      "payload_shape": {
        "request": {
          "default": "boolean"
        },
        "response": {
          "type": "boolean"
        }
      },
      "explanation": "Detected Python function `get_load_dotenv` in src\\flask\\helpers.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function get_load_dotenv in src\\flask\\helpers.py",
        "matched template: execute a shell command (sim=0.13)"
      ]
    },
    {
      "name": "stream_with_context",
      "description": "stream data over websocket. Function `stream_with_context`.",
      "predicted_filename": "src\\flask\\helpers.py",
      "predicted_code_snippet": "def stream_with_context(\n    generator_or_function: t.Iterator[t.AnyStr],\n) -> t.Iterator[t.AnyStr]: ...",
      "input_schema": {
        "type": "object",
        "properties": {
          "generator_or_function": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "generator_or_function"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "generator_or_function": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `stream_with_context` in src\\flask\\helpers.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function stream_with_context in src\\flask\\helpers.py",
        "matched template: stream data over websocket (sim=0.26)"
      ]
    },
    {
      "name": "stream_with_context",
      "description": "stream data over websocket. Function `stream_with_context`.",
      "predicted_filename": "src\\flask\\helpers.py",
      "predicted_code_snippet": "def stream_with_context(\n    generator_or_function: t.Callable[..., t.Iterator[t.AnyStr]],\n) -> t.Callable[[t.Iterator[t.AnyStr]], t.Iterator[t.AnyStr]]: ...",
      "input_schema": {
        "type": "object",
        "properties": {
          "generator_or_function": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "generator_or_function"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "generator_or_function": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `stream_with_context` in src\\flask\\helpers.py",
      "possible_syscalls": [],
      "confidence": 0.26,
      "evidence": [
        "function stream_with_context in src\\flask\\helpers.py",
        "matched template: stream data over websocket (sim=0.33)"
      ]
    },
    {
      "name": "stream_with_context",
      "description": "stream data over websocket. Function `stream_with_context`.",
      "predicted_filename": "src\\flask\\helpers.py",
      "predicted_code_snippet": "def stream_with_context(\n    generator_or_function: t.Iterator[t.AnyStr] | t.Callable[..., t.Iterator[t.AnyStr]],\n) -> t.Iterator[t.AnyStr] | t.Callable[[t.Iterator[t.AnyStr]], t.Iterator[t.AnyStr]]:\n    \"\"\"Wrap a response generator function so that it runs inside the current\n    request context. This keeps :data:`.request`, :data:`.session`, and :data:`.g`\n    available, even though at the point the generator runs the request context\n    will typically have ended.\n\n    Use it as a decorator on a generator function:\n\n    .. code-block:: python\n\n        from flask import stream_with_context, request, Response\n\n        @app.get(\"/stream\")\n        def streamed_response():\n            @stream_with_context\n            def generate():\n                yield \"Hello \"\n                yield request.args[\"name\"]\n                yield \"!\"\n\n            return Response(generate())\n\n    Or use it as a wrapper around a created generator:\n\n    .. code-block:: python\n\n        from flask import stream_with_context, request, Response\n\n        @app.get(\"/stream\")\n        def streamed_response():\n            def generate():\n                yield \"Hello \"\n                yield request.args[\"name\"]\n                yield \"!\"\n\n            return Response(stream_with_context(generate()))\n\n    .. versionadded:: 0.9\n    \"\"\"\n    try:\n        gen = iter(generator_or_function)  # type: ignore[arg-type]\n    except TypeError:\n\n        def decorator(*args: t.Any, **kwargs: t.Any) -> t.Any:\n            gen = generator_or_function(*args, **kwargs)  # type: ignore[operator]\n            return stream_with_context(gen)\n\n        return update_wrapper(decorator, generator_or_function)  # type: ignore[arg-type]\n\n    def generator() -> t.Iterator[t.AnyStr]:\n        if (ctx := _cv_app.get(None)) is None:\n            raise RuntimeError(\n                \"'stream_with_context' can only be used when a request\"\n                \" context is active, such as in a view function.\"\n            )\n\n        with ctx:\n            yield None  # type: ignore[misc]\n\n            try:\n                yield from gen\n            finally:\n                # Clean up in case the user wrapped a WSGI iterator.\n                if hasattr(gen, \"close\"):\n                    gen.close()\n\n    # Execute the generator to the sentinel value. This captures the current\n    # context and pushes it to preserve it. Further iteration will yield from\n    # the original iterator.\n    wrapped_g = generator()\n    next(wrapped_g)\n    return wrapped_g",
      "input_schema": {
        "type": "object",
        "properties": {
          "generator_or_function": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "generator_or_function"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "generator_or_function": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `stream_with_context` in src\\flask\\helpers.py",
      "possible_syscalls": [],
      "confidence": 0.25,
      "evidence": [
        "function stream_with_context in src\\flask\\helpers.py",
        "matched template: stream data over websocket (sim=0.31)"
      ]
    },
    {
      "name": "make_response",
      "description": "handle a HTTP route request and return response. Function `make_response`.",
      "predicted_filename": "src\\flask\\helpers.py",
      "predicted_code_snippet": "def make_response(*args: t.Any) -> Response:\n    \"\"\"Sometimes it is necessary to set additional headers in a view.  Because\n    views do not have to return response objects but can return a value that\n    is converted into a response object by Flask itself, it becomes tricky to\n    add headers to it.  This function can be called instead of using a return\n    and you will get a response object which you can use to attach headers.\n\n    If view looked like this and you want to add a new header::\n\n        def index():\n            return render_template('index.html', foo=42)\n\n    You can now do something like this::\n\n        def index():\n            response = make_response(render_template('index.html', foo=42))\n            response.headers['X-Parachutes'] = 'parachutes are cool'\n            return response\n\n    This function accepts the very same arguments you can return from a\n    view function.  This for example creates a response with a 404 error\n    code::\n\n        response = make_response(render_template('not_found.html'), 404)\n\n    The other use case of this function is to force the return value of a\n    view function into a response which is helpful with view\n    decorators::\n\n        response = make_response(view_function())\n        response.headers['X-Parachutes'] = 'parachutes are cool'\n\n    Internally this function does the following things:\n\n    -   if no arguments are passed, it creates a new response argument\n    -   if one argument is passed, :meth:`flask.Flask.make_response`\n        is invoked with it.\n    -   if more than one argument is passed, the arguments are passed\n        to the :meth:`flask.Flask.make_response` function as tuple.\n\n    .. versionadded:: 0.6\n    \"\"\"\n    if not args:\n        return current_app.response_class()\n    if len(args) == 1:\n        args = args[0]\n    return current_app.make_response(args)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `make_response` in src\\flask\\helpers.py",
      "possible_syscalls": [],
      "confidence": 0.31,
      "evidence": [
        "function make_response in src\\flask\\helpers.py",
        "matched template: handle a HTTP route request and return response (sim=0.41)"
      ]
    },
    {
      "name": "url_for",
      "description": "make an HTTP request to an external API. Function `url_for`.",
      "predicted_filename": "src\\flask\\helpers.py",
      "predicted_code_snippet": "def url_for(\n    endpoint: str,\n    *,\n    _anchor: str | None = None,\n    _method: str | None = None,\n    _scheme: str | None = None,\n    _external: bool | None = None,\n    **values: t.Any,\n) -> str:\n    \"\"\"Generate a URL to the given endpoint with the given values.\n\n    This requires an active request or application context, and calls\n    :meth:`current_app.url_for() <flask.Flask.url_for>`. See that method\n    for full documentation.\n\n    :param endpoint: The endpoint name associated with the URL to\n        generate. If this starts with a ``.``, the current blueprint\n        name (if any) will be used.\n    :param _anchor: If given, append this as ``#anchor`` to the URL.\n    :param _method: If given, generate the URL associated with this\n        method for the endpoint.\n    :param _scheme: If given, the URL will have this scheme if it is\n        external.\n    :param _external: If given, prefer the URL to be internal (False) or\n        require it to be external (True). External URLs include the\n        scheme and domain. When not in an active request, URLs are\n        external by default.\n    :param values: Values to use for the variable parts of the URL rule.\n        Unknown keys are appended as query string arguments, like\n        ``?a=b&c=d``.\n\n    .. versionchanged:: 2.2\n        Calls ``current_app.url_for``, allowing an app to override the\n        behavior.\n\n    .. versionchanged:: 0.10\n       The ``_scheme`` parameter was added.\n\n    .. versionchanged:: 0.9\n       The ``_anchor`` and ``_method`` parameters were added.\n\n    .. versionchanged:: 0.9\n       Calls ``app.handle_url_build_error`` on build errors.\n    \"\"\"\n    return current_app.url_for(\n        endpoint,\n        _anchor=_anchor,\n        _method=_method,\n        _scheme=_scheme,\n        _external=_external,\n        **values,\n    )",
      "input_schema": {
        "type": "object",
        "properties": {
          "endpoint": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "endpoint"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "endpoint": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `url_for` in src\\flask\\helpers.py",
      "possible_syscalls": [],
      "confidence": 0.26,
      "evidence": [
        "function url_for in src\\flask\\helpers.py",
        "matched template: make an HTTP request to an external API (sim=0.32)"
      ]
    },
    {
      "name": "redirect",
      "description": "handle a HTTP route request and return response. Function `redirect`.",
      "predicted_filename": "src\\flask\\helpers.py",
      "predicted_code_snippet": "def redirect(\n    location: str, code: int = 302, Response: type[BaseResponse] | None = None\n) -> BaseResponse:\n    \"\"\"Create a redirect response object.\n\n    If :data:`~flask.current_app` is available, it will use its\n    :meth:`~flask.Flask.redirect` method, otherwise it will use\n    :func:`werkzeug.utils.redirect`.\n\n    :param location: The URL to redirect to.\n    :param code: The status code for the redirect.\n    :param Response: The response class to use. Not used when\n        ``current_app`` is active, which uses ``app.response_class``.\n\n    .. versionadded:: 2.2\n        Calls ``current_app.redirect`` if available instead of always\n        using Werkzeug's default ``redirect``.\n    \"\"\"\n    if (ctx := _cv_app.get(None)) is not None:\n        return ctx.app.redirect(location, code=code)\n\n    return _wz_redirect(location, code=code, Response=Response)",
      "input_schema": {
        "type": "object",
        "properties": {
          "location": {
            "type": "string",
            "required": true
          },
          "code": {
            "type": "integer",
            "required": false
          },
          "Response": {
            "type": "string",
            "required": false
          }
        },
        "required": [
          "location"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "location": "string",
          "code": "integer",
          "Response": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `redirect` in src\\flask\\helpers.py",
      "possible_syscalls": [],
      "confidence": 0.27,
      "evidence": [
        "function redirect in src\\flask\\helpers.py",
        "matched template: handle a HTTP route request and return response (sim=0.35)"
      ]
    },
    {
      "name": "abort",
      "description": "handle a HTTP route request and return response. Function `abort`.",
      "predicted_filename": "src\\flask\\helpers.py",
      "predicted_code_snippet": "def abort(code: int | BaseResponse, *args: t.Any, **kwargs: t.Any) -> t.NoReturn:\n    \"\"\"Raise an :exc:`~werkzeug.exceptions.HTTPException` for the given\n    status code.\n\n    If :data:`~flask.current_app` is available, it will call its\n    :attr:`~flask.Flask.aborter` object, otherwise it will use\n    :func:`werkzeug.exceptions.abort`.\n\n    :param code: The status code for the exception, which must be\n        registered in ``app.aborter``.\n    :param args: Passed to the exception.\n    :param kwargs: Passed to the exception.\n\n    .. versionadded:: 2.2\n        Calls ``current_app.aborter`` if available instead of always\n        using Werkzeug's default ``abort``.\n    \"\"\"\n    if (ctx := _cv_app.get(None)) is not None:\n        ctx.app.aborter(code, *args, **kwargs)\n\n    _wz_abort(code, *args, **kwargs)",
      "input_schema": {
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "required": true
          }
        },
        "required": [
          "code"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "code": "integer"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `abort` in src\\flask\\helpers.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function abort in src\\flask\\helpers.py",
        "matched template: handle a HTTP route request and return response (sim=0.18)"
      ]
    },
    {
      "name": "get_template_attribute",
      "description": "write data to a file. Function `get_template_attribute`.",
      "predicted_filename": "src\\flask\\helpers.py",
      "predicted_code_snippet": "def get_template_attribute(template_name: str, attribute: str) -> t.Any:\n    \"\"\"Loads a macro (or variable) a template exports.  This can be used to\n    invoke a macro from within Python code.  If you for example have a\n    template named :file:`_cider.html` with the following contents:\n\n    .. sourcecode:: html+jinja\n\n       {% macro hello(name) %}Hello {{ name }}!{% endmacro %}\n\n    You can access this from Python code like this::\n\n        hello = get_template_attribute('_cider.html', 'hello')\n        return hello('World')\n\n    .. versionadded:: 0.2\n\n    :param template_name: the name of the template\n    :param attribute: the name of the variable of macro to access\n    \"\"\"\n    return getattr(current_app.jinja_env.get_template(template_name).module, attribute)",
      "input_schema": {
        "type": "object",
        "properties": {
          "template_name": {
            "type": "string",
            "required": true
          },
          "attribute": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "template_name",
          "attribute"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "template_name": "string",
          "attribute": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `get_template_attribute` in src\\flask\\helpers.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function get_template_attribute in src\\flask\\helpers.py",
        "matched template: write data to a file (sim=0.15)"
      ]
    },
    {
      "name": "flash",
      "description": "stream data over websocket. Function `flash`.",
      "predicted_filename": "src\\flask\\helpers.py",
      "predicted_code_snippet": "def flash(message: str, category: str = \"message\") -> None:\n    \"\"\"Flashes a message to the next request.  In order to remove the\n    flashed message from the session and to display it to the user,\n    the template has to call :func:`get_flashed_messages`.\n\n    .. versionchanged:: 0.3\n       `category` parameter added.\n\n    :param message: the message to be flashed.\n    :param category: the category for the message.  The following values\n                     are recommended: ``'message'`` for any kind of message,\n                     ``'error'`` for errors, ``'info'`` for information\n                     messages and ``'warning'`` for warnings.  However any\n                     kind of string can be used as category.\n    \"\"\"\n    # Original implementation:\n    #\n    #     session.setdefault('_flashes', []).append((category, message))\n    #\n    # This assumed that changes made to mutable structures in the session are\n    # always in sync with the session object, which is not true for session\n    # implementations that use external storage for keeping their keys/values.\n    flashes = session.get(\"_flashes\", [])\n    flashes.append((category, message))\n    session[\"_flashes\"] = flashes\n    app = current_app._get_current_object()\n    message_flashed.send(\n        app,\n        _async_wrapper=app.ensure_sync,\n        message=message,\n        category=category,\n    )",
      "input_schema": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "required": true
          },
          "category": {
            "type": "string",
            "required": false
          }
        },
        "required": [
          "message"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "message": "string",
          "category": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `flash` in src\\flask\\helpers.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function flash in src\\flask\\helpers.py",
        "matched template: stream data over websocket (sim=0.21)"
      ]
    },
    {
      "name": "get_flashed_messages",
      "description": "stream data over websocket. Function `get_flashed_messages`.",
      "predicted_filename": "src\\flask\\helpers.py",
      "predicted_code_snippet": "def get_flashed_messages(\n    with_categories: bool = False, category_filter: t.Iterable[str] = ()\n) -> list[str] | list[tuple[str, str]]:\n    \"\"\"Pulls all flashed messages from the session and returns them.\n    Further calls in the same request to the function will return\n    the same messages.  By default just the messages are returned,\n    but when `with_categories` is set to ``True``, the return value will\n    be a list of tuples in the form ``(category, message)`` instead.\n\n    Filter the flashed messages to one or more categories by providing those\n    categories in `category_filter`.  This allows rendering categories in\n    separate html blocks.  The `with_categories` and `category_filter`\n    arguments are distinct:\n\n    * `with_categories` controls whether categories are returned with message\n      text (``True`` gives a tuple, where ``False`` gives just the message text).\n    * `category_filter` filters the messages down to only those matching the\n      provided categories.\n\n    See :doc:`/patterns/flashing` for examples.\n\n    .. versionchanged:: 0.3\n       `with_categories` parameter added.\n\n    .. versionchanged:: 0.9\n        `category_filter` parameter added.\n\n    :param with_categories: set to ``True`` to also receive categories.\n    :param category_filter: filter of categories to limit return values.  Only\n                            categories in the list will be returned.\n    \"\"\"\n    flashes = app_ctx._flashes\n    if flashes is None:\n        flashes = session.pop(\"_flashes\") if \"_flashes\" in session else []\n        app_ctx._flashes = flashes\n    if category_filter:\n        flashes = list(filter(lambda f: f[0] in category_filter, flashes))\n    if not with_categories:\n        return [x[1] for x in flashes]\n    return flashes",
      "input_schema": {
        "type": "object",
        "properties": {
          "with_categories": {
            "type": "boolean",
            "required": false
          },
          "category_filter": {
            "type": "string",
            "required": false
          }
        },
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "with_categories": "boolean",
          "category_filter": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `get_flashed_messages` in src\\flask\\helpers.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function get_flashed_messages in src\\flask\\helpers.py",
        "matched template: stream data over websocket (sim=0.17)"
      ]
    },
    {
      "name": "_prepare_send_file_kwargs",
      "description": "write data to a file. Function `_prepare_send_file_kwargs`.",
      "predicted_filename": "src\\flask\\helpers.py",
      "predicted_code_snippet": "def _prepare_send_file_kwargs(**kwargs: t.Any) -> dict[str, t.Any]:\n    ctx = app_ctx._get_current_object()\n\n    if kwargs.get(\"max_age\") is None:\n        kwargs[\"max_age\"] = ctx.app.get_send_file_max_age\n\n    kwargs.update(\n        environ=ctx.request.environ,\n        use_x_sendfile=ctx.app.config[\"USE_X_SENDFILE\"],\n        response_class=ctx.app.response_class,\n        _root_path=ctx.app.root_path,\n    )\n    return kwargs",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `_prepare_send_file_kwargs` in src\\flask\\helpers.py",
      "possible_syscalls": [],
      "confidence": 0.25,
      "evidence": [
        "function _prepare_send_file_kwargs in src\\flask\\helpers.py",
        "matched template: write data to a file (sim=0.31)"
      ]
    },
    {
      "name": "send_file",
      "description": "write data to a file. Function `send_file`.",
      "predicted_filename": "src\\flask\\helpers.py",
      "predicted_code_snippet": "def send_file(\n    path_or_file: os.PathLike[t.AnyStr] | str | t.IO[bytes],\n    mimetype: str | None = None,\n    as_attachment: bool = False,\n    download_name: str | None = None,\n    conditional: bool = True,\n    etag: bool | str = True,\n    last_modified: datetime | int | float | None = None,\n    max_age: None | (int | t.Callable[[str | None], int | None]) = None,\n) -> Response:\n    \"\"\"Send the contents of a file to the client.\n\n    The first argument can be a file path or a file-like object. Paths\n    are preferred in most cases because Werkzeug can manage the file and\n    get extra information from the path. Passing a file-like object\n    requires that the file is opened in binary mode, and is mostly\n    useful when building a file in memory with :class:`io.BytesIO`.\n\n    Never pass file paths provided by a user. The path is assumed to be\n    trusted, so a user could craft a path to access a file you didn't\n    intend. Use :func:`send_from_directory` to safely serve\n    user-requested paths from within a directory.\n\n    If the WSGI server sets a ``file_wrapper`` in ``environ``, it is\n    used, otherwise Werkzeug's built-in wrapper is used. Alternatively,\n    if the HTTP server supports ``X-Sendfile``, configuring Flask with\n    ``USE_X_SENDFILE = True`` will tell the server to send the given\n    path, which is much more efficient than reading it in Python.\n\n    :param path_or_file: The path to the file to send, relative to the\n        current working directory if a relative path is given.\n        Alternatively, a file-like object opened in binary mode. Make\n        sure the file pointer is seeked to the start of the data.\n    :param mimetype: The MIME type to send for the file. If not\n        provided, it will try to detect it from the file name.\n    :param as_attachment: Indicate to a browser that it should offer to\n        save the file instead of displaying it.\n    :param download_name: The default name browsers will use when saving\n        the file. Defaults to the passed file name.\n    :param conditional: Enable conditional and range responses based on\n        request headers. Requires passing a file path and ``environ``.\n    :param etag: Calculate an ETag for the file, which requires passing\n        a file path. Can also be a string to use instead.\n    :param last_modified: The last modified time to send for the file,\n        in seconds. If not provided, it will try to detect it from the\n        file path.\n    :param max_age: How long the client should cache the file, in\n        seconds. If set, ``Cache-Control`` will be ``public``, otherwise\n        it will be ``no-cache`` to prefer conditional caching.\n\n    .. versionchanged:: 2.0\n        ``download_name`` replaces the ``attachment_filename``\n        parameter. If ``as_attachment=False``, it is passed with\n        ``Content-Disposition: inline`` instead.\n\n    .. versionchanged:: 2.0\n        ``max_age`` replaces the ``cache_timeout`` parameter.\n        ``conditional`` is enabled and ``max_age`` is not set by\n        default.\n\n    .. versionchanged:: 2.0\n        ``etag`` replaces the ``add_etags`` parameter. It can be a\n        string to use instead of generating one.\n\n    .. versionchanged:: 2.0\n        Passing a file-like object that inherits from\n        :class:`~io.TextIOBase` will raise a :exc:`ValueError` rather\n        than sending an empty file.\n\n    .. versionadded:: 2.0\n        Moved the implementation to Werkzeug. This is now a wrapper to\n        pass some Flask-specific arguments.\n\n    .. versionchanged:: 1.1\n        ``filename`` may be a :class:`~os.PathLike` object.\n\n    .. versionchanged:: 1.1\n        Passing a :class:`~io.BytesIO` object supports range requests.\n\n    .. versionchanged:: 1.0.3\n        Filenames are encoded with ASCII instead of Latin-1 for broader\n        compatibility with WSGI servers.\n\n    .. versionchanged:: 1.0\n        UTF-8 filenames as specified in :rfc:`2231` are supported.\n\n    .. versionchanged:: 0.12\n        The filename is no longer automatically inferred from file\n        objects. If you want to use automatic MIME and etag support,\n        pass a filename via ``filename_or_fp`` or\n        ``attachment_filename``.\n\n    .. versionchanged:: 0.12\n        ``attachment_filename`` is preferred over ``filename`` for MIME\n        detection.\n\n    .. versionchanged:: 0.9\n        ``cache_timeout`` defaults to\n        :meth:`Flask.get_send_file_max_age`.\n\n    .. versionchanged:: 0.7\n        MIME guessing and etag support for file-like objects was\n        removed because it was unreliable. Pass a filename if you are\n        able to, otherwise attach an etag yourself.\n\n    .. versionchanged:: 0.5\n        The ``add_etags``, ``cache_timeout`` and ``conditional``\n        parameters were added. The default behavior is to add etags.\n\n    .. versionadded:: 0.2\n    \"\"\"\n    return werkzeug.utils.send_file(  # type: ignore[return-value]\n        **_prepare_send_file_kwargs(\n            path_or_file=path_or_file,\n            environ=request.environ,\n            mimetype=mimetype,\n            as_attachment=as_attachment,\n            download_name=download_name,\n            conditional=conditional,\n            etag=etag,\n            last_modified=last_modified,\n            max_age=max_age,\n        )\n    )",
      "input_schema": {
        "type": "object",
        "properties": {
          "path_or_file": {
            "type": "string",
            "required": true
          },
          "mimetype": {
            "type": "string",
            "required": false
          },
          "as_attachment": {
            "type": "boolean",
            "required": false
          },
          "download_name": {
            "type": "string",
            "required": false
          },
          "conditional": {
            "type": "boolean",
            "required": false
          },
          "etag": {
            "type": "string",
            "required": false
          },
          "last_modified": {
            "type": "integer",
            "required": false
          },
          "max_age": {
            "type": "string",
            "required": false
          }
        },
        "required": [
          "path_or_file"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "path_or_file": "string",
          "mimetype": "string",
          "as_attachment": "boolean",
          "download_name": "string",
          "conditional": "boolean",
          "etag": "string",
          "last_modified": "integer",
          "max_age": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `send_file` in src\\flask\\helpers.py",
      "possible_syscalls": [],
      "confidence": 0.31,
      "evidence": [
        "function send_file in src\\flask\\helpers.py",
        "matched template: write data to a file (sim=0.39)"
      ]
    },
    {
      "name": "send_from_directory",
      "description": "write data to a file. Function `send_from_directory`.",
      "predicted_filename": "src\\flask\\helpers.py",
      "predicted_code_snippet": "def send_from_directory(\n    directory: os.PathLike[str] | str,\n    path: os.PathLike[str] | str,\n    **kwargs: t.Any,\n) -> Response:\n    \"\"\"Send a file from within a directory using :func:`send_file`.\n\n    .. code-block:: python\n\n        @app.route(\"/uploads/<path:name>\")\n        def download_file(name):\n            return send_from_directory(\n                app.config['UPLOAD_FOLDER'], name, as_attachment=True\n            )\n\n    This is a secure way to serve files from a folder, such as static\n    files or uploads. Uses :func:`~werkzeug.security.safe_join` to\n    ensure the path coming from the client is not maliciously crafted to\n    point outside the specified directory.\n\n    If the final path does not point to an existing regular file,\n    raises a 404 :exc:`~werkzeug.exceptions.NotFound` error.\n\n    :param directory: The directory that ``path`` must be located under,\n        relative to the current application's root path. This *must not*\n        be a value provided by the client, otherwise it becomes insecure.\n    :param path: The path to the file to send, relative to\n        ``directory``.\n    :param kwargs: Arguments to pass to :func:`send_file`.\n\n    .. versionchanged:: 2.0\n        ``path`` replaces the ``filename`` parameter.\n\n    .. versionadded:: 2.0\n        Moved the implementation to Werkzeug. This is now a wrapper to\n        pass some Flask-specific arguments.\n\n    .. versionadded:: 0.5\n    \"\"\"\n    return werkzeug.utils.send_from_directory(  # type: ignore[return-value]\n        directory, path, **_prepare_send_file_kwargs(**kwargs)\n    )",
      "input_schema": {
        "type": "object",
        "properties": {
          "directory": {
            "type": "string",
            "required": true
          },
          "path": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "directory",
          "path"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "directory": "string",
          "path": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `send_from_directory` in src\\flask\\helpers.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function send_from_directory in src\\flask\\helpers.py",
        "matched template: write data to a file (sim=0.26)"
      ]
    },
    {
      "name": "get_root_path",
      "description": "list files in a directory. Function `get_root_path`.",
      "predicted_filename": "src\\flask\\helpers.py",
      "predicted_code_snippet": "def get_root_path(import_name: str) -> str:\n    \"\"\"Find the root path of a package, or the path that contains a\n    module. If it cannot be found, returns the current working\n    directory.\n\n    Not to be confused with the value returned by :func:`find_package`.\n\n    :meta private:\n    \"\"\"\n    # Module already imported and has a file attribute. Use that first.\n    mod = sys.modules.get(import_name)\n\n    if mod is not None and hasattr(mod, \"__file__\") and mod.__file__ is not None:\n        return os.path.dirname(os.path.abspath(mod.__file__))\n\n    # Next attempt: check the loader.\n    try:\n        spec = importlib.util.find_spec(import_name)\n\n        if spec is None:\n            raise ValueError\n    except (ImportError, ValueError):\n        loader = None\n    else:\n        loader = spec.loader\n\n    # Loader does not exist or we're referring to an unloaded main\n    # module or a main module without path (interactive sessions), go\n    # with the current working directory.\n    if loader is None:\n        return os.getcwd()\n\n    if hasattr(loader, \"get_filename\"):\n        filepath = loader.get_filename(import_name)  # pyright: ignore\n    else:\n        # Fall back to imports.\n        __import__(import_name)\n        mod = sys.modules[import_name]\n        filepath = getattr(mod, \"__file__\", None)\n\n        # If we don't have a file path it might be because it is a\n        # namespace package. In this case pick the root path from the\n        # first module that is contained in the package.\n        if filepath is None:\n            raise RuntimeError(\n                \"No root path can be found for the provided module\"\n                f\" {import_name!r}. This can happen because the module\"\n                \" came from an import hook that does not provide file\"\n                \" name information or because it's a namespace package.\"\n                \" In this case the root path needs to be explicitly\"\n                \" provided.\"\n            )\n\n    # filepath is import_name.py for a module, or __init__.py for a package.\n    return os.path.dirname(os.path.abspath(filepath))",
      "input_schema": {
        "type": "object",
        "properties": {
          "import_name": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "import_name"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "import_name": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `get_root_path` in src\\flask\\helpers.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function get_root_path in src\\flask\\helpers.py",
        "matched template: list files in a directory (sim=0.22)"
      ]
    },
    {
      "name": "_split_blueprint_path",
      "description": "write data to a file. Function `_split_blueprint_path`.",
      "predicted_filename": "src\\flask\\helpers.py",
      "predicted_code_snippet": "def _split_blueprint_path(name: str) -> list[str]:\n    out: list[str] = [name]\n\n    if \".\" in name:\n        out.extend(_split_blueprint_path(name.rpartition(\".\")[0]))\n\n    return out",
      "input_schema": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "name"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "name": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `_split_blueprint_path` in src\\flask\\helpers.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function _split_blueprint_path in src\\flask\\helpers.py",
        "matched template: write data to a file (sim=0.19)"
      ]
    },
    {
      "name": "wsgi_errors_stream",
      "description": "stream data over websocket. Function `wsgi_errors_stream`.",
      "predicted_filename": "src\\flask\\logging.py",
      "predicted_code_snippet": "def wsgi_errors_stream() -> t.TextIO:\n    \"\"\"Find the most appropriate error stream for the application. If a request\n    is active, log to ``wsgi.errors``, otherwise use ``sys.stderr``.\n\n    If you configure your own :class:`logging.StreamHandler`, you may want to\n    use this for the stream. If you are using file or dict configuration and\n    can't import this directly, you can refer to it as\n    ``ext://flask.logging.wsgi_errors_stream``.\n    \"\"\"\n    if request:\n        return request.environ[\"wsgi.errors\"]  # type: ignore[no-any-return]\n\n    return sys.stderr",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `wsgi_errors_stream` in src\\flask\\logging.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function wsgi_errors_stream in src\\flask\\logging.py",
        "matched template: stream data over websocket (sim=0.21)"
      ]
    },
    {
      "name": "has_level_handler",
      "description": "handle a HTTP route request and return response. Function `has_level_handler`.",
      "predicted_filename": "src\\flask\\logging.py",
      "predicted_code_snippet": "def has_level_handler(logger: logging.Logger) -> bool:\n    \"\"\"Check if there is a handler in the logging chain that will handle the\n    given logger's :meth:`effective level <~logging.Logger.getEffectiveLevel>`.\n    \"\"\"\n    level = logger.getEffectiveLevel()\n    current = logger\n\n    while current:\n        if any(handler.level <= level for handler in current.handlers):\n            return True\n\n        if not current.propagate:\n            break\n\n        current = current.parent  # type: ignore\n\n    return False",
      "input_schema": {
        "type": "object",
        "properties": {
          "logger": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "logger"
        ]
      },
      "output_schema": {
        "type": "boolean"
      },
      "payload_shape": {
        "request": {
          "logger": "string"
        },
        "response": {
          "type": "boolean"
        }
      },
      "explanation": "Detected Python function `has_level_handler` in src\\flask\\logging.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function has_level_handler in src\\flask\\logging.py",
        "matched template: handle a HTTP route request and return response (sim=0.12)"
      ]
    },
    {
      "name": "create_logger",
      "description": "stream data over websocket. Function `create_logger`.",
      "predicted_filename": "src\\flask\\logging.py",
      "predicted_code_snippet": "def create_logger(app: App) -> logging.Logger:\n    \"\"\"Get the Flask app's logger and configure it if needed.\n\n    The logger name will be the same as\n    :attr:`app.import_name <flask.Flask.name>`.\n\n    When :attr:`~flask.Flask.debug` is enabled, set the logger level to\n    :data:`logging.DEBUG` if it is not set.\n\n    If there is no handler for the logger's effective level, add a\n    :class:`~logging.StreamHandler` for\n    :func:`~flask.logging.wsgi_errors_stream` with a basic format.\n    \"\"\"\n    logger = logging.getLogger(app.name)\n\n    if app.debug and not logger.level:\n        logger.setLevel(logging.DEBUG)\n\n    if not has_level_handler(logger):\n        logger.addHandler(default_handler)\n\n    return logger",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `create_logger` in src\\flask\\logging.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function create_logger in src\\flask\\logging.py",
        "matched template: stream data over websocket (sim=0.17)"
      ]
    },
    {
      "name": "_lazy_sha1",
      "description": "compute cryptographic hash of input data. Function `_lazy_sha1`.",
      "predicted_filename": "src\\flask\\sessions.py",
      "predicted_code_snippet": "def _lazy_sha1(string: bytes = b\"\") -> t.Any:\n    \"\"\"Don't access ``hashlib.sha1`` until runtime. FIPS builds may not include\n    SHA-1, in which case the import and use as a default would fail before the\n    developer can configure something else.\n    \"\"\"\n    return hashlib.sha1(string)",
      "input_schema": {
        "type": "object",
        "properties": {
          "string": {
            "type": "string",
            "required": false
          }
        },
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "string": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `_lazy_sha1` in src\\flask\\sessions.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function _lazy_sha1 in src\\flask\\sessions.py",
        "matched template: compute cryptographic hash of input data (sim=0.27)"
      ]
    },
    {
      "name": "_default_template_ctx_processor",
      "description": "execute a shell command. Function `_default_template_ctx_processor`.",
      "predicted_filename": "src\\flask\\templating.py",
      "predicted_code_snippet": "def _default_template_ctx_processor() -> dict[str, t.Any]:\n    \"\"\"Default template context processor.  Injects `request`,\n    `session` and `g`.\n    \"\"\"\n    ctx = app_ctx._get_current_object()\n    rv: dict[str, t.Any] = {\"g\": ctx.g}\n\n    if ctx.has_request:\n        rv[\"request\"] = ctx.request\n        rv[\"session\"] = ctx.session\n\n    return rv",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `_default_template_ctx_processor` in src\\flask\\templating.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function _default_template_ctx_processor in src\\flask\\templating.py",
        "matched template: execute a shell command (sim=0.17)"
      ]
    },
    {
      "name": "_render",
      "description": "stream data over websocket. Function `_render`.",
      "predicted_filename": "src\\flask\\templating.py",
      "predicted_code_snippet": "def _render(ctx: AppContext, template: Template, context: dict[str, t.Any]) -> str:\n    app = ctx.app\n    app.update_template_context(ctx, context)\n    before_render_template.send(\n        app, _async_wrapper=app.ensure_sync, template=template, context=context\n    )\n    rv = template.render(context)\n    template_rendered.send(\n        app, _async_wrapper=app.ensure_sync, template=template, context=context\n    )\n    return rv",
      "input_schema": {
        "type": "object",
        "properties": {
          "ctx": {
            "type": "string",
            "required": true
          },
          "template": {
            "type": "string",
            "required": true
          },
          "context": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "ctx",
          "template",
          "context"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "ctx": "string",
          "template": "string",
          "context": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `_render` in src\\flask\\templating.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function _render in src\\flask\\templating.py",
        "matched template: stream data over websocket (sim=0.16)"
      ]
    },
    {
      "name": "render_template",
      "description": "execute a shell command. Function `render_template`.",
      "predicted_filename": "src\\flask\\templating.py",
      "predicted_code_snippet": "def render_template(\n    template_name_or_list: str | Template | list[str | Template],\n    **context: t.Any,\n) -> str:\n    \"\"\"Render a template by name with the given context.\n\n    :param template_name_or_list: The name of the template to render. If\n        a list is given, the first name to exist will be rendered.\n    :param context: The variables to make available in the template.\n    \"\"\"\n    ctx = app_ctx._get_current_object()\n    template = ctx.app.jinja_env.get_or_select_template(template_name_or_list)\n    return _render(ctx, template, context)",
      "input_schema": {
        "type": "object",
        "properties": {
          "template_name_or_list": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "template_name_or_list"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "template_name_or_list": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `render_template` in src\\flask\\templating.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function render_template in src\\flask\\templating.py",
        "matched template: execute a shell command (sim=0.13)"
      ]
    },
    {
      "name": "render_template_string",
      "description": "execute a shell command. Function `render_template_string`.",
      "predicted_filename": "src\\flask\\templating.py",
      "predicted_code_snippet": "def render_template_string(source: str, **context: t.Any) -> str:\n    \"\"\"Render a template from the given source string with the given\n    context.\n\n    :param source: The source code of the template to render.\n    :param context: The variables to make available in the template.\n    \"\"\"\n    ctx = app_ctx._get_current_object()\n    template = ctx.app.jinja_env.from_string(source)\n    return _render(ctx, template, context)",
      "input_schema": {
        "type": "object",
        "properties": {
          "source": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "source"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "source": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `render_template_string` in src\\flask\\templating.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function render_template_string in src\\flask\\templating.py",
        "matched template: execute a shell command (sim=0.15)"
      ]
    },
    {
      "name": "_stream",
      "description": "stream data over websocket. Function `_stream`.",
      "predicted_filename": "src\\flask\\templating.py",
      "predicted_code_snippet": "def _stream(\n    ctx: AppContext, template: Template, context: dict[str, t.Any]\n) -> t.Iterator[str]:\n    app = ctx.app\n    app.update_template_context(ctx, context)\n    before_render_template.send(\n        app, _async_wrapper=app.ensure_sync, template=template, context=context\n    )\n\n    def generate() -> t.Iterator[str]:\n        yield from template.generate(context)\n        template_rendered.send(\n            app, _async_wrapper=app.ensure_sync, template=template, context=context\n        )\n\n    return stream_with_context(generate())",
      "input_schema": {
        "type": "object",
        "properties": {
          "ctx": {
            "type": "string",
            "required": true
          },
          "template": {
            "type": "string",
            "required": true
          },
          "context": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "ctx",
          "template",
          "context"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "ctx": "string",
          "template": "string",
          "context": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `_stream` in src\\flask\\templating.py",
      "possible_syscalls": [],
      "confidence": 0.25,
      "evidence": [
        "function _stream in src\\flask\\templating.py",
        "matched template: stream data over websocket (sim=0.31)"
      ]
    },
    {
      "name": "stream_template",
      "description": "stream data over websocket. Function `stream_template`.",
      "predicted_filename": "src\\flask\\templating.py",
      "predicted_code_snippet": "def stream_template(\n    template_name_or_list: str | Template | list[str | Template],\n    **context: t.Any,\n) -> t.Iterator[str]:\n    \"\"\"Render a template by name with the given context as a stream.\n    This returns an iterator of strings, which can be used as a\n    streaming response from a view.\n\n    :param template_name_or_list: The name of the template to render. If\n        a list is given, the first name to exist will be rendered.\n    :param context: The variables to make available in the template.\n\n    .. versionadded:: 2.2\n    \"\"\"\n    ctx = app_ctx._get_current_object()\n    template = ctx.app.jinja_env.get_or_select_template(template_name_or_list)\n    return _stream(ctx, template, context)",
      "input_schema": {
        "type": "object",
        "properties": {
          "template_name_or_list": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "template_name_or_list"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "template_name_or_list": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `stream_template` in src\\flask\\templating.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function stream_template in src\\flask\\templating.py",
        "matched template: stream data over websocket (sim=0.22)"
      ]
    },
    {
      "name": "stream_template_string",
      "description": "stream data over websocket. Function `stream_template_string`.",
      "predicted_filename": "src\\flask\\templating.py",
      "predicted_code_snippet": "def stream_template_string(source: str, **context: t.Any) -> t.Iterator[str]:\n    \"\"\"Render a template from the given source string with the given\n    context as a stream. This returns an iterator of strings, which can\n    be used as a streaming response from a view.\n\n    :param source: The source code of the template to render.\n    :param context: The variables to make available in the template.\n\n    .. versionadded:: 2.2\n    \"\"\"\n    ctx = app_ctx._get_current_object()\n    template = ctx.app.jinja_env.from_string(source)\n    return _stream(ctx, template, context)",
      "input_schema": {
        "type": "object",
        "properties": {
          "source": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "source"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "source": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `stream_template_string` in src\\flask\\templating.py",
      "possible_syscalls": [],
      "confidence": 0.25,
      "evidence": [
        "function stream_template_string in src\\flask\\templating.py",
        "matched template: stream data over websocket (sim=0.30)"
      ]
    },
    {
      "name": "_get_werkzeug_version",
      "description": "make an HTTP request to an external API. Function `_get_werkzeug_version`.",
      "predicted_filename": "src\\flask\\testing.py",
      "predicted_code_snippet": "def _get_werkzeug_version() -> str:\n    global _werkzeug_version\n\n    if not _werkzeug_version:\n        _werkzeug_version = importlib.metadata.version(\"werkzeug\")\n\n    return _werkzeug_version",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `_get_werkzeug_version` in src\\flask\\testing.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        },
        {
          "syscall": "network",
          "reason": "HTTP requests to external services"
        }
      ],
      "confidence": 0.18,
      "evidence": [
        "function _get_werkzeug_version in src\\flask\\testing.py",
        "matched template: make an HTTP request to an external API (sim=0.16)"
      ]
    },
    {
      "name": "_default",
      "description": "serialize object to JSON. Function `_default`.",
      "predicted_filename": "src\\flask\\json\\provider.py",
      "predicted_code_snippet": "def _default(o: t.Any) -> t.Any:\n    if isinstance(o, date):\n        return http_date(o)\n\n    if isinstance(o, (decimal.Decimal, uuid.UUID)):\n        return str(o)\n\n    if dataclasses and dataclasses.is_dataclass(o):\n        return dataclasses.asdict(o)  # type: ignore[arg-type]\n\n    if hasattr(o, \"__html__\"):\n        return str(o.__html__())\n\n    raise TypeError(f\"Object of type {type(o).__name__} is not JSON serializable\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "o": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "o"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "o": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `_default` in src\\flask\\json\\provider.py",
      "possible_syscalls": [],
      "confidence": 0.27,
      "evidence": [
        "function _default in src\\flask\\json\\provider.py",
        "matched template: serialize object to JSON (sim=0.34)"
      ]
    },
    {
      "name": "dumps",
      "description": "serialize object to JSON. Function `dumps`.",
      "predicted_filename": "src\\flask\\json\\__init__.py",
      "predicted_code_snippet": "def dumps(obj: t.Any, **kwargs: t.Any) -> str:\n    \"\"\"Serialize data as JSON.\n\n    If :data:`~flask.current_app` is available, it will use its\n    :meth:`app.json.dumps() <flask.json.provider.JSONProvider.dumps>`\n    method, otherwise it will use :func:`json.dumps`.\n\n    :param obj: The data to serialize.\n    :param kwargs: Arguments passed to the ``dumps`` implementation.\n\n    .. versionchanged:: 2.3\n        The ``app`` parameter was removed.\n\n    .. versionchanged:: 2.2\n        Calls ``current_app.json.dumps``, allowing an app to override\n        the behavior.\n\n    .. versionchanged:: 2.0.2\n        :class:`decimal.Decimal` is supported by converting to a string.\n\n    .. versionchanged:: 2.0\n        ``encoding`` will be removed in Flask 2.1.\n\n    .. versionchanged:: 1.0.3\n        ``app`` can be passed directly, rather than requiring an app\n        context for configuration.\n    \"\"\"\n    if current_app:\n        return current_app.json.dumps(obj, **kwargs)\n\n    kwargs.setdefault(\"default\", _default)\n    return _json.dumps(obj, **kwargs)",
      "input_schema": {
        "type": "object",
        "properties": {
          "obj": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "obj"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "obj": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `dumps` in src\\flask\\json\\__init__.py",
      "possible_syscalls": [],
      "confidence": 0.25,
      "evidence": [
        "function dumps in src\\flask\\json\\__init__.py",
        "matched template: serialize object to JSON (sim=0.31)"
      ]
    },
    {
      "name": "dump",
      "description": "write data to a file. Function `dump`.",
      "predicted_filename": "src\\flask\\json\\__init__.py",
      "predicted_code_snippet": "def dump(obj: t.Any, fp: t.IO[str], **kwargs: t.Any) -> None:\n    \"\"\"Serialize data as JSON and write to a file.\n\n    If :data:`~flask.current_app` is available, it will use its\n    :meth:`app.json.dump() <flask.json.provider.JSONProvider.dump>`\n    method, otherwise it will use :func:`json.dump`.\n\n    :param obj: The data to serialize.\n    :param fp: A file opened for writing text. Should use the UTF-8\n        encoding to be valid JSON.\n    :param kwargs: Arguments passed to the ``dump`` implementation.\n\n    .. versionchanged:: 2.3\n        The ``app`` parameter was removed.\n\n    .. versionchanged:: 2.2\n        Calls ``current_app.json.dump``, allowing an app to override\n        the behavior.\n\n    .. versionchanged:: 2.0\n        Writing to a binary file, and the ``encoding`` argument, will be\n        removed in Flask 2.1.\n    \"\"\"\n    if current_app:\n        current_app.json.dump(obj, fp, **kwargs)\n    else:\n        kwargs.setdefault(\"default\", _default)\n        _json.dump(obj, fp, **kwargs)",
      "input_schema": {
        "type": "object",
        "properties": {
          "obj": {
            "type": "string",
            "required": true
          },
          "fp": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "obj",
          "fp"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "obj": "string",
          "fp": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `dump` in src\\flask\\json\\__init__.py",
      "possible_syscalls": [],
      "confidence": 0.26,
      "evidence": [
        "function dump in src\\flask\\json\\__init__.py",
        "matched template: write data to a file (sim=0.32)"
      ]
    },
    {
      "name": "loads",
      "description": "serialize object to JSON. Function `loads`.",
      "predicted_filename": "src\\flask\\json\\__init__.py",
      "predicted_code_snippet": "def loads(s: str | bytes, **kwargs: t.Any) -> t.Any:\n    \"\"\"Deserialize data as JSON.\n\n    If :data:`~flask.current_app` is available, it will use its\n    :meth:`app.json.loads() <flask.json.provider.JSONProvider.loads>`\n    method, otherwise it will use :func:`json.loads`.\n\n    :param s: Text or UTF-8 bytes.\n    :param kwargs: Arguments passed to the ``loads`` implementation.\n\n    .. versionchanged:: 2.3\n        The ``app`` parameter was removed.\n\n    .. versionchanged:: 2.2\n        Calls ``current_app.json.loads``, allowing an app to override\n        the behavior.\n\n    .. versionchanged:: 2.0\n        ``encoding`` will be removed in Flask 2.1. The data must be a\n        string or UTF-8 bytes.\n\n    .. versionchanged:: 1.0.3\n        ``app`` can be passed directly, rather than requiring an app\n        context for configuration.\n    \"\"\"\n    if current_app:\n        return current_app.json.loads(s, **kwargs)\n\n    return _json.loads(s, **kwargs)",
      "input_schema": {
        "type": "object",
        "properties": {
          "s": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "s"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "s": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `loads` in src\\flask\\json\\__init__.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function loads in src\\flask\\json\\__init__.py",
        "matched template: serialize object to JSON (sim=0.21)"
      ]
    },
    {
      "name": "load",
      "description": "serialize object to JSON. Function `load`.",
      "predicted_filename": "src\\flask\\json\\__init__.py",
      "predicted_code_snippet": "def load(fp: t.IO[t.AnyStr], **kwargs: t.Any) -> t.Any:\n    \"\"\"Deserialize data as JSON read from a file.\n\n    If :data:`~flask.current_app` is available, it will use its\n    :meth:`app.json.load() <flask.json.provider.JSONProvider.load>`\n    method, otherwise it will use :func:`json.load`.\n\n    :param fp: A file opened for reading text or UTF-8 bytes.\n    :param kwargs: Arguments passed to the ``load`` implementation.\n\n    .. versionchanged:: 2.3\n        The ``app`` parameter was removed.\n\n    .. versionchanged:: 2.2\n        Calls ``current_app.json.load``, allowing an app to override\n        the behavior.\n\n    .. versionchanged:: 2.2\n        The ``app`` parameter will be removed in Flask 2.3.\n\n    .. versionchanged:: 2.0\n        ``encoding`` will be removed in Flask 2.1. The file must be text\n        mode, or binary mode with UTF-8 bytes.\n    \"\"\"\n    if current_app:\n        return current_app.json.load(fp, **kwargs)\n\n    return _json.load(fp, **kwargs)",
      "input_schema": {
        "type": "object",
        "properties": {
          "fp": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "fp"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "fp": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `load` in src\\flask\\json\\__init__.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function load in src\\flask\\json\\__init__.py",
        "matched template: serialize object to JSON (sim=0.20)"
      ]
    },
    {
      "name": "jsonify",
      "description": "serialize object to JSON. Function `jsonify`.",
      "predicted_filename": "src\\flask\\json\\__init__.py",
      "predicted_code_snippet": "def jsonify(*args: t.Any, **kwargs: t.Any) -> Response:\n    \"\"\"Serialize the given arguments as JSON, and return a\n    :class:`~flask.Response` object with the ``application/json``\n    mimetype. A dict or list returned from a view will be converted to a\n    JSON response automatically without needing to call this.\n\n    This requires an active app context, and calls\n    :meth:`app.json.response() <flask.json.provider.JSONProvider.response>`.\n\n    In debug mode, the output is formatted with indentation to make it\n    easier to read. This may also be controlled by the provider.\n\n    Either positional or keyword arguments can be given, not both.\n    If no arguments are given, ``None`` is serialized.\n\n    :param args: A single value to serialize, or multiple values to\n        treat as a list to serialize.\n    :param kwargs: Treat as a dict to serialize.\n\n    .. versionchanged:: 2.2\n        Calls ``current_app.json.response``, allowing an app to override\n        the behavior.\n\n    .. versionchanged:: 2.0.2\n        :class:`decimal.Decimal` is supported by converting to a string.\n\n    .. versionchanged:: 0.11\n        Added support for serializing top-level arrays. This was a\n        security risk in ancient browsers. See :ref:`security-json`.\n\n    .. versionadded:: 0.2\n    \"\"\"\n    return current_app.json.response(*args, **kwargs)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `jsonify` in src\\flask\\json\\__init__.py",
      "possible_syscalls": [],
      "confidence": 0.29,
      "evidence": [
        "function jsonify in src\\flask\\json\\__init__.py",
        "matched template: serialize object to JSON (sim=0.37)"
      ]
    },
    {
      "name": "_make_timedelta",
      "description": "handle a HTTP route request and return response. Function `_make_timedelta`.",
      "predicted_filename": "src\\flask\\sansio\\app.py",
      "predicted_code_snippet": "def _make_timedelta(value: timedelta | int | None) -> timedelta | None:\n    if value is None or isinstance(value, timedelta):\n        return value\n\n    return timedelta(seconds=value)",
      "input_schema": {
        "type": "object",
        "properties": {
          "value": {
            "type": "integer",
            "required": true
          }
        },
        "required": [
          "value"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "value": "integer"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `_make_timedelta` in src\\flask\\sansio\\app.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function _make_timedelta in src\\flask\\sansio\\app.py",
        "matched template: handle a HTTP route request and return response (sim=0.24)"
      ]
    },
    {
      "name": "setupmethod",
      "description": "cache results to disk or memory. Function `setupmethod`.",
      "predicted_filename": "src\\flask\\sansio\\scaffold.py",
      "predicted_code_snippet": "def setupmethod(f: F) -> F:\n    f_name = f.__name__\n\n    def wrapper_func(self: Scaffold, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        self._check_setup_finished(f_name)\n        return f(self, *args, **kwargs)\n\n    return t.cast(F, update_wrapper(wrapper_func, f))",
      "input_schema": {
        "type": "object",
        "properties": {
          "f": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "f"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "f": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `setupmethod` in src\\flask\\sansio\\scaffold.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function setupmethod in src\\flask\\sansio\\scaffold.py",
        "matched template: cache results to disk or memory (sim=0.17)"
      ]
    },
    {
      "name": "_endpoint_from_view_func",
      "description": "handle a HTTP route request and return response. Function `_endpoint_from_view_func`.",
      "predicted_filename": "src\\flask\\sansio\\scaffold.py",
      "predicted_code_snippet": "def _endpoint_from_view_func(view_func: ft.RouteCallable) -> str:\n    \"\"\"Internal helper that returns the default endpoint for a given\n    function.  This always is the function name.\n    \"\"\"\n    assert view_func is not None, \"expected view func if endpoint is not provided.\"\n    return view_func.__name__",
      "input_schema": {
        "type": "object",
        "properties": {
          "view_func": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "view_func"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "view_func": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `_endpoint_from_view_func` in src\\flask\\sansio\\scaffold.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function _endpoint_from_view_func in src\\flask\\sansio\\scaffold.py",
        "matched template: handle a HTTP route request and return response (sim=0.18)"
      ]
    },
    {
      "name": "_find_package_path",
      "description": "list files in a directory. Function `_find_package_path`.",
      "predicted_filename": "src\\flask\\sansio\\scaffold.py",
      "predicted_code_snippet": "def _find_package_path(import_name: str) -> str:\n    \"\"\"Find the path that contains the package or module.\"\"\"\n    root_mod_name, _, _ = import_name.partition(\".\")\n\n    try:\n        root_spec = importlib.util.find_spec(root_mod_name)\n\n        if root_spec is None:\n            raise ValueError(\"not found\")\n    except (ImportError, ValueError):\n        # ImportError: the machinery told us it does not exist\n        # ValueError:\n        #    - the module name was invalid\n        #    - the module name is __main__\n        #    - we raised `ValueError` due to `root_spec` being `None`\n        return os.getcwd()\n\n    if root_spec.submodule_search_locations:\n        if root_spec.origin is None or root_spec.origin == \"namespace\":\n            # namespace package\n            package_spec = importlib.util.find_spec(import_name)\n\n            if package_spec is not None and package_spec.submodule_search_locations:\n                # Pick the path in the namespace that contains the submodule.\n                package_path = pathlib.Path(\n                    os.path.commonpath(package_spec.submodule_search_locations)\n                )\n                search_location = next(\n                    location\n                    for location in root_spec.submodule_search_locations\n                    if package_path.is_relative_to(location)\n                )\n            else:\n                # Pick the first path.\n                search_location = root_spec.submodule_search_locations[0]\n\n            return os.path.dirname(search_location)\n        else:\n            # package with __init__.py\n            return os.path.dirname(os.path.dirname(root_spec.origin))\n    else:\n        # module\n        return os.path.dirname(root_spec.origin)",
      "input_schema": {
        "type": "object",
        "properties": {
          "import_name": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "import_name"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "import_name": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `_find_package_path` in src\\flask\\sansio\\scaffold.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function _find_package_path in src\\flask\\sansio\\scaffold.py",
        "matched template: list files in a directory (sim=0.13)"
      ]
    },
    {
      "name": "find_package",
      "description": "list files in a directory. Function `find_package`.",
      "predicted_filename": "src\\flask\\sansio\\scaffold.py",
      "predicted_code_snippet": "def find_package(import_name: str) -> tuple[str | None, str]:\n    \"\"\"Find the prefix that a package is installed under, and the path\n    that it would be imported from.\n\n    The prefix is the directory containing the standard directory\n    hierarchy (lib, bin, etc.). If the package is not installed to the\n    system (:attr:`sys.prefix`) or a virtualenv (``site-packages``),\n    ``None`` is returned.\n\n    The path is the entry in :attr:`sys.path` that contains the package\n    for import. If the package is not installed, it's assumed that the\n    package was imported from the current working directory.\n    \"\"\"\n    package_path = _find_package_path(import_name)\n    py_prefix = os.path.abspath(sys.prefix)\n\n    # installed to the system\n    if pathlib.PurePath(package_path).is_relative_to(py_prefix):\n        return py_prefix, package_path\n\n    site_parent, site_folder = os.path.split(package_path)\n\n    # installed to a virtualenv\n    if site_folder.lower() == \"site-packages\":\n        parent, folder = os.path.split(site_parent)\n\n        # Windows (prefix/lib/site-packages)\n        if folder.lower() == \"lib\":\n            return parent, package_path\n\n        # Unix (prefix/lib/pythonX.Y/site-packages)\n        if os.path.basename(parent).lower() == \"lib\":\n            return os.path.dirname(parent), package_path\n\n        # something else (prefix/site-packages)\n        return site_parent, package_path\n\n    # not installed\n    return None, package_path",
      "input_schema": {
        "type": "object",
        "properties": {
          "import_name": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "import_name"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "import_name": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `find_package` in src\\flask\\sansio\\scaffold.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function find_package in src\\flask\\sansio\\scaffold.py",
        "matched template: list files in a directory (sim=0.15)"
      ]
    },
    {
      "name": "_standard_os_environ",
      "description": "execute a shell command. Function `_standard_os_environ`.",
      "predicted_filename": "tests\\conftest.py",
      "predicted_code_snippet": "def _standard_os_environ():\n    \"\"\"Set up ``os.environ`` at the start of the test session to have\n    standard values. Returns a list of operations that is used by\n    :func:`._reset_os_environ` after each test.\n    \"\"\"\n    mp = monkeypatch.MonkeyPatch()\n    out = (\n        (os.environ, \"FLASK_ENV_FILE\", monkeypatch.notset),\n        (os.environ, \"FLASK_APP\", monkeypatch.notset),\n        (os.environ, \"FLASK_DEBUG\", monkeypatch.notset),\n        (os.environ, \"FLASK_RUN_FROM_CLI\", monkeypatch.notset),\n        (os.environ, \"WERKZEUG_RUN_MAIN\", monkeypatch.notset),\n    )\n\n    for _, key, value in out:\n        if value is monkeypatch.notset:\n            mp.delenv(key, False)\n        else:\n            mp.setenv(key, value)\n\n    yield out\n    mp.undo()",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `_standard_os_environ` in tests\\conftest.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function _standard_os_environ in tests\\conftest.py",
        "matched template: execute a shell command (sim=0.14)"
      ]
    },
    {
      "name": "_reset_os_environ",
      "description": "execute a shell command. Function `_reset_os_environ`.",
      "predicted_filename": "tests\\conftest.py",
      "predicted_code_snippet": "def _reset_os_environ(monkeypatch, _standard_os_environ):\n    \"\"\"Reset ``os.environ`` to the standard environ after each test,\n    in case a test changed something without cleaning up.\n    \"\"\"\n    monkeypatch._setitem.extend(_standard_os_environ)",
      "input_schema": {
        "type": "object",
        "properties": {
          "monkeypatch": {
            "type": "string",
            "required": true
          },
          "_standard_os_environ": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "monkeypatch",
          "_standard_os_environ"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "monkeypatch": "string",
          "_standard_os_environ": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `_reset_os_environ` in tests\\conftest.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function _reset_os_environ in tests\\conftest.py",
        "matched template: execute a shell command (sim=0.12)"
      ]
    },
    {
      "name": "app",
      "description": "write data to a file. Function `app`.",
      "predicted_filename": "tests\\conftest.py",
      "predicted_code_snippet": "def app():\n    app = Flask(\"flask_test\", root_path=os.path.dirname(__file__))\n    app.config.update(\n        TESTING=True,\n        SECRET_KEY=\"test key\",\n    )\n    return app",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `app` in tests\\conftest.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function app in tests\\conftest.py",
        "matched template: write data to a file (sim=0.12)"
      ]
    },
    {
      "name": "app_ctx",
      "description": "execute a shell command. Function `app_ctx`.",
      "predicted_filename": "tests\\conftest.py",
      "predicted_code_snippet": "def app_ctx(app):\n    with app.app_context() as ctx:\n        yield ctx",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `app_ctx` in tests\\conftest.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function app_ctx in tests\\conftest.py",
        "matched template: execute a shell command (sim=0.14)"
      ]
    },
    {
      "name": "req_ctx",
      "description": "execute a shell command. Function `req_ctx`.",
      "predicted_filename": "tests\\conftest.py",
      "predicted_code_snippet": "def req_ctx(app):\n    with app.test_request_context() as ctx:\n        yield ctx",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `req_ctx` in tests\\conftest.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function req_ctx in tests\\conftest.py",
        "matched template: execute a shell command (sim=0.12)"
      ]
    },
    {
      "name": "client",
      "description": "execute a shell command. Function `client`.",
      "predicted_filename": "tests\\conftest.py",
      "predicted_code_snippet": "def client(app):\n    return app.test_client()",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `client` in tests\\conftest.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function client in tests\\conftest.py",
        "matched template: execute a shell command (sim=0.15)"
      ]
    },
    {
      "name": "test_apps",
      "description": "cache results to disk or memory. Function `test_apps`.",
      "predicted_filename": "tests\\conftest.py",
      "predicted_code_snippet": "def test_apps(monkeypatch):\n    monkeypatch.syspath_prepend(os.path.join(os.path.dirname(__file__), \"test_apps\"))\n    original_modules = set(sys.modules.keys())\n\n    yield\n\n    # Remove any imports cached during the test. Otherwise \"import app\"\n    # will work in the next test even though it's no longer on the path.\n    for key in sys.modules.keys() - original_modules:\n        sys.modules.pop(key)",
      "input_schema": {
        "type": "object",
        "properties": {
          "monkeypatch": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "monkeypatch"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "monkeypatch": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_apps` in tests\\conftest.py",
      "possible_syscalls": [],
      "confidence": 0.16,
      "evidence": [
        "function test_apps in tests\\conftest.py",
        "matched template: cache results to disk or memory (sim=0.10)"
      ]
    },
    {
      "name": "leak_detector",
      "description": "validate and sanitize user input. Function `leak_detector`.",
      "predicted_filename": "tests\\conftest.py",
      "predicted_code_snippet": "def leak_detector():\n    \"\"\"Fails if any app contexts are still pushed when a test ends. Pops all\n    contexts so subsequent tests are not affected.\n    \"\"\"\n    yield\n    leaks = []\n\n    while _app_ctx:\n        leaks.append(_app_ctx._get_current_object())\n        _app_ctx.pop()\n\n    assert not leaks",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `leak_detector` in tests\\conftest.py",
      "possible_syscalls": [],
      "confidence": 0.16,
      "evidence": [
        "function leak_detector in tests\\conftest.py",
        "matched template: validate and sanitize user input (sim=0.10)"
      ]
    },
    {
      "name": "modules_tmp_path",
      "description": "execute a shell command. Function `modules_tmp_path`.",
      "predicted_filename": "tests\\conftest.py",
      "predicted_code_snippet": "def modules_tmp_path(tmp_path, monkeypatch):\n    \"\"\"A temporary directory added to sys.path.\"\"\"\n    rv = tmp_path / \"modules_tmp\"\n    rv.mkdir()\n    monkeypatch.syspath_prepend(os.fspath(rv))\n    return rv",
      "input_schema": {
        "type": "object",
        "properties": {
          "tmp_path": {
            "type": "string",
            "required": true
          },
          "monkeypatch": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "tmp_path",
          "monkeypatch"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "tmp_path": "string",
          "monkeypatch": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `modules_tmp_path` in tests\\conftest.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function modules_tmp_path in tests\\conftest.py",
        "matched template: execute a shell command (sim=0.15)"
      ]
    },
    {
      "name": "modules_tmp_path_prefix",
      "description": "execute a shell command. Function `modules_tmp_path_prefix`.",
      "predicted_filename": "tests\\conftest.py",
      "predicted_code_snippet": "def modules_tmp_path_prefix(modules_tmp_path, monkeypatch):\n    monkeypatch.setattr(sys, \"prefix\", os.fspath(modules_tmp_path))\n    return modules_tmp_path",
      "input_schema": {
        "type": "object",
        "properties": {
          "modules_tmp_path": {
            "type": "string",
            "required": true
          },
          "monkeypatch": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "modules_tmp_path",
          "monkeypatch"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "modules_tmp_path": "string",
          "monkeypatch": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `modules_tmp_path_prefix` in tests\\conftest.py",
      "possible_syscalls": [],
      "confidence": 0.16,
      "evidence": [
        "function modules_tmp_path_prefix in tests\\conftest.py",
        "matched template: execute a shell command (sim=0.11)"
      ]
    },
    {
      "name": "site_packages",
      "description": "execute a shell command. Function `site_packages`.",
      "predicted_filename": "tests\\conftest.py",
      "predicted_code_snippet": "def site_packages(modules_tmp_path, monkeypatch):\n    \"\"\"Create a fake site-packages.\"\"\"\n    py_dir = f\"python{sys.version_info.major}.{sys.version_info.minor}\"\n    rv = modules_tmp_path / \"lib\" / py_dir / \"site-packages\"\n    rv.mkdir(parents=True)\n    monkeypatch.syspath_prepend(os.fspath(rv))\n    return rv",
      "input_schema": {
        "type": "object",
        "properties": {
          "modules_tmp_path": {
            "type": "string",
            "required": true
          },
          "monkeypatch": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "modules_tmp_path",
          "monkeypatch"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "modules_tmp_path": "string",
          "monkeypatch": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `site_packages` in tests\\conftest.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function site_packages in tests\\conftest.py",
        "matched template: execute a shell command (sim=0.12)"
      ]
    },
    {
      "name": "purge_module",
      "description": "validate and sanitize user input. Function `purge_module`.",
      "predicted_filename": "tests\\conftest.py",
      "predicted_code_snippet": "def purge_module(request):\n    def inner(name):\n        request.addfinalizer(lambda: sys.modules.pop(name, None))\n\n    return inner",
      "input_schema": {
        "type": "object",
        "properties": {
          "request": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "request"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "request": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `purge_module` in tests\\conftest.py",
      "possible_syscalls": [],
      "confidence": 0.16,
      "evidence": [
        "function purge_module in tests\\conftest.py",
        "matched template: validate and sanitize user input (sim=0.10)"
      ]
    },
    {
      "name": "test_basic_url_generation",
      "description": "handle a HTTP route request and return response. Function `test_basic_url_generation`.",
      "predicted_filename": "tests\\test_appctx.py",
      "predicted_code_snippet": "def test_basic_url_generation(app):\n    app.config[\"SERVER_NAME\"] = \"localhost\"\n    app.config[\"PREFERRED_URL_SCHEME\"] = \"https\"\n\n    @app.route(\"/\")\n    def index():\n        pass\n\n    with app.app_context():\n        rv = flask.url_for(\"index\")\n        assert rv == \"https://localhost/\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_basic_url_generation` in tests\\test_appctx.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function test_basic_url_generation in tests\\test_appctx.py",
        "matched template: handle a HTTP route request and return response (sim=0.28)"
      ]
    },
    {
      "name": "test_url_generation_requires_server_name",
      "description": "handle a HTTP route request and return response. Function `test_url_generation_requires_server_name`.",
      "predicted_filename": "tests\\test_appctx.py",
      "predicted_code_snippet": "def test_url_generation_requires_server_name(app):\n    with app.app_context():\n        with pytest.raises(RuntimeError):\n            flask.url_for(\"index\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_url_generation_requires_server_name` in tests\\test_appctx.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function test_url_generation_requires_server_name in tests\\test_appctx.py",
        "matched template: handle a HTTP route request and return response (sim=0.26)"
      ]
    },
    {
      "name": "test_url_generation_without_context_fails",
      "description": "handle a HTTP route request and return response. Function `test_url_generation_without_context_fails`.",
      "predicted_filename": "tests\\test_appctx.py",
      "predicted_code_snippet": "def test_url_generation_without_context_fails():\n    with pytest.raises(RuntimeError):\n        flask.url_for(\"index\")",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_url_generation_without_context_fails` in tests\\test_appctx.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function test_url_generation_without_context_fails in tests\\test_appctx.py",
        "matched template: handle a HTTP route request and return response (sim=0.26)"
      ]
    },
    {
      "name": "test_request_context_means_app_context",
      "description": "handle a HTTP route request and return response. Function `test_request_context_means_app_context`.",
      "predicted_filename": "tests\\test_appctx.py",
      "predicted_code_snippet": "def test_request_context_means_app_context(app):\n    with app.test_request_context():\n        assert flask.current_app._get_current_object() is app\n    assert not flask.current_app",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_request_context_means_app_context` in tests\\test_appctx.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function test_request_context_means_app_context in tests\\test_appctx.py",
        "matched template: handle a HTTP route request and return response (sim=0.26)"
      ]
    },
    {
      "name": "test_app_context_provides_current_app",
      "description": "handle a HTTP route request and return response. Function `test_app_context_provides_current_app`.",
      "predicted_filename": "tests\\test_appctx.py",
      "predicted_code_snippet": "def test_app_context_provides_current_app(app):\n    with app.app_context():\n        assert flask.current_app._get_current_object() is app\n    assert not flask.current_app",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_app_context_provides_current_app` in tests\\test_appctx.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function test_app_context_provides_current_app in tests\\test_appctx.py",
        "matched template: handle a HTTP route request and return response (sim=0.24)"
      ]
    },
    {
      "name": "test_app_tearing_down",
      "description": "handle a HTTP route request and return response. Function `test_app_tearing_down`.",
      "predicted_filename": "tests\\test_appctx.py",
      "predicted_code_snippet": "def test_app_tearing_down(app):\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    with app.app_context():\n        pass\n\n    assert cleanup_stuff == [None]",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_app_tearing_down` in tests\\test_appctx.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function test_app_tearing_down in tests\\test_appctx.py",
        "matched template: handle a HTTP route request and return response (sim=0.23)"
      ]
    },
    {
      "name": "test_app_tearing_down_with_previous_exception",
      "description": "handle a HTTP route request and return response. Function `test_app_tearing_down_with_previous_exception`.",
      "predicted_filename": "tests\\test_appctx.py",
      "predicted_code_snippet": "def test_app_tearing_down_with_previous_exception(app):\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    try:\n        raise Exception(\"dummy\")\n    except Exception:\n        pass\n\n    with app.app_context():\n        pass\n\n    assert cleanup_stuff == [None]",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_app_tearing_down_with_previous_exception` in tests\\test_appctx.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_app_tearing_down_with_previous_exception in tests\\test_appctx.py",
        "matched template: handle a HTTP route request and return response (sim=0.20)"
      ]
    },
    {
      "name": "test_app_tearing_down_with_handled_exception_by_except_block",
      "description": "handle a HTTP route request and return response. Function `test_app_tearing_down_with_handled_exception_by_except_block`.",
      "predicted_filename": "tests\\test_appctx.py",
      "predicted_code_snippet": "def test_app_tearing_down_with_handled_exception_by_except_block(app):\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    with app.app_context():\n        try:\n            raise Exception(\"dummy\")\n        except Exception:\n            pass\n\n    assert cleanup_stuff == [None]",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_app_tearing_down_with_handled_exception_by_except_block` in tests\\test_appctx.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function test_app_tearing_down_with_handled_exception_by_except_block in tests\\test_appctx.py",
        "matched template: handle a HTTP route request and return response (sim=0.21)"
      ]
    },
    {
      "name": "test_app_tearing_down_with_handled_exception_by_app_handler",
      "description": "handle a HTTP route request and return response. Function `test_app_tearing_down_with_handled_exception_by_app_handler`.",
      "predicted_filename": "tests\\test_appctx.py",
      "predicted_code_snippet": "def test_app_tearing_down_with_handled_exception_by_app_handler(app, client):\n    app.config[\"PROPAGATE_EXCEPTIONS\"] = True\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    @app.route(\"/\")\n    def index():\n        raise Exception(\"dummy\")\n\n    @app.errorhandler(Exception)\n    def handler(f):\n        return flask.jsonify(str(f))\n\n    with app.app_context():\n        client.get(\"/\")\n\n    # teardown request context, and with block context\n    assert cleanup_stuff == [None, None]",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_app_tearing_down_with_handled_exception_by_app_handler` in tests\\test_appctx.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function test_app_tearing_down_with_handled_exception_by_app_handler in tests\\test_appctx.py",
        "matched template: handle a HTTP route request and return response (sim=0.26)"
      ]
    },
    {
      "name": "test_app_tearing_down_with_unhandled_exception",
      "description": "handle a HTTP route request and return response. Function `test_app_tearing_down_with_unhandled_exception`.",
      "predicted_filename": "tests\\test_appctx.py",
      "predicted_code_snippet": "def test_app_tearing_down_with_unhandled_exception(app, client):\n    app.config[\"PROPAGATE_EXCEPTIONS\"] = True\n    cleanup_stuff = []\n\n    @app.teardown_appcontext\n    def cleanup(exception):\n        cleanup_stuff.append(exception)\n\n    @app.route(\"/\")\n    def index():\n        raise ValueError(\"dummy\")\n\n    with pytest.raises(ValueError, match=\"dummy\"):\n        with app.app_context():\n            client.get(\"/\")\n\n    assert len(cleanup_stuff) == 2\n    assert isinstance(cleanup_stuff[0], ValueError)\n    assert str(cleanup_stuff[0]) == \"dummy\"\n    # exception propagated, seen by request context and with block context\n    assert cleanup_stuff[0] is cleanup_stuff[1]",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_app_tearing_down_with_unhandled_exception` in tests\\test_appctx.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function test_app_tearing_down_with_unhandled_exception in tests\\test_appctx.py",
        "matched template: handle a HTTP route request and return response (sim=0.17)"
      ]
    },
    {
      "name": "test_app_ctx_globals_methods",
      "description": "validate and sanitize user input. Function `test_app_ctx_globals_methods`.",
      "predicted_filename": "tests\\test_appctx.py",
      "predicted_code_snippet": "def test_app_ctx_globals_methods(app, app_ctx):\n    # get\n    assert flask.g.get(\"foo\") is None\n    assert flask.g.get(\"foo\", \"bar\") == \"bar\"\n    # __contains__\n    assert \"foo\" not in flask.g\n    flask.g.foo = \"bar\"\n    assert \"foo\" in flask.g\n    # setdefault\n    flask.g.setdefault(\"bar\", \"the cake is a lie\")\n    flask.g.setdefault(\"bar\", \"hello world\")\n    assert flask.g.bar == \"the cake is a lie\"\n    # pop\n    assert flask.g.pop(\"bar\") == \"the cake is a lie\"\n    with pytest.raises(KeyError):\n        flask.g.pop(\"bar\")\n    assert flask.g.pop(\"bar\", \"more cake\") == \"more cake\"\n    # __iter__\n    assert list(flask.g) == [\"foo\"]\n    # __repr__\n    assert repr(flask.g) == \"<flask.g of 'flask_test'>\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "app_ctx": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "app_ctx"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "app_ctx": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_app_ctx_globals_methods` in tests\\test_appctx.py",
      "possible_syscalls": [],
      "confidence": 0.16,
      "evidence": [
        "function test_app_ctx_globals_methods in tests\\test_appctx.py",
        "matched template: validate and sanitize user input (sim=0.09)"
      ]
    },
    {
      "name": "test_custom_app_ctx_globals_class",
      "description": "make an HTTP request to an external API. Function `test_custom_app_ctx_globals_class`.",
      "predicted_filename": "tests\\test_appctx.py",
      "predicted_code_snippet": "def test_custom_app_ctx_globals_class(app):\n    class CustomRequestGlobals:\n        def __init__(self):\n            self.spam = \"eggs\"\n\n    app.app_ctx_globals_class = CustomRequestGlobals\n    with app.app_context():\n        assert flask.render_template_string(\"{{ g.spam }}\") == \"eggs\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_custom_app_ctx_globals_class` in tests\\test_appctx.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function test_custom_app_ctx_globals_class in tests\\test_appctx.py",
        "matched template: make an HTTP request to an external API (sim=0.21)"
      ]
    },
    {
      "name": "test_context_refcounts",
      "description": "handle a HTTP route request and return response. Function `test_context_refcounts`.",
      "predicted_filename": "tests\\test_appctx.py",
      "predicted_code_snippet": "def test_context_refcounts(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_req(error=None):\n        called.append(\"request\")\n\n    @app.teardown_appcontext\n    def teardown_app(error=None):\n        called.append(\"app\")\n\n    @app.route(\"/\")\n    def index():\n        with app_ctx:\n            pass\n\n        assert flask.request.environ[\"werkzeug.request\"] is not None\n        return \"\"\n\n    res = client.get(\"/\")\n    assert res.status_code == 200\n    assert res.data == b\"\"\n    assert called == [\"request\", \"app\"]",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_context_refcounts` in tests\\test_appctx.py",
      "possible_syscalls": [],
      "confidence": 0.24,
      "evidence": [
        "function test_context_refcounts in tests\\test_appctx.py",
        "matched template: handle a HTTP route request and return response (sim=0.30)"
      ]
    },
    {
      "name": "test_clean_pop",
      "description": "handle a HTTP route request and return response. Function `test_clean_pop`.",
      "predicted_filename": "tests\\test_appctx.py",
      "predicted_code_snippet": "def test_clean_pop(app):\n    app.testing = False\n    called = []\n\n    @app.teardown_request\n    def teardown_req(error=None):\n        raise ZeroDivisionError\n\n    @app.teardown_appcontext\n    def teardown_app(error=None):\n        called.append(\"TEARDOWN\")\n\n    with app.app_context():\n        called.append(flask.current_app.name)\n\n    assert called == [\"flask_test\", \"TEARDOWN\"]\n    assert not flask.current_app",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_clean_pop` in tests\\test_appctx.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_clean_pop in tests\\test_appctx.py",
        "matched template: handle a HTTP route request and return response (sim=0.18)"
      ]
    },
    {
      "name": "_async_app",
      "description": "handle a HTTP route request and return response. Function `_async_app`.",
      "predicted_filename": "tests\\test_async.py",
      "predicted_code_snippet": "def _async_app():\n    app = Flask(__name__)\n\n    @app.route(\"/\", methods=[\"GET\", \"POST\"])\n    @app.route(\"/home\", methods=[\"GET\", \"POST\"])\n    async def index():\n        await asyncio.sleep(0)\n        return request.method\n\n    @app.errorhandler(AppError)\n    async def handle(_):\n        return \"\", 412\n\n    @app.route(\"/error\")\n    async def error():\n        raise AppError()\n\n    blueprint = Blueprint(\"bp\", __name__)\n\n    @blueprint.route(\"/\", methods=[\"GET\", \"POST\"])\n    async def bp_index():\n        await asyncio.sleep(0)\n        return request.method\n\n    @blueprint.errorhandler(BlueprintError)\n    async def bp_handle(_):\n        return \"\", 412\n\n    @blueprint.route(\"/error\")\n    async def bp_error():\n        raise BlueprintError()\n\n    app.register_blueprint(blueprint, url_prefix=\"/bp\")\n\n    app.add_url_rule(\"/view\", view_func=AsyncView.as_view(\"view\"))\n    app.add_url_rule(\"/methodview\", view_func=AsyncMethodView.as_view(\"methodview\"))\n\n    return app",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `_async_app` in tests\\test_async.py",
      "possible_syscalls": [],
      "confidence": 0.25,
      "evidence": [
        "function _async_app in tests\\test_async.py",
        "matched template: handle a HTTP route request and return response (sim=0.31)"
      ]
    },
    {
      "name": "test_async_route",
      "description": "handle a HTTP route request and return response. Function `test_async_route`.",
      "predicted_filename": "tests\\test_async.py",
      "predicted_code_snippet": "def test_async_route(path, async_app):\n    test_client = async_app.test_client()\n    response = test_client.get(path)\n    assert b\"GET\" in response.get_data()\n    response = test_client.post(path)\n    assert b\"POST\" in response.get_data()",
      "input_schema": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "required": true
          },
          "async_app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "path",
          "async_app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "path": "string",
          "async_app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_async_route` in tests\\test_async.py",
      "possible_syscalls": [],
      "confidence": 0.25,
      "evidence": [
        "function test_async_route in tests\\test_async.py",
        "matched template: handle a HTTP route request and return response (sim=0.31)"
      ]
    },
    {
      "name": "test_async_error_handler",
      "description": "handle a HTTP route request and return response. Function `test_async_error_handler`.",
      "predicted_filename": "tests\\test_async.py",
      "predicted_code_snippet": "def test_async_error_handler(path, async_app):\n    test_client = async_app.test_client()\n    response = test_client.get(path)\n    assert response.status_code == 412",
      "input_schema": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "required": true
          },
          "async_app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "path",
          "async_app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "path": "string",
          "async_app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_async_error_handler` in tests\\test_async.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function test_async_error_handler in tests\\test_async.py",
        "matched template: handle a HTTP route request and return response (sim=0.22)"
      ]
    },
    {
      "name": "test_async_before_after_request",
      "description": "handle a HTTP route request and return response. Function `test_async_before_after_request`.",
      "predicted_filename": "tests\\test_async.py",
      "predicted_code_snippet": "def test_async_before_after_request():\n    app_before_called = False\n    app_after_called = False\n    bp_before_called = False\n    bp_after_called = False\n\n    app = Flask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        return \"\"\n\n    @app.before_request\n    async def before():\n        nonlocal app_before_called\n        app_before_called = True\n\n    @app.after_request\n    async def after(response):\n        nonlocal app_after_called\n        app_after_called = True\n        return response\n\n    blueprint = Blueprint(\"bp\", __name__)\n\n    @blueprint.route(\"/\")\n    def bp_index():\n        return \"\"\n\n    @blueprint.before_request\n    async def bp_before():\n        nonlocal bp_before_called\n        bp_before_called = True\n\n    @blueprint.after_request\n    async def bp_after(response):\n        nonlocal bp_after_called\n        bp_after_called = True\n        return response\n\n    app.register_blueprint(blueprint, url_prefix=\"/bp\")\n\n    test_client = app.test_client()\n    test_client.get(\"/\")\n    assert app_before_called\n    assert app_after_called\n    test_client.get(\"/bp/\")\n    assert bp_before_called\n    assert bp_after_called",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_async_before_after_request` in tests\\test_async.py",
      "possible_syscalls": [],
      "confidence": 0.25,
      "evidence": [
        "function test_async_before_after_request in tests\\test_async.py",
        "matched template: handle a HTTP route request and return response (sim=0.31)"
      ]
    },
    {
      "name": "test_options_work",
      "description": "handle a HTTP route request and return response. Function `test_options_work`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_options_work(app, client):\n    @app.route(\"/\", methods=[\"GET\", \"POST\"])\n    def index():\n        return \"Hello World\"\n\n    rv = client.open(\"/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n    assert rv.data == b\"\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_options_work` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.22,
      "evidence": [
        "function test_options_work in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.25)"
      ]
    },
    {
      "name": "test_options_on_multiple_rules",
      "description": "handle a HTTP route request and return response. Function `test_options_on_multiple_rules`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_options_on_multiple_rules(app, client):\n    @app.route(\"/\", methods=[\"GET\", \"POST\"])\n    def index():\n        return \"Hello World\"\n\n    @app.route(\"/\", methods=[\"PUT\"])\n    def index_put():\n        return \"Aha!\"\n\n    rv = client.open(\"/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\", \"PUT\"]",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_options_on_multiple_rules` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.21,
      "evidence": [
        "function test_options_on_multiple_rules in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.24)"
      ]
    },
    {
      "name": "test_method_route",
      "description": "handle a HTTP route request and return response. Function `test_method_route`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_method_route(app, client, method):\n    method_route = getattr(app, method)\n    client_method = getattr(client, method)\n\n    @method_route(\"/\")\n    def hello():\n        return \"Hello\"\n\n    assert client_method(\"/\").data == b\"Hello\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          },
          "method": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client",
          "method"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string",
          "method": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_method_route` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.27,
      "evidence": [
        "function test_method_route in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.34)"
      ]
    },
    {
      "name": "test_method_route_no_methods",
      "description": "handle a HTTP route request and return response. Function `test_method_route_no_methods`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_method_route_no_methods(app):\n    with pytest.raises(TypeError):\n        app.get(\"/\", methods=[\"GET\", \"POST\"])",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_method_route_no_methods` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.26,
      "evidence": [
        "function test_method_route_no_methods in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.32)"
      ]
    },
    {
      "name": "test_provide_automatic_options_attr",
      "description": "handle a HTTP route request and return response. Function `test_provide_automatic_options_attr`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_provide_automatic_options_attr():\n    app = flask.Flask(__name__)\n\n    def index():\n        return \"Hello World!\"\n\n    index.provide_automatic_options = False\n    app.route(\"/\")(index)\n    rv = app.test_client().open(\"/\", method=\"OPTIONS\")\n    assert rv.status_code == 405\n\n    app = flask.Flask(__name__)\n\n    def index2():\n        return \"Hello World!\"\n\n    index2.provide_automatic_options = True\n    app.route(\"/\", methods=[\"OPTIONS\"])(index2)\n    rv = app.test_client().open(\"/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"OPTIONS\"]",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_provide_automatic_options_attr` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.18,
      "evidence": [
        "function test_provide_automatic_options_attr in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.17)"
      ]
    },
    {
      "name": "test_provide_automatic_options_kwarg",
      "description": "handle a HTTP route request and return response. Function `test_provide_automatic_options_kwarg`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_provide_automatic_options_kwarg(app, client):\n    def index():\n        return flask.request.method\n\n    def more():\n        return flask.request.method\n\n    app.add_url_rule(\"/\", view_func=index, provide_automatic_options=False)\n    app.add_url_rule(\n        \"/more\",\n        view_func=more,\n        methods=[\"GET\", \"POST\"],\n        provide_automatic_options=False,\n    )\n    assert client.get(\"/\").data == b\"GET\"\n\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\"]\n\n    rv = client.open(\"/\", method=\"OPTIONS\")\n    assert rv.status_code == 405\n\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"POST\"]\n\n    rv = client.open(\"/more\", method=\"OPTIONS\")\n    assert rv.status_code == 405",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_provide_automatic_options_kwarg` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.22,
      "evidence": [
        "function test_provide_automatic_options_kwarg in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.26)"
      ]
    },
    {
      "name": "test_request_dispatching",
      "description": "handle a HTTP route request and return response. Function `test_request_dispatching`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_request_dispatching(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.request.method\n\n    @app.route(\"/more\", methods=[\"GET\", \"POST\"])\n    def more():\n        return flask.request.method\n\n    assert client.get(\"/\").data == b\"GET\"\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\"]\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_request_dispatching` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.26,
      "evidence": [
        "function test_request_dispatching in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.33)"
      ]
    },
    {
      "name": "test_disallow_string_for_allowed_methods",
      "description": "handle a HTTP route request and return response. Function `test_disallow_string_for_allowed_methods`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_disallow_string_for_allowed_methods(app):\n    with pytest.raises(TypeError):\n        app.add_url_rule(\"/\", methods=\"GET POST\", endpoint=\"test\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_disallow_string_for_allowed_methods` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.22,
      "evidence": [
        "function test_disallow_string_for_allowed_methods in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.26)"
      ]
    },
    {
      "name": "test_url_mapping",
      "description": "make an HTTP request to an external API. Function `test_url_mapping`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_url_mapping(app, client):\n    random_uuid4 = \"7eb41166-9ebf-4d26-b771-ea3f54f8b383\"\n\n    def index():\n        return flask.request.method\n\n    def more():\n        return flask.request.method\n\n    def options():\n        return random_uuid4\n\n    app.add_url_rule(\"/\", \"index\", index)\n    app.add_url_rule(\"/more\", \"more\", more, methods=[\"GET\", \"POST\"])\n\n    # Issue 1288: Test that automatic options are not added\n    #             when non-uppercase 'options' in methods\n    app.add_url_rule(\"/options\", \"options\", options, methods=[\"options\"])\n\n    assert client.get(\"/\").data == b\"GET\"\n    rv = client.post(\"/\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\"]\n    rv = client.head(\"/\")\n    assert rv.status_code == 200\n    assert not rv.data  # head truncates\n    assert client.post(\"/more\").data == b\"POST\"\n    assert client.get(\"/more\").data == b\"GET\"\n    rv = client.delete(\"/more\")\n    assert rv.status_code == 405\n    assert sorted(rv.allow) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]\n    rv = client.open(\"/options\", method=\"OPTIONS\")\n    assert rv.status_code == 200\n    assert random_uuid4 in rv.data.decode(\"utf-8\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_url_mapping` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.18,
      "evidence": [
        "function test_url_mapping in tests\\test_basic.py",
        "matched template: make an HTTP request to an external API (sim=0.16)"
      ]
    },
    {
      "name": "test_werkzeug_routing",
      "description": "handle a HTTP route request and return response. Function `test_werkzeug_routing`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_werkzeug_routing(app, client):\n    from werkzeug.routing import Rule\n    from werkzeug.routing import Submount\n\n    app.url_map.add(\n        Submount(\"/foo\", [Rule(\"/bar\", endpoint=\"bar\"), Rule(\"/\", endpoint=\"index\")])\n    )\n\n    def bar():\n        return \"bar\"\n\n    def index():\n        return \"index\"\n\n    app.view_functions[\"bar\"] = bar\n    app.view_functions[\"index\"] = index\n\n    assert client.get(\"/foo/\").data == b\"index\"\n    assert client.get(\"/foo/bar\").data == b\"bar\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_werkzeug_routing` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.24,
      "evidence": [
        "function test_werkzeug_routing in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.29)"
      ]
    },
    {
      "name": "test_endpoint_decorator",
      "description": "handle a HTTP route request and return response. Function `test_endpoint_decorator`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_endpoint_decorator(app, client):\n    from werkzeug.routing import Rule\n    from werkzeug.routing import Submount\n\n    app.url_map.add(\n        Submount(\"/foo\", [Rule(\"/bar\", endpoint=\"bar\"), Rule(\"/\", endpoint=\"index\")])\n    )\n\n    @app.endpoint(\"bar\")\n    def bar():\n        return \"bar\"\n\n    @app.endpoint(\"index\")\n    def index():\n        return \"index\"\n\n    assert client.get(\"/foo/\").data == b\"index\"\n    assert client.get(\"/foo/bar\").data == b\"bar\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_endpoint_decorator` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.22,
      "evidence": [
        "function test_endpoint_decorator in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.25)"
      ]
    },
    {
      "name": "test_session",
      "description": "handle a HTTP route request and return response. Function `test_session`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_session(app, client):\n    @app.route(\"/set\", methods=[\"POST\"])\n    def set():\n        assert not flask.session.accessed\n        assert not flask.session.modified\n        flask.session[\"value\"] = flask.request.form[\"value\"]\n        assert flask.session.accessed\n        assert flask.session.modified\n        return \"value set\"\n\n    @app.route(\"/get\")\n    def get():\n        assert not flask.session.accessed\n        assert not flask.session.modified\n        v = flask.session.get(\"value\", \"None\")\n        assert flask.session.accessed\n        assert not flask.session.modified\n        return v\n\n    assert client.post(\"/set\", data={\"value\": \"42\"}).data == b\"value set\"\n    assert client.get(\"/get\").data == b\"42\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_session` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.24,
      "evidence": [
        "function test_session in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.29)"
      ]
    },
    {
      "name": "test_session_path",
      "description": "handle a HTTP route request and return response. Function `test_session_path`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_session_path(app, client):\n    app.config.update(APPLICATION_ROOT=\"/foo\")\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    rv = client.get(\"/\", \"http://example.com:8080/foo\")\n    assert \"path=/foo\" in rv.headers[\"set-cookie\"].lower()",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_session_path` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.24,
      "evidence": [
        "function test_session_path in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.29)"
      ]
    },
    {
      "name": "test_session_using_application_root",
      "description": "handle a HTTP route request and return response. Function `test_session_using_application_root`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_session_using_application_root(app, client):\n    class PrefixPathMiddleware:\n        def __init__(self, app, prefix):\n            self.app = app\n            self.prefix = prefix\n\n        def __call__(self, environ, start_response):\n            environ[\"SCRIPT_NAME\"] = self.prefix\n            return self.app(environ, start_response)\n\n    app.wsgi_app = PrefixPathMiddleware(app.wsgi_app, \"/bar\")\n    app.config.update(APPLICATION_ROOT=\"/bar\")\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    rv = client.get(\"/\", \"http://example.com:8080/\")\n    assert \"path=/bar\" in rv.headers[\"set-cookie\"].lower()",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_session_using_application_root` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.21,
      "evidence": [
        "function test_session_using_application_root in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.23)"
      ]
    },
    {
      "name": "test_session_using_session_settings",
      "description": "handle a HTTP route request and return response. Function `test_session_using_session_settings`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_session_using_session_settings(app, client):\n    app.config.update(\n        SERVER_NAME=\"www.example.com:8080\",\n        APPLICATION_ROOT=\"/test\",\n        SESSION_COOKIE_DOMAIN=\".example.com\",\n        SESSION_COOKIE_HTTPONLY=False,\n        SESSION_COOKIE_SECURE=True,\n        SESSION_COOKIE_PARTITIONED=True,\n        SESSION_COOKIE_SAMESITE=\"Lax\",\n        SESSION_COOKIE_PATH=\"/\",\n    )\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    @app.route(\"/clear\")\n    def clear():\n        flask.session.pop(\"testing\", None)\n        return \"Goodbye World\"\n\n    rv = client.get(\"/\", \"http://www.example.com:8080/test/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    # or condition for Werkzeug < 2.3\n    assert \"domain=example.com\" in cookie or \"domain=.example.com\" in cookie\n    assert \"path=/\" in cookie\n    assert \"secure\" in cookie\n    assert \"httponly\" not in cookie\n    assert \"samesite\" in cookie\n    assert \"partitioned\" in cookie\n\n    rv = client.get(\"/clear\", \"http://www.example.com:8080/test/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"session=;\" in cookie\n    # or condition for Werkzeug < 2.3\n    assert \"domain=example.com\" in cookie or \"domain=.example.com\" in cookie\n    assert \"path=/\" in cookie\n    assert \"secure\" in cookie\n    assert \"samesite\" in cookie\n    assert \"partitioned\" in cookie",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_session_using_session_settings` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.22,
      "evidence": [
        "function test_session_using_session_settings in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.25)"
      ]
    },
    {
      "name": "test_session_using_samesite_attribute",
      "description": "authenticate a user and return a token. Function `test_session_using_samesite_attribute`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_session_using_samesite_attribute(app, client):\n    @app.route(\"/\")\n    def index():\n        flask.session[\"testing\"] = 42\n        return \"Hello World\"\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"invalid\")\n\n    with pytest.raises(ValueError):\n        client.get(\"/\")\n\n    app.config.update(SESSION_COOKIE_SAMESITE=None)\n    rv = client.get(\"/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite\" not in cookie\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"Strict\")\n    rv = client.get(\"/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite=strict\" in cookie\n\n    app.config.update(SESSION_COOKIE_SAMESITE=\"Lax\")\n    rv = client.get(\"/\")\n    cookie = rv.headers[\"set-cookie\"].lower()\n    assert \"samesite=lax\" in cookie",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_session_using_samesite_attribute` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.19,
      "evidence": [
        "function test_session_using_samesite_attribute in tests\\test_basic.py",
        "matched template: authenticate a user and return a token (sim=0.18)"
      ]
    },
    {
      "name": "test_missing_session",
      "description": "authenticate a user and return a token. Function `test_missing_session`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_missing_session(app):\n    app.secret_key = None\n\n    def expect_exception(f, *args, **kwargs):\n        e = pytest.raises(RuntimeError, f, *args, **kwargs)\n        assert e.value.args and \"session is unavailable\" in e.value.args[0]\n\n    with app.test_request_context():\n        assert flask.session.get(\"missing_key\") is None\n        expect_exception(flask.session.__setitem__, \"foo\", 42)\n        expect_exception(flask.session.pop, \"foo\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_missing_session` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.18,
      "evidence": [
        "function test_missing_session in tests\\test_basic.py",
        "matched template: authenticate a user and return a token (sim=0.16)"
      ]
    },
    {
      "name": "test_session_secret_key_fallbacks",
      "description": "authenticate a user and return a token. Function `test_session_secret_key_fallbacks`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_session_secret_key_fallbacks(app, client) -> None:\n    @app.post(\"/\")\n    def set_session() -> str:\n        flask.session[\"a\"] = 1\n        return \"\"\n\n    @app.get(\"/\")\n    def get_session() -> dict[str, t.Any]:\n        return dict(flask.session)\n\n    # Set session with initial secret key, and two valid expiring keys\n    app.secret_key, app.config[\"SECRET_KEY_FALLBACKS\"] = (\n        \"0 key\",\n        [\"-1 key\", \"-2 key\"],\n    )\n    client.post()\n    assert client.get().json == {\"a\": 1}\n    # Change secret key, session can't be loaded and appears empty\n    app.secret_key = \"? key\"\n    assert client.get().json == {}\n    # Rotate the valid keys, session can be loaded\n    app.secret_key, app.config[\"SECRET_KEY_FALLBACKS\"] = (\n        \"+1 key\",\n        [\"0 key\", \"-1 key\"],\n    )\n    assert client.get().json == {\"a\": 1}",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `test_session_secret_key_fallbacks` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.19,
      "evidence": [
        "function test_session_secret_key_fallbacks in tests\\test_basic.py",
        "matched template: authenticate a user and return a token (sim=0.19)"
      ]
    },
    {
      "name": "test_session_expiration",
      "description": "handle a HTTP route request and return response. Function `test_session_expiration`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_session_expiration(app, client):\n    permanent = True\n\n    @app.route(\"/\")\n    def index():\n        flask.session[\"test\"] = 42\n        flask.session.permanent = permanent\n        return \"\"\n\n    @app.route(\"/test\")\n    def test():\n        return str(flask.session.permanent)\n\n    rv = client.get(\"/\")\n    assert \"set-cookie\" in rv.headers\n    match = re.search(r\"(?i)\\bexpires=([^;]+)\", rv.headers[\"set-cookie\"])\n    expires = parse_date(match.group())\n    expected = datetime.now(timezone.utc) + app.permanent_session_lifetime\n    assert expires.year == expected.year\n    assert expires.month == expected.month\n    assert expires.day == expected.day\n\n    rv = client.get(\"/test\")\n    assert rv.data == b\"True\"\n\n    permanent = False\n    rv = client.get(\"/\")\n    assert \"set-cookie\" in rv.headers\n    match = re.search(r\"\\bexpires=([^;]+)\", rv.headers[\"set-cookie\"])\n    assert match is None",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_session_expiration` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.21,
      "evidence": [
        "function test_session_expiration in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.22)"
      ]
    },
    {
      "name": "test_session_stored_last",
      "description": "handle a HTTP route request and return response. Function `test_session_stored_last`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_session_stored_last(app, client):\n    @app.after_request\n    def modify_session(response):\n        flask.session[\"foo\"] = 42\n        return response\n\n    @app.route(\"/\")\n    def dump_session_contents():\n        return repr(flask.session.get(\"foo\"))\n\n    assert client.get(\"/\").data == b\"None\"\n    assert client.get(\"/\").data == b\"42\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_session_stored_last` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.21,
      "evidence": [
        "function test_session_stored_last in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.24)"
      ]
    },
    {
      "name": "test_session_special_types",
      "description": "stream data over websocket. Function `test_session_special_types`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_session_special_types(app, client):\n    now = datetime.now(timezone.utc).replace(microsecond=0)\n    the_uuid = uuid.uuid4()\n\n    @app.route(\"/\")\n    def dump_session_contents():\n        flask.session[\"t\"] = (1, 2, 3)\n        flask.session[\"b\"] = b\"\\xff\"\n        flask.session[\"m\"] = Markup(\"<html>\")\n        flask.session[\"u\"] = the_uuid\n        flask.session[\"d\"] = now\n        flask.session[\"t_tag\"] = {\" t\": \"not-a-tuple\"}\n        flask.session[\"di_t_tag\"] = {\" t__\": \"not-a-tuple\"}\n        flask.session[\"di_tag\"] = {\" di\": \"not-a-dict\"}\n        return \"\", 204\n\n    with client:\n        client.get(\"/\")\n        s = flask.session\n        assert s[\"t\"] == (1, 2, 3)\n        assert type(s[\"b\"]) is bytes  # noqa: E721\n        assert s[\"b\"] == b\"\\xff\"\n        assert type(s[\"m\"]) is Markup  # noqa: E721\n        assert s[\"m\"] == Markup(\"<html>\")\n        assert s[\"u\"] == the_uuid\n        assert s[\"d\"] == now\n        assert s[\"t_tag\"] == {\" t\": \"not-a-tuple\"}\n        assert s[\"di_t_tag\"] == {\" t__\": \"not-a-tuple\"}\n        assert s[\"di_tag\"] == {\" di\": \"not-a-dict\"}",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_session_special_types` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.21,
      "evidence": [
        "function test_session_special_types in tests\\test_basic.py",
        "matched template: stream data over websocket (sim=0.22)"
      ]
    },
    {
      "name": "test_session_cookie_setting",
      "description": "handle a HTTP route request and return response. Function `test_session_cookie_setting`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_session_cookie_setting(app):\n    is_permanent = True\n\n    @app.route(\"/bump\")\n    def bump():\n        rv = flask.session[\"foo\"] = flask.session.get(\"foo\", 0) + 1\n        flask.session.permanent = is_permanent\n        return str(rv)\n\n    @app.route(\"/read\")\n    def read():\n        return str(flask.session.get(\"foo\", 0))\n\n    def run_test(expect_header):\n        with app.test_client() as c:\n            assert c.get(\"/bump\").data == b\"1\"\n            assert c.get(\"/bump\").data == b\"2\"\n            assert c.get(\"/bump\").data == b\"3\"\n\n            rv = c.get(\"/read\")\n            set_cookie = rv.headers.get(\"set-cookie\")\n            assert (set_cookie is not None) == expect_header\n            assert rv.data == b\"3\"\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=True)\n\n    is_permanent = True\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = True\n    run_test(expect_header=False)\n\n    is_permanent = False\n    app.config[\"SESSION_REFRESH_EACH_REQUEST\"] = False\n    run_test(expect_header=False)",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_session_cookie_setting` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.23,
      "evidence": [
        "function test_session_cookie_setting in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.28)"
      ]
    },
    {
      "name": "test_session_vary_cookie",
      "description": "handle a HTTP route request and return response. Function `test_session_vary_cookie`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_session_vary_cookie(app, client):\n    @app.route(\"/set\")\n    def set_session():\n        flask.session[\"test\"] = \"test\"\n        return \"\"\n\n    @app.route(\"/get\")\n    def get():\n        return flask.session.get(\"test\")\n\n    @app.route(\"/getitem\")\n    def getitem():\n        return flask.session[\"test\"]\n\n    @app.route(\"/setdefault\")\n    def setdefault():\n        return flask.session.setdefault(\"test\", \"default\")\n\n    @app.route(\"/clear\")\n    def clear():\n        flask.session.clear()\n        return \"\"\n\n    @app.route(\"/vary-cookie-header-set\")\n    def vary_cookie_header_set():\n        response = flask.Response()\n        response.vary.add(\"Cookie\")\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/vary-header-set\")\n    def vary_header_set():\n        response = flask.Response()\n        response.vary.update((\"Accept-Encoding\", \"Accept-Language\"))\n        flask.session[\"test\"] = \"test\"\n        return response\n\n    @app.route(\"/no-vary-header\")\n    def no_vary_header():\n        return \"\"\n\n    def expect(path, header_value=\"Cookie\"):\n        rv = client.get(path)\n\n        if header_value:\n            # The 'Vary' key should exist in the headers only once.\n            assert len(rv.headers.get_all(\"Vary\")) == 1\n            assert rv.headers[\"Vary\"] == header_value\n        else:\n            assert \"Vary\" not in rv.headers\n\n    expect(\"/set\")\n    expect(\"/get\")\n    expect(\"/getitem\")\n    expect(\"/setdefault\")\n    expect(\"/clear\")\n    expect(\"/vary-cookie-header-set\")\n    expect(\"/vary-header-set\", \"Accept-Encoding, Accept-Language, Cookie\")\n    expect(\"/no-vary-header\", None)",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_session_vary_cookie` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.27,
      "evidence": [
        "function test_session_vary_cookie in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.34)"
      ]
    },
    {
      "name": "test_session_refresh_vary",
      "description": "authenticate a user and return a token. Function `test_session_refresh_vary`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_session_refresh_vary(app, client):\n    @app.get(\"/login\")\n    def login():\n        flask.session[\"user_id\"] = 1\n        flask.session.permanent = True\n        return \"\"\n\n    @app.get(\"/ignored\")\n    def ignored():\n        return \"\"\n\n    rv = client.get(\"/login\")\n    assert rv.headers[\"Vary\"] == \"Cookie\"\n    rv = client.get(\"/ignored\")\n    assert rv.headers[\"Vary\"] == \"Cookie\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_session_refresh_vary` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.23,
      "evidence": [
        "function test_session_refresh_vary in tests\\test_basic.py",
        "matched template: authenticate a user and return a token (sim=0.27)"
      ]
    },
    {
      "name": "test_flashes",
      "description": "stream data over websocket. Function `test_flashes`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_flashes(app, req_ctx):\n    assert not flask.session.modified\n    flask.flash(\"Zap\")\n    flask.session.modified = False\n    flask.flash(\"Zip\")\n    assert flask.session.modified\n    assert list(flask.get_flashed_messages()) == [\"Zap\", \"Zip\"]",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "req_ctx": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "req_ctx"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "req_ctx": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_flashes` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.19,
      "evidence": [
        "function test_flashes in tests\\test_basic.py",
        "matched template: stream data over websocket (sim=0.17)"
      ]
    },
    {
      "name": "test_extended_flashing",
      "description": "handle a HTTP route request and return response. Function `test_extended_flashing`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_extended_flashing(app):\n    # Be sure app.testing=True below, else tests can fail silently.\n    #\n    # Specifically, if app.testing is not set to True, the AssertionErrors\n    # in the view functions will cause a 500 response to the test client\n    # instead of propagating exceptions.\n\n    @app.route(\"/\")\n    def index():\n        flask.flash(\"Hello World\")\n        flask.flash(\"Hello World\", \"error\")\n        flask.flash(Markup(\"<em>Testing</em>\"), \"warning\")\n        return \"\"\n\n    @app.route(\"/test/\")\n    def test():\n        messages = flask.get_flashed_messages()\n        assert list(messages) == [\n            \"Hello World\",\n            \"Hello World\",\n            Markup(\"<em>Testing</em>\"),\n        ]\n        return \"\"\n\n    @app.route(\"/test_with_categories/\")\n    def test_with_categories():\n        messages = flask.get_flashed_messages(with_categories=True)\n        assert len(messages) == 3\n        assert list(messages) == [\n            (\"message\", \"Hello World\"),\n            (\"error\", \"Hello World\"),\n            (\"warning\", Markup(\"<em>Testing</em>\")),\n        ]\n        return \"\"\n\n    @app.route(\"/test_filter/\")\n    def test_filter():\n        messages = flask.get_flashed_messages(\n            category_filter=[\"message\"], with_categories=True\n        )\n        assert list(messages) == [(\"message\", \"Hello World\")]\n        return \"\"\n\n    @app.route(\"/test_filters/\")\n    def test_filters():\n        messages = flask.get_flashed_messages(\n            category_filter=[\"message\", \"warning\"], with_categories=True\n        )\n        assert list(messages) == [\n            (\"message\", \"Hello World\"),\n            (\"warning\", Markup(\"<em>Testing</em>\")),\n        ]\n        return \"\"\n\n    @app.route(\"/test_filters_without_returning_categories/\")\n    def test_filters2():\n        messages = flask.get_flashed_messages(category_filter=[\"message\", \"warning\"])\n        assert len(messages) == 2\n        assert messages[0] == \"Hello World\"\n        assert messages[1] == Markup(\"<em>Testing</em>\")\n        return \"\"\n\n    # Create new test client on each test to clean flashed messages.\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_with_categories/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filter/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filters/\")\n\n    client = app.test_client()\n    client.get(\"/\")\n    client.get(\"/test_filters_without_returning_categories/\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_extended_flashing` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.19,
      "evidence": [
        "function test_extended_flashing in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.18)"
      ]
    },
    {
      "name": "test_request_processing",
      "description": "handle a HTTP route request and return response. Function `test_request_processing`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_request_processing(app, client):\n    evts = []\n\n    @app.before_request\n    def before_request():\n        evts.append(\"before\")\n\n    @app.after_request\n    def after_request(response):\n        response.data += b\"|after\"\n        evts.append(\"after\")\n        return response\n\n    @app.route(\"/\")\n    def index():\n        assert \"before\" in evts\n        assert \"after\" not in evts\n        return \"request\"\n\n    assert \"after\" not in evts\n    rv = client.get(\"/\").data\n    assert \"after\" in evts\n    assert rv == b\"request|after\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_request_processing` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.22,
      "evidence": [
        "function test_request_processing in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.26)"
      ]
    },
    {
      "name": "test_request_preprocessing_early_return",
      "description": "handle a HTTP route request and return response. Function `test_request_preprocessing_early_return`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_request_preprocessing_early_return(app, client):\n    evts = []\n\n    @app.before_request\n    def before_request1():\n        evts.append(1)\n\n    @app.before_request\n    def before_request2():\n        evts.append(2)\n        return \"hello\"\n\n    @app.before_request\n    def before_request3():\n        evts.append(3)\n        return \"bye\"\n\n    @app.route(\"/\")\n    def index():\n        evts.append(\"index\")\n        return \"damnit\"\n\n    rv = client.get(\"/\").data.strip()\n    assert rv == b\"hello\"\n    assert evts == [1, 2]",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_request_preprocessing_early_return` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.22,
      "evidence": [
        "function test_request_preprocessing_early_return in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.25)"
      ]
    },
    {
      "name": "test_after_request_processing",
      "description": "handle a HTTP route request and return response. Function `test_after_request_processing`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_after_request_processing(app, client):\n    @app.route(\"/\")\n    def index():\n        @flask.after_this_request\n        def foo(response):\n            response.headers[\"X-Foo\"] = \"a header\"\n            return response\n\n        return \"Test\"\n\n    resp = client.get(\"/\")\n    assert resp.status_code == 200\n    assert resp.headers[\"X-Foo\"] == \"a header\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_after_request_processing` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.29,
      "evidence": [
        "function test_after_request_processing in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.38)"
      ]
    },
    {
      "name": "test_teardown_request_handler",
      "description": "handle a HTTP route request and return response. Function `test_teardown_request_handler`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_teardown_request_handler(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_request(exc):\n        called.append(True)\n        return \"Ignored\"\n\n    @app.route(\"/\")\n    def root():\n        return \"Response\"\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 200\n    assert b\"Response\" in rv.data\n    assert len(called) == 1",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_teardown_request_handler` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.25,
      "evidence": [
        "function test_teardown_request_handler in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.30)"
      ]
    },
    {
      "name": "test_teardown_request_handler_debug_mode",
      "description": "handle a HTTP route request and return response. Function `test_teardown_request_handler_debug_mode`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_teardown_request_handler_debug_mode(app, client):\n    called = []\n\n    @app.teardown_request\n    def teardown_request(exc):\n        called.append(True)\n        return \"Ignored\"\n\n    @app.route(\"/\")\n    def root():\n        return \"Response\"\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 200\n    assert b\"Response\" in rv.data\n    assert len(called) == 1",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_teardown_request_handler_debug_mode` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.23,
      "evidence": [
        "function test_teardown_request_handler_debug_mode in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.28)"
      ]
    },
    {
      "name": "test_teardown_request_handler_error",
      "description": "handle a HTTP route request and return response. Function `test_teardown_request_handler_error`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_teardown_request_handler_error(app, client):\n    called = []\n    app.testing = False\n\n    @app.teardown_request\n    def teardown_request1(exc):\n        assert type(exc) is ZeroDivisionError\n        called.append(True)\n        # This raises a new error and blows away sys.exc_info(), so we can\n        # test that all teardown_requests get passed the same original\n        # exception.\n        try:\n            raise TypeError()\n        except Exception:\n            pass\n\n    @app.teardown_request\n    def teardown_request2(exc):\n        assert type(exc) is ZeroDivisionError\n        called.append(True)\n        # This raises a new error and blows away sys.exc_info(), so we can\n        # test that all teardown_requests get passed the same original\n        # exception.\n        try:\n            raise TypeError()\n        except Exception:\n            pass\n\n    @app.route(\"/\")\n    def fails():\n        raise ZeroDivisionError\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 500\n    assert b\"Internal Server Error\" in rv.data\n    assert len(called) == 2",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_teardown_request_handler_error` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.2,
      "evidence": [
        "function test_teardown_request_handler_error in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.22)"
      ]
    },
    {
      "name": "test_before_after_request_order",
      "description": "handle a HTTP route request and return response. Function `test_before_after_request_order`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_before_after_request_order(app, client):\n    called = []\n\n    @app.before_request\n    def before1():\n        called.append(1)\n\n    @app.before_request\n    def before2():\n        called.append(2)\n\n    @app.after_request\n    def after1(response):\n        called.append(4)\n        return response\n\n    @app.after_request\n    def after2(response):\n        called.append(3)\n        return response\n\n    @app.teardown_request\n    def finish1(exc):\n        called.append(6)\n\n    @app.teardown_request\n    def finish2(exc):\n        called.append(5)\n\n    @app.route(\"/\")\n    def index():\n        return \"42\"\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"42\"\n    assert called == [1, 2, 3, 4, 5, 6]",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_before_after_request_order` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.24,
      "evidence": [
        "function test_before_after_request_order in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.29)"
      ]
    },
    {
      "name": "test_error_handling",
      "description": "handle a HTTP route request and return response. Function `test_error_handling`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_error_handling(app, client):\n    app.testing = False\n\n    @app.errorhandler(404)\n    def not_found(e):\n        return \"not found\", 404\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"internal server error\", 500\n\n    @app.errorhandler(Forbidden)\n    def forbidden(e):\n        return \"forbidden\", 403\n\n    @app.route(\"/\")\n    def index():\n        flask.abort(404)\n\n    @app.route(\"/error\")\n    def error():\n        raise ZeroDivisionError\n\n    @app.route(\"/forbidden\")\n    def error2():\n        flask.abort(403)\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 404\n    assert rv.data == b\"not found\"\n    rv = client.get(\"/error\")\n    assert rv.status_code == 500\n    assert b\"internal server error\" == rv.data\n    rv = client.get(\"/forbidden\")\n    assert rv.status_code == 403\n    assert b\"forbidden\" == rv.data",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_error_handling` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.26,
      "evidence": [
        "function test_error_handling in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.33)"
      ]
    },
    {
      "name": "test_error_handling_processing",
      "description": "handle a HTTP route request and return response. Function `test_error_handling_processing`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_error_handling_processing(app, client):\n    app.testing = False\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"internal server error\", 500\n\n    @app.route(\"/\")\n    def broken_func():\n        raise ZeroDivisionError\n\n    @app.after_request\n    def after_request(resp):\n        resp.mimetype = \"text/x-special\"\n        return resp\n\n    resp = client.get(\"/\")\n    assert resp.mimetype == \"text/x-special\"\n    assert resp.data == b\"internal server error\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_error_handling_processing` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.21,
      "evidence": [
        "function test_error_handling_processing in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.23)"
      ]
    },
    {
      "name": "test_baseexception_error_handling",
      "description": "handle a HTTP route request and return response. Function `test_baseexception_error_handling`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_baseexception_error_handling(app, client):\n    app.testing = False\n\n    @app.route(\"/\")\n    def broken_func():\n        raise KeyboardInterrupt()\n\n    with pytest.raises(KeyboardInterrupt):\n        client.get(\"/\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_baseexception_error_handling` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.19,
      "evidence": [
        "function test_baseexception_error_handling in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.19)"
      ]
    },
    {
      "name": "test_before_request_and_routing_errors",
      "description": "handle a HTTP route request and return response. Function `test_before_request_and_routing_errors`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_before_request_and_routing_errors(app, client):\n    @app.before_request\n    def attach_something():\n        flask.g.something = \"value\"\n\n    @app.errorhandler(404)\n    def return_something(error):\n        return flask.g.something, 404\n\n    rv = client.get(\"/\")\n    assert rv.status_code == 404\n    assert rv.data == b\"value\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_before_request_and_routing_errors` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.27,
      "evidence": [
        "function test_before_request_and_routing_errors in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.34)"
      ]
    },
    {
      "name": "test_user_error_handling",
      "description": "handle a HTTP route request and return response. Function `test_user_error_handling`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_user_error_handling(app, client):\n    class MyException(Exception):\n        pass\n\n    @app.errorhandler(MyException)\n    def handle_my_exception(e):\n        assert isinstance(e, MyException)\n        return \"42\"\n\n    @app.route(\"/\")\n    def index():\n        raise MyException()\n\n    assert client.get(\"/\").data == b\"42\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_user_error_handling` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.22,
      "evidence": [
        "function test_user_error_handling in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.26)"
      ]
    },
    {
      "name": "test_http_error_subclass_handling",
      "description": "handle a HTTP route request and return response. Function `test_http_error_subclass_handling`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_http_error_subclass_handling(app, client):\n    class ForbiddenSubclass(Forbidden):\n        pass\n\n    @app.errorhandler(ForbiddenSubclass)\n    def handle_forbidden_subclass(e):\n        assert isinstance(e, ForbiddenSubclass)\n        return \"banana\"\n\n    @app.errorhandler(403)\n    def handle_403(e):\n        assert not isinstance(e, ForbiddenSubclass)\n        assert isinstance(e, Forbidden)\n        return \"apple\"\n\n    @app.route(\"/1\")\n    def index1():\n        raise ForbiddenSubclass()\n\n    @app.route(\"/2\")\n    def index2():\n        flask.abort(403)\n\n    @app.route(\"/3\")\n    def index3():\n        raise Forbidden()\n\n    assert client.get(\"/1\").data == b\"banana\"\n    assert client.get(\"/2\").data == b\"apple\"\n    assert client.get(\"/3\").data == b\"apple\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_http_error_subclass_handling` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.25,
      "evidence": [
        "function test_http_error_subclass_handling in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.31)"
      ]
    },
    {
      "name": "test_errorhandler_precedence",
      "description": "handle a HTTP route request and return response. Function `test_errorhandler_precedence`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_errorhandler_precedence(app, client):\n    class E1(Exception):\n        pass\n\n    class E2(Exception):\n        pass\n\n    class E3(E1, E2):\n        pass\n\n    @app.errorhandler(E2)\n    def handle_e2(e):\n        return \"E2\"\n\n    @app.errorhandler(Exception)\n    def handle_exception(e):\n        return \"Exception\"\n\n    @app.route(\"/E1\")\n    def raise_e1():\n        raise E1\n\n    @app.route(\"/E3\")\n    def raise_e3():\n        raise E3\n\n    rv = client.get(\"/E1\")\n    assert rv.data == b\"Exception\"\n\n    rv = client.get(\"/E3\")\n    assert rv.data == b\"E2\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_errorhandler_precedence` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.21,
      "evidence": [
        "function test_errorhandler_precedence in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.24)"
      ]
    },
    {
      "name": "test_trap_bad_request_key_error",
      "description": "handle a HTTP route request and return response. Function `test_trap_bad_request_key_error`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_trap_bad_request_key_error(app, client, debug, trap, expect_key, expect_abort):\n    app.config[\"DEBUG\"] = debug\n    app.config[\"TRAP_BAD_REQUEST_ERRORS\"] = trap\n\n    @app.route(\"/key\")\n    def fail():\n        flask.request.form[\"missing_key\"]\n\n    @app.route(\"/abort\")\n    def allow_abort():\n        flask.abort(400)\n\n    if expect_key:\n        rv = client.get(\"/key\")\n        assert rv.status_code == 400\n        assert b\"missing_key\" not in rv.data\n    else:\n        with pytest.raises(KeyError) as exc_info:\n            client.get(\"/key\")\n\n        assert exc_info.errisinstance(BadRequest)\n        assert \"missing_key\" in exc_info.value.get_description()\n\n    if expect_abort:\n        rv = client.get(\"/abort\")\n        assert rv.status_code == 400\n    else:\n        with pytest.raises(BadRequest):\n            client.get(\"/abort\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          },
          "debug": {
            "type": "string",
            "required": true
          },
          "trap": {
            "type": "string",
            "required": true
          },
          "expect_key": {
            "type": "string",
            "required": true
          },
          "expect_abort": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client",
          "debug",
          "trap",
          "expect_key",
          "expect_abort"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string",
          "debug": "string",
          "trap": "string",
          "expect_key": "string",
          "expect_abort": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_trap_bad_request_key_error` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.2,
      "evidence": [
        "function test_trap_bad_request_key_error in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.22)"
      ]
    },
    {
      "name": "test_trapping_of_all_http_exceptions",
      "description": "handle a HTTP route request and return response. Function `test_trapping_of_all_http_exceptions`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_trapping_of_all_http_exceptions(app, client):\n    app.config[\"TRAP_HTTP_EXCEPTIONS\"] = True\n\n    @app.route(\"/fail\")\n    def fail():\n        flask.abort(404)\n\n    with pytest.raises(NotFound):\n        client.get(\"/fail\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_trapping_of_all_http_exceptions` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.22,
      "evidence": [
        "function test_trapping_of_all_http_exceptions in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.25)"
      ]
    },
    {
      "name": "test_error_handler_after_processor_error",
      "description": "handle a HTTP route request and return response. Function `test_error_handler_after_processor_error`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_error_handler_after_processor_error(app, client):\n    app.testing = False\n\n    @app.before_request\n    def before_request():\n        if _trigger == \"before\":\n            raise ZeroDivisionError\n\n    @app.after_request\n    def after_request(response):\n        if _trigger == \"after\":\n            raise ZeroDivisionError\n\n        return response\n\n    @app.route(\"/\")\n    def index():\n        return \"Foo\"\n\n    @app.errorhandler(500)\n    def internal_server_error(e):\n        return \"Hello Server Error\", 500\n\n    for _trigger in \"before\", \"after\":\n        rv = client.get(\"/\")\n        assert rv.status_code == 500\n        assert rv.data == b\"Hello Server Error\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_error_handler_after_processor_error` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.2,
      "evidence": [
        "function test_error_handler_after_processor_error in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.20)"
      ]
    },
    {
      "name": "test_enctype_debug_helper",
      "description": "write data to a file. Function `test_enctype_debug_helper`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_enctype_debug_helper(app, client):\n    from flask.debughelpers import DebugFilesKeyError\n\n    app.debug = True\n\n    @app.route(\"/fail\", methods=[\"POST\"])\n    def index():\n        return flask.request.files[\"foo\"].filename\n\n    with pytest.raises(DebugFilesKeyError) as e:\n        client.post(\"/fail\", data={\"foo\": \"index.txt\"})\n    assert \"no file contents were transmitted\" in str(e.value)\n    assert \"This was submitted: 'index.txt'\" in str(e.value)",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_enctype_debug_helper` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.27,
      "evidence": [
        "function test_enctype_debug_helper in tests\\test_basic.py",
        "matched template: write data to a file (sim=0.34)"
      ]
    },
    {
      "name": "test_response_types",
      "description": "handle a HTTP route request and return response. Function `test_response_types`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_response_types(app, client):\n    @app.route(\"/text\")\n    def from_text():\n        return \"H\u00e4llo W\u00f6rld\"\n\n    @app.route(\"/bytes\")\n    def from_bytes():\n        return \"H\u00e4llo W\u00f6rld\".encode()\n\n    @app.route(\"/full_tuple\")\n    def from_full_tuple():\n        return (\n            \"Meh\",\n            400,\n            {\"X-Foo\": \"Testing\", \"Content-Type\": \"text/plain; charset=utf-8\"},\n        )\n\n    @app.route(\"/text_headers\")\n    def from_text_headers():\n        return \"Hello\", {\"X-Foo\": \"Test\", \"Content-Type\": \"text/plain; charset=utf-8\"}\n\n    @app.route(\"/text_status\")\n    def from_text_status():\n        return \"Hi, status!\", 400\n\n    @app.route(\"/response_headers\")\n    def from_response_headers():\n        return (\n            flask.Response(\n                \"Hello world\", 404, {\"Content-Type\": \"text/html\", \"X-Foo\": \"Baz\"}\n            ),\n            {\"Content-Type\": \"text/plain\", \"X-Foo\": \"Bar\", \"X-Bar\": \"Foo\"},\n        )\n\n    @app.route(\"/response_status\")\n    def from_response_status():\n        return app.response_class(\"Hello world\", 400), 500\n\n    @app.route(\"/wsgi\")\n    def from_wsgi():\n        return NotFound()\n\n    @app.route(\"/dict\")\n    def from_dict():\n        return {\"foo\": \"bar\"}, 201\n\n    @app.route(\"/list\")\n    def from_list():\n        return [\"foo\", \"bar\"], 201\n\n    assert client.get(\"/text\").data == \"H\u00e4llo W\u00f6rld\".encode()\n    assert client.get(\"/bytes\").data == \"H\u00e4llo W\u00f6rld\".encode()\n\n    rv = client.get(\"/full_tuple\")\n    assert rv.data == b\"Meh\"\n    assert rv.headers[\"X-Foo\"] == \"Testing\"\n    assert rv.status_code == 400\n    assert rv.mimetype == \"text/plain\"\n\n    rv = client.get(\"/text_headers\")\n    assert rv.data == b\"Hello\"\n    assert rv.headers[\"X-Foo\"] == \"Test\"\n    assert rv.status_code == 200\n    assert rv.mimetype == \"text/plain\"\n\n    rv = client.get(\"/text_status\")\n    assert rv.data == b\"Hi, status!\"\n    assert rv.status_code == 400\n    assert rv.mimetype == \"text/html\"\n\n    rv = client.get(\"/response_headers\")\n    assert rv.data == b\"Hello world\"\n    assert rv.content_type == \"text/plain\"\n    assert rv.headers.getlist(\"X-Foo\") == [\"Bar\"]\n    assert rv.headers[\"X-Bar\"] == \"Foo\"\n    assert rv.status_code == 404\n\n    rv = client.get(\"/response_status\")\n    assert rv.data == b\"Hello world\"\n    assert rv.status_code == 500\n\n    rv = client.get(\"/wsgi\")\n    assert b\"Not Found\" in rv.data\n    assert rv.status_code == 404\n\n    rv = client.get(\"/dict\")\n    assert rv.json == {\"foo\": \"bar\"}\n    assert rv.status_code == 201\n\n    rv = client.get(\"/list\")\n    assert rv.json == [\"foo\", \"bar\"]\n    assert rv.status_code == 201",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_response_types` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.35,
      "evidence": [
        "function test_response_types in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.46)"
      ]
    },
    {
      "name": "test_response_type_errors",
      "description": "handle a HTTP route request and return response. Function `test_response_type_errors`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_response_type_errors():\n    app = flask.Flask(__name__)\n    app.testing = True\n\n    @app.route(\"/none\")\n    def from_none():\n        pass\n\n    @app.route(\"/small_tuple\")\n    def from_small_tuple():\n        return (\"Hello\",)\n\n    @app.route(\"/large_tuple\")\n    def from_large_tuple():\n        return \"Hello\", 234, {\"X-Foo\": \"Bar\"}, \"???\"\n\n    @app.route(\"/bad_type\")\n    def from_bad_type():\n        return True\n\n    @app.route(\"/bad_wsgi\")\n    def from_bad_wsgi():\n        return lambda: None\n\n    c = app.test_client()\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"/none\")\n\n    assert \"returned None\" in str(e.value)\n    assert \"from_none\" in str(e.value)\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"/small_tuple\")\n\n    assert \"tuple must have the form\" in str(e.value)\n\n    with pytest.raises(TypeError):\n        c.get(\"/large_tuple\")\n\n    with pytest.raises(TypeError) as e:\n        c.get(\"/bad_type\")\n\n    assert \"it was a bool\" in str(e.value)\n\n    with pytest.raises(TypeError):\n        c.get(\"/bad_wsgi\")",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_response_type_errors` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.27,
      "evidence": [
        "function test_response_type_errors in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.34)"
      ]
    },
    {
      "name": "test_make_response",
      "description": "handle a HTTP route request and return response. Function `test_make_response`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_make_response(app, req_ctx):\n    rv = flask.make_response()\n    assert rv.status_code == 200\n    assert rv.data == b\"\"\n    assert rv.mimetype == \"text/html\"\n\n    rv = flask.make_response(\"Awesome\")\n    assert rv.status_code == 200\n    assert rv.data == b\"Awesome\"\n    assert rv.mimetype == \"text/html\"\n\n    rv = flask.make_response(\"W00t\", 404)\n    assert rv.status_code == 404\n    assert rv.data == b\"W00t\"\n    assert rv.mimetype == \"text/html\"\n\n    rv = flask.make_response(c for c in \"Hello\")\n    assert rv.status_code == 200\n    assert rv.data == b\"Hello\"\n    assert rv.mimetype == \"text/html\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "req_ctx": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "req_ctx"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "req_ctx": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_make_response` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.22,
      "evidence": [
        "function test_make_response in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.26)"
      ]
    },
    {
      "name": "test_make_response_with_response_instance",
      "description": "handle a HTTP route request and return response. Function `test_make_response_with_response_instance`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_make_response_with_response_instance(app, req_ctx):\n    rv = flask.make_response(flask.jsonify({\"msg\": \"W00t\"}), 400)\n    assert rv.status_code == 400\n    assert rv.data == b'{\"msg\":\"W00t\"}\\n'\n    assert rv.mimetype == \"application/json\"\n\n    rv = flask.make_response(flask.Response(\"\"), 400)\n    assert rv.status_code == 400\n    assert rv.data == b\"\"\n    assert rv.mimetype == \"text/html\"\n\n    rv = flask.make_response(\n        flask.Response(\"\", headers={\"Content-Type\": \"text/html\"}),\n        400,\n        [(\"X-Foo\", \"bar\")],\n    )\n    assert rv.status_code == 400\n    assert rv.headers[\"Content-Type\"] == \"text/html\"\n    assert rv.headers[\"X-Foo\"] == \"bar\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "req_ctx": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "req_ctx"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "req_ctx": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_make_response_with_response_instance` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.23,
      "evidence": [
        "function test_make_response_with_response_instance in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.28)"
      ]
    },
    {
      "name": "test_jsonify_no_prettyprint",
      "description": "parse JSON input and validate fields. Function `test_jsonify_no_prettyprint`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_jsonify_no_prettyprint(app, compact):\n    app.json.compact = compact\n    rv = app.json.response({\"msg\": {\"submsg\": \"W00t\"}, \"msg2\": \"foobar\"})\n    data = rv.data.strip()\n    assert (b\" \" not in data) is compact\n    assert (b\"\\n\" not in data) is compact",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "compact": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "compact"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "compact": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_jsonify_no_prettyprint` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.24,
      "evidence": [
        "function test_jsonify_no_prettyprint in tests\\test_basic.py",
        "matched template: parse JSON input and validate fields (sim=0.29)"
      ]
    },
    {
      "name": "test_jsonify_mimetype",
      "description": "parse JSON input and validate fields. Function `test_jsonify_mimetype`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_jsonify_mimetype(app, req_ctx):\n    app.json.mimetype = \"application/vnd.api+json\"\n    msg = {\"msg\": {\"submsg\": \"W00t\"}}\n    rv = flask.make_response(flask.jsonify(msg), 200)\n    assert rv.mimetype == \"application/vnd.api+json\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "req_ctx": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "req_ctx"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "req_ctx": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_jsonify_mimetype` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.23,
      "evidence": [
        "function test_jsonify_mimetype in tests\\test_basic.py",
        "matched template: parse JSON input and validate fields (sim=0.27)"
      ]
    },
    {
      "name": "test_json_dump_dataclass",
      "description": "parse JSON input and validate fields. Function `test_json_dump_dataclass`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_json_dump_dataclass(app, req_ctx):\n    from dataclasses import make_dataclass\n\n    Data = make_dataclass(\"Data\", [(\"name\", str)])\n    value = app.json.dumps(Data(\"Flask\"))\n    value = app.json.loads(value)\n    assert value == {\"name\": \"Flask\"}",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "req_ctx": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "req_ctx"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "req_ctx": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_json_dump_dataclass` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.25,
      "evidence": [
        "function test_json_dump_dataclass in tests\\test_basic.py",
        "matched template: parse JSON input and validate fields (sim=0.31)"
      ]
    },
    {
      "name": "test_jsonify_args_and_kwargs_check",
      "description": "parse JSON input and validate fields. Function `test_jsonify_args_and_kwargs_check`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_jsonify_args_and_kwargs_check(app, req_ctx):\n    with pytest.raises(TypeError) as e:\n        flask.jsonify(\"fake args\", kwargs=\"fake\")\n    assert \"args or kwargs\" in str(e.value)",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "req_ctx": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "req_ctx"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "req_ctx": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_jsonify_args_and_kwargs_check` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.24,
      "evidence": [
        "function test_jsonify_args_and_kwargs_check in tests\\test_basic.py",
        "matched template: parse JSON input and validate fields (sim=0.29)"
      ]
    },
    {
      "name": "test_url_generation",
      "description": "handle a HTTP route request and return response. Function `test_url_generation`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_url_generation(app, req_ctx):\n    @app.route(\"/hello/<name>\", methods=[\"POST\"])\n    def hello():\n        pass\n\n    assert flask.url_for(\"hello\", name=\"test x\") == \"/hello/test%20x\"\n    assert (\n        flask.url_for(\"hello\", name=\"test x\", _external=True)\n        == \"http://localhost/hello/test%20x\"\n    )",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "req_ctx": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "req_ctx"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "req_ctx": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_url_generation` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.24,
      "evidence": [
        "function test_url_generation in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.29)"
      ]
    },
    {
      "name": "test_build_error_handler",
      "description": "handle a HTTP route request and return response. Function `test_build_error_handler`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_build_error_handler(app):\n    # Test base case, a URL which results in a BuildError.\n    with app.test_request_context():\n        pytest.raises(BuildError, flask.url_for, \"spam\")\n\n    # Verify the error is re-raised if not the current exception.\n    try:\n        with app.test_request_context():\n            flask.url_for(\"spam\")\n    except BuildError as err:\n        error = err\n    try:\n        raise RuntimeError(\"Test case where BuildError is not current.\")\n    except RuntimeError:\n        pytest.raises(BuildError, app.handle_url_build_error, error, \"spam\", {})\n\n    # Test a custom handler.\n    def handler(error, endpoint, values):\n        # Just a test.\n        return \"/test_handler/\"\n\n    app.url_build_error_handlers.append(handler)\n    with app.test_request_context():\n        assert flask.url_for(\"spam\") == \"/test_handler/\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_build_error_handler` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.18,
      "evidence": [
        "function test_build_error_handler in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.15)"
      ]
    },
    {
      "name": "test_build_error_handler_reraise",
      "description": "handle a HTTP route request and return response. Function `test_build_error_handler_reraise`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_build_error_handler_reraise(app):\n    # Test a custom handler which reraises the BuildError\n    def handler_raises_build_error(error, endpoint, values):\n        raise error\n\n    app.url_build_error_handlers.append(handler_raises_build_error)\n\n    with app.test_request_context():\n        pytest.raises(BuildError, flask.url_for, \"not.existing\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_build_error_handler_reraise` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.2,
      "evidence": [
        "function test_build_error_handler_reraise in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.22)"
      ]
    },
    {
      "name": "test_url_for_passes_special_values_to_build_error_handler",
      "description": "make an HTTP request to an external API. Function `test_url_for_passes_special_values_to_build_error_handler`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_url_for_passes_special_values_to_build_error_handler(app):\n    @app.url_build_error_handlers.append\n    def handler(error, endpoint, values):\n        assert values == {\n            \"_external\": False,\n            \"_anchor\": None,\n            \"_method\": None,\n            \"_scheme\": None,\n        }\n        return \"handled\"\n\n    with app.test_request_context():\n        flask.url_for(\"/\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_url_for_passes_special_values_to_build_error_handler` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.23,
      "evidence": [
        "function test_url_for_passes_special_values_to_build_error_handler in tests\\test_basic.py",
        "matched template: make an HTTP request to an external API (sim=0.27)"
      ]
    },
    {
      "name": "test_static_files",
      "description": "write data to a file. Function `test_static_files`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_static_files(app, client):\n    rv = client.get(\"/static/index.html\")\n    assert rv.status_code == 200\n    assert rv.data.strip() == b\"<h1>Hello World!</h1>\"\n    with app.test_request_context():\n        assert flask.url_for(\"static\", filename=\"index.html\") == \"/static/index.html\"\n    rv.close()",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_static_files` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.2,
      "evidence": [
        "function test_static_files in tests\\test_basic.py",
        "matched template: write data to a file (sim=0.22)"
      ]
    },
    {
      "name": "test_static_url_path",
      "description": "handle a HTTP route request and return response. Function `test_static_url_path`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_static_url_path():\n    app = flask.Flask(__name__, static_url_path=\"/foo\")\n    app.testing = True\n    rv = app.test_client().get(\"/foo/index.html\")\n    assert rv.status_code == 200\n    rv.close()\n\n    with app.test_request_context():\n        assert flask.url_for(\"static\", filename=\"index.html\") == \"/foo/index.html\"",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_static_url_path` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.22,
      "evidence": [
        "function test_static_url_path in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.25)"
      ]
    },
    {
      "name": "test_static_url_path_with_ending_slash",
      "description": "handle a HTTP route request and return response. Function `test_static_url_path_with_ending_slash`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_static_url_path_with_ending_slash():\n    app = flask.Flask(__name__, static_url_path=\"/foo/\")\n    app.testing = True\n    rv = app.test_client().get(\"/foo/index.html\")\n    assert rv.status_code == 200\n    rv.close()\n\n    with app.test_request_context():\n        assert flask.url_for(\"static\", filename=\"index.html\") == \"/foo/index.html\"",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_static_url_path_with_ending_slash` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.22,
      "evidence": [
        "function test_static_url_path_with_ending_slash in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.25)"
      ]
    },
    {
      "name": "test_static_url_empty_path",
      "description": "handle a HTTP route request and return response. Function `test_static_url_empty_path`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_static_url_empty_path(app):\n    app = flask.Flask(__name__, static_folder=\"\", static_url_path=\"\")\n    rv = app.test_client().open(\"/static/index.html\", method=\"GET\")\n    assert rv.status_code == 200\n    rv.close()",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_static_url_empty_path` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.21,
      "evidence": [
        "function test_static_url_empty_path in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.24)"
      ]
    },
    {
      "name": "test_static_url_empty_path_default",
      "description": "handle a HTTP route request and return response. Function `test_static_url_empty_path_default`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_static_url_empty_path_default(app):\n    app = flask.Flask(__name__, static_folder=\"\")\n    rv = app.test_client().open(\"/static/index.html\", method=\"GET\")\n    assert rv.status_code == 200\n    rv.close()",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_static_url_empty_path_default` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.21,
      "evidence": [
        "function test_static_url_empty_path_default in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.24)"
      ]
    },
    {
      "name": "test_static_folder_with_pathlib_path",
      "description": "handle a HTTP route request and return response. Function `test_static_folder_with_pathlib_path`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_static_folder_with_pathlib_path(app):\n    from pathlib import Path\n\n    app = flask.Flask(__name__, static_folder=Path(\"static\"))\n    rv = app.test_client().open(\"/static/index.html\", method=\"GET\")\n    assert rv.status_code == 200\n    rv.close()",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_static_folder_with_pathlib_path` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.19,
      "evidence": [
        "function test_static_folder_with_pathlib_path in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.18)"
      ]
    },
    {
      "name": "test_static_folder_with_ending_slash",
      "description": "handle a HTTP route request and return response. Function `test_static_folder_with_ending_slash`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_static_folder_with_ending_slash():\n    app = flask.Flask(__name__, static_folder=\"static/\")\n\n    @app.route(\"/<path:path>\")\n    def catch_all(path):\n        return path\n\n    rv = app.test_client().get(\"/catch/all\")\n    assert rv.data == b\"catch/all\"",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_static_folder_with_ending_slash` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.21,
      "evidence": [
        "function test_static_folder_with_ending_slash in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.23)"
      ]
    },
    {
      "name": "test_static_route_with_host_matching",
      "description": "handle a HTTP route request and return response. Function `test_static_route_with_host_matching`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_static_route_with_host_matching():\n    app = flask.Flask(__name__, host_matching=True, static_host=\"example.com\")\n    c = app.test_client()\n    rv = c.get(\"http://example.com/static/index.html\")\n    assert rv.status_code == 200\n    rv.close()\n    with app.test_request_context():\n        rv = flask.url_for(\"static\", filename=\"index.html\", _external=True)\n        assert rv == \"http://example.com/static/index.html\"\n    # Providing static_host without host_matching=True should error.\n    with pytest.raises(AssertionError):\n        flask.Flask(__name__, static_host=\"example.com\")\n    # Providing host_matching=True with static_folder\n    # but without static_host should error.\n    with pytest.raises(AssertionError):\n        flask.Flask(__name__, host_matching=True)\n    # Providing host_matching=True without static_host\n    # but with static_folder=None should not error.\n    flask.Flask(__name__, host_matching=True, static_folder=None)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_static_route_with_host_matching` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.22,
      "evidence": [
        "function test_static_route_with_host_matching in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.25)"
      ]
    },
    {
      "name": "test_request_locals",
      "description": "handle a HTTP route request and return response. Function `test_request_locals`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_request_locals():\n    assert repr(flask.g) == \"<LocalProxy unbound>\"\n    assert not flask.g",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_request_locals` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.25,
      "evidence": [
        "function test_request_locals in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.31)"
      ]
    },
    {
      "name": "test_server_name_matching",
      "description": "handle a HTTP route request and return response. Function `test_server_name_matching`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_server_name_matching(\n    subdomain_matching: bool,\n    host_matching: bool,\n    expect_base: str,\n    expect_abc: str,\n    expect_xyz: str,\n) -> None:\n    app = flask.Flask(\n        __name__,\n        subdomain_matching=subdomain_matching,\n        host_matching=host_matching,\n        static_host=\"example.test\" if host_matching else None,\n    )\n    app.config[\"SERVER_NAME\"] = \"example.test\"\n\n    @app.route(\"/\", defaults={\"name\": \"default\"}, host=\"<name>\")\n    @app.route(\"/\", subdomain=\"<name>\", host=\"<name>.example.test\")\n    def index(name: str) -> str:\n        return name\n\n    client = app.test_client()\n\n    r = client.get(base_url=\"http://example.test\")\n    assert r.text == expect_base\n\n    r = client.get(base_url=\"http://abc.example.test\")\n    assert r.text == expect_abc\n\n    with pytest.warns() if subdomain_matching else nullcontext():\n        r = client.get(base_url=\"http://xyz.other.test\")\n\n    assert r.text == expect_xyz",
      "input_schema": {
        "type": "object",
        "properties": {
          "subdomain_matching": {
            "type": "boolean",
            "required": true
          },
          "host_matching": {
            "type": "boolean",
            "required": true
          },
          "expect_base": {
            "type": "string",
            "required": true
          },
          "expect_abc": {
            "type": "string",
            "required": true
          },
          "expect_xyz": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "subdomain_matching",
          "host_matching",
          "expect_base",
          "expect_abc",
          "expect_xyz"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "subdomain_matching": "boolean",
          "host_matching": "boolean",
          "expect_base": "string",
          "expect_abc": "string",
          "expect_xyz": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `test_server_name_matching` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.23,
      "evidence": [
        "function test_server_name_matching in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.28)"
      ]
    },
    {
      "name": "test_server_name_subdomain",
      "description": "handle a HTTP route request and return response. Function `test_server_name_subdomain`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_server_name_subdomain():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    client = app.test_client()\n\n    @app.route(\"/\")\n    def index():\n        return \"default\"\n\n    @app.route(\"/\", subdomain=\"foo\")\n    def subdomain():\n        return \"subdomain\"\n\n    app.config[\"SERVER_NAME\"] = \"dev.local:5000\"\n    rv = client.get(\"/\")\n    assert rv.data == b\"default\"\n\n    rv = client.get(\"/\", \"http://dev.local:5000\")\n    assert rv.data == b\"default\"\n\n    rv = client.get(\"/\", \"https://dev.local:5000\")\n    assert rv.data == b\"default\"\n\n    app.config[\"SERVER_NAME\"] = \"dev.local:443\"\n    rv = client.get(\"/\", \"https://dev.local\")\n\n    # Werkzeug 1.0 fixes matching https scheme with 443 port\n    if rv.status_code != 404:\n        assert rv.data == b\"default\"\n\n    app.config[\"SERVER_NAME\"] = \"dev.local\"\n    rv = client.get(\"/\", \"https://dev.local\")\n    assert rv.data == b\"default\"\n\n    # suppress Werkzeug 0.15 warning about name mismatch\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\n            \"ignore\", \"Current server name\", UserWarning, \"flask.app\"\n        )\n        rv = client.get(\"/\", \"http://foo.localhost\")\n        assert rv.status_code == 404\n\n    rv = client.get(\"/\", \"http://foo.dev.local\")\n    assert rv.data == b\"subdomain\"",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_server_name_subdomain` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.24,
      "evidence": [
        "function test_server_name_subdomain in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.29)"
      ]
    },
    {
      "name": "test_exception_propagation",
      "description": "handle a HTTP route request and return response. Function `test_exception_propagation`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_exception_propagation(app, client, key):\n    app.testing = False\n\n    @app.route(\"/\")\n    def index():\n        raise ZeroDivisionError\n\n    if key is not None:\n        app.config[key] = True\n\n        with pytest.raises(ZeroDivisionError):\n            client.get(\"/\")\n    else:\n        assert client.get(\"/\").status_code == 500",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          },
          "key": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client",
          "key"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string",
          "key": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_exception_propagation` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.2,
      "evidence": [
        "function test_exception_propagation in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.21)"
      ]
    },
    {
      "name": "test_werkzeug_passthrough_errors",
      "description": "validate and sanitize user input. Function `test_werkzeug_passthrough_errors`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_werkzeug_passthrough_errors(\n    monkeypatch, debug, use_debugger, use_reloader, propagate_exceptions, app\n):\n    rv = {}\n\n    # Mocks werkzeug.serving.run_simple method\n    def run_simple_mock(*args, **kwargs):\n        rv[\"passthrough_errors\"] = kwargs.get(\"passthrough_errors\")\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n    app.config[\"PROPAGATE_EXCEPTIONS\"] = propagate_exceptions\n    app.run(debug=debug, use_debugger=use_debugger, use_reloader=use_reloader)",
      "input_schema": {
        "type": "object",
        "properties": {
          "monkeypatch": {
            "type": "string",
            "required": true
          },
          "debug": {
            "type": "string",
            "required": true
          },
          "use_debugger": {
            "type": "string",
            "required": true
          },
          "use_reloader": {
            "type": "string",
            "required": true
          },
          "propagate_exceptions": {
            "type": "string",
            "required": true
          },
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "monkeypatch",
          "debug",
          "use_debugger",
          "use_reloader",
          "propagate_exceptions",
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "monkeypatch": "string",
          "debug": "string",
          "use_debugger": "string",
          "use_reloader": "string",
          "propagate_exceptions": "string",
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_werkzeug_passthrough_errors` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.17,
      "evidence": [
        "function test_werkzeug_passthrough_errors in tests\\test_basic.py",
        "matched template: validate and sanitize user input (sim=0.12)"
      ]
    },
    {
      "name": "test_url_processors",
      "description": "handle a HTTP route request and return response. Function `test_url_processors`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_url_processors(app, client):\n    @app.url_defaults\n    def add_language_code(endpoint, values):\n        if flask.g.lang_code is not None and app.url_map.is_endpoint_expecting(\n            endpoint, \"lang_code\"\n        ):\n            values.setdefault(\"lang_code\", flask.g.lang_code)\n\n    @app.url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop(\"lang_code\", None)\n\n    @app.route(\"/<lang_code>/\")\n    def index():\n        return flask.url_for(\"about\")\n\n    @app.route(\"/<lang_code>/about\")\n    def about():\n        return flask.url_for(\"something_else\")\n\n    @app.route(\"/foo\")\n    def something_else():\n        return flask.url_for(\"about\", lang_code=\"en\")\n\n    assert client.get(\"/de/\").data == b\"/de/about\"\n    assert client.get(\"/de/about\").data == b\"/foo\"\n    assert client.get(\"/foo\").data == b\"/en/about\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_url_processors` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.24,
      "evidence": [
        "function test_url_processors in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.29)"
      ]
    },
    {
      "name": "test_inject_blueprint_url_defaults",
      "description": "make an HTTP request to an external API. Function `test_inject_blueprint_url_defaults`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_inject_blueprint_url_defaults(app):\n    bp = flask.Blueprint(\"foo\", __name__, template_folder=\"template\")\n\n    @bp.url_defaults\n    def bp_defaults(endpoint, values):\n        values[\"page\"] = \"login\"\n\n    @bp.route(\"/<page>\")\n    def view(page):\n        pass\n\n    app.register_blueprint(bp)\n\n    values = dict()\n    app.inject_url_defaults(\"foo.view\", values)\n    expected = dict(page=\"login\")\n    assert values == expected\n\n    with app.test_request_context(\"/somepage\"):\n        url = flask.url_for(\"foo.view\")\n    expected = \"/login\"\n    assert url == expected",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_inject_blueprint_url_defaults` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.19,
      "evidence": [
        "function test_inject_blueprint_url_defaults in tests\\test_basic.py",
        "matched template: make an HTTP request to an external API (sim=0.18)"
      ]
    },
    {
      "name": "test_nonascii_pathinfo",
      "description": "handle a HTTP route request and return response. Function `test_nonascii_pathinfo`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_nonascii_pathinfo(app, client):\n    @app.route(\"/\u043a\u0438\u0440\u0442\u0435\u0441\u0442\")\n    def index():\n        return \"Hello World!\"\n\n    rv = client.get(\"/\u043a\u0438\u0440\u0442\u0435\u0441\u0442\")\n    assert rv.data == b\"Hello World!\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_nonascii_pathinfo` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.22,
      "evidence": [
        "function test_nonascii_pathinfo in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.26)"
      ]
    },
    {
      "name": "test_no_setup_after_first_request",
      "description": "handle a HTTP route request and return response. Function `test_no_setup_after_first_request`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_no_setup_after_first_request(app, client):\n    app.debug = True\n\n    @app.route(\"/\")\n    def index():\n        return \"Awesome\"\n\n    assert client.get(\"/\").data == b\"Awesome\"\n\n    with pytest.raises(AssertionError) as exc_info:\n        app.add_url_rule(\"/foo\", endpoint=\"late\")\n\n    assert \"setup method 'add_url_rule'\" in str(exc_info.value)",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_no_setup_after_first_request` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.23,
      "evidence": [
        "function test_no_setup_after_first_request in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.28)"
      ]
    },
    {
      "name": "test_routing_redirect_debugging",
      "description": "handle a HTTP route request and return response. Function `test_routing_redirect_debugging`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_routing_redirect_debugging(monkeypatch, app, client):\n    app.config[\"DEBUG\"] = True\n\n    @app.route(\"/user/\", methods=[\"GET\", \"POST\"])\n    def user():\n        return flask.request.form[\"status\"]\n\n    # default redirect code preserves form data\n    rv = client.post(\"/user\", data={\"status\": \"success\"}, follow_redirects=True)\n    assert rv.data == b\"success\"\n\n    # 301 and 302 raise error\n    monkeypatch.setattr(RequestRedirect, \"code\", 301)\n\n    with client, pytest.raises(AssertionError) as exc_info:\n        client.post(\"/user\", data={\"status\": \"error\"}, follow_redirects=True)\n\n    assert \"canonical URL 'http://localhost/user/'\" in str(exc_info.value)",
      "input_schema": {
        "type": "object",
        "properties": {
          "monkeypatch": {
            "type": "string",
            "required": true
          },
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "monkeypatch",
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "monkeypatch": "string",
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_routing_redirect_debugging` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.26,
      "evidence": [
        "function test_routing_redirect_debugging in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.33)"
      ]
    },
    {
      "name": "test_route_decorator_custom_endpoint",
      "description": "handle a HTTP route request and return response. Function `test_route_decorator_custom_endpoint`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_route_decorator_custom_endpoint(app, client):\n    app.debug = True\n\n    @app.route(\"/foo/\")\n    def foo():\n        return flask.request.endpoint\n\n    @app.route(\"/bar/\", endpoint=\"bar\")\n    def for_bar():\n        return flask.request.endpoint\n\n    @app.route(\"/bar/123\", endpoint=\"123\")\n    def for_bar_foo():\n        return flask.request.endpoint\n\n    with app.test_request_context():\n        assert flask.url_for(\"foo\") == \"/foo/\"\n        assert flask.url_for(\"bar\") == \"/bar/\"\n        assert flask.url_for(\"123\") == \"/bar/123\"\n\n    assert client.get(\"/foo/\").data == b\"foo\"\n    assert client.get(\"/bar/\").data == b\"bar\"\n    assert client.get(\"/bar/123\").data == b\"123\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_route_decorator_custom_endpoint` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.31,
      "evidence": [
        "function test_route_decorator_custom_endpoint in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.40)"
      ]
    },
    {
      "name": "test_get_method_on_g",
      "description": "handle a HTTP route request and return response. Function `test_get_method_on_g`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_get_method_on_g(app_ctx):\n    assert flask.g.get(\"x\") is None\n    assert flask.g.get(\"x\", 11) == 11\n    flask.g.x = 42\n    assert flask.g.get(\"x\") == 42\n    assert flask.g.x == 42",
      "input_schema": {
        "type": "object",
        "properties": {
          "app_ctx": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app_ctx"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app_ctx": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_get_method_on_g` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.19,
      "evidence": [
        "function test_get_method_on_g in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.20)"
      ]
    },
    {
      "name": "test_g_iteration_protocol",
      "description": "handle a HTTP route request and return response. Function `test_g_iteration_protocol`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_g_iteration_protocol(app_ctx):\n    flask.g.foo = 23\n    flask.g.bar = 42\n    assert \"foo\" in flask.g\n    assert \"foos\" not in flask.g\n    assert sorted(flask.g) == [\"bar\", \"foo\"]",
      "input_schema": {
        "type": "object",
        "properties": {
          "app_ctx": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app_ctx"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app_ctx": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_g_iteration_protocol` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.2,
      "evidence": [
        "function test_g_iteration_protocol in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.21)"
      ]
    },
    {
      "name": "test_subdomain_basic_support",
      "description": "handle a HTTP route request and return response. Function `test_subdomain_basic_support`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_subdomain_basic_support():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain\"\n    client = app.test_client()\n\n    @app.route(\"/\")\n    def normal_index():\n        return \"normal index\"\n\n    @app.route(\"/\", subdomain=\"test\")\n    def test_index():\n        return \"test index\"\n\n    rv = client.get(\"/\", \"http://localhost.localdomain/\")\n    assert rv.data == b\"normal index\"\n\n    rv = client.get(\"/\", \"http://test.localhost.localdomain/\")\n    assert rv.data == b\"test index\"",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_subdomain_basic_support` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.21,
      "evidence": [
        "function test_subdomain_basic_support in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.24)"
      ]
    },
    {
      "name": "test_subdomain_matching",
      "description": "handle a HTTP route request and return response. Function `test_subdomain_matching`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_subdomain_matching():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    client = app.test_client()\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain\"\n\n    @app.route(\"/\", subdomain=\"<user>\")\n    def index(user):\n        return f\"index for {user}\"\n\n    rv = client.get(\"/\", \"http://mitsuhiko.localhost.localdomain/\")\n    assert rv.data == b\"index for mitsuhiko\"",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_subdomain_matching` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.2,
      "evidence": [
        "function test_subdomain_matching in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.21)"
      ]
    },
    {
      "name": "test_subdomain_matching_with_ports",
      "description": "handle a HTTP route request and return response. Function `test_subdomain_matching_with_ports`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_subdomain_matching_with_ports():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain:3000\"\n    client = app.test_client()\n\n    @app.route(\"/\", subdomain=\"<user>\")\n    def index(user):\n        return f\"index for {user}\"\n\n    rv = client.get(\"/\", \"http://mitsuhiko.localhost.localdomain:3000/\")\n    assert rv.data == b\"index for mitsuhiko\"",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_subdomain_matching_with_ports` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.19,
      "evidence": [
        "function test_subdomain_matching_with_ports in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.19)"
      ]
    },
    {
      "name": "test_subdomain_matching_other_name",
      "description": "handle a HTTP route request and return response. Function `test_subdomain_matching_other_name`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_subdomain_matching_other_name(matching):\n    app = flask.Flask(__name__, subdomain_matching=matching)\n    app.config[\"SERVER_NAME\"] = \"localhost.localdomain:3000\"\n    client = app.test_client()\n\n    @app.route(\"/\")\n    def index():\n        return \"\", 204\n\n    # suppress Werkzeug 0.15 warning about name mismatch\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\n            \"ignore\", \"Current server name\", UserWarning, \"flask.app\"\n        )\n        # ip address can't match name\n        rv = client.get(\"/\", \"http://127.0.0.1:3000/\")\n        assert rv.status_code == 404 if matching else 204\n\n    # allow all subdomains if matching is disabled\n    rv = client.get(\"/\", \"http://www.localhost.localdomain:3000/\")\n    assert rv.status_code == 404 if matching else 204",
      "input_schema": {
        "type": "object",
        "properties": {
          "matching": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "matching"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "matching": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_subdomain_matching_other_name` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.21,
      "evidence": [
        "function test_subdomain_matching_other_name in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.24)"
      ]
    },
    {
      "name": "test_multi_route_rules",
      "description": "handle a HTTP route request and return response. Function `test_multi_route_rules`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_multi_route_rules(app, client):\n    @app.route(\"/\")\n    @app.route(\"/<test>/\")\n    def index(test=\"a\"):\n        return test\n\n    rv = client.open(\"/\")\n    assert rv.data == b\"a\"\n    rv = client.open(\"/b/\")\n    assert rv.data == b\"b\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_multi_route_rules` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.27,
      "evidence": [
        "function test_multi_route_rules in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.34)"
      ]
    },
    {
      "name": "test_multi_route_class_views",
      "description": "handle a HTTP route request and return response. Function `test_multi_route_class_views`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_multi_route_class_views(app, client):\n    class View:\n        def __init__(self, app):\n            app.add_url_rule(\"/\", \"index\", self.index)\n            app.add_url_rule(\"/<test>/\", \"index\", self.index)\n\n        def index(self, test=\"a\"):\n            return test\n\n    _ = View(app)\n    rv = client.open(\"/\")\n    assert rv.data == b\"a\"\n    rv = client.open(\"/b/\")\n    assert rv.data == b\"b\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_multi_route_class_views` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.25,
      "evidence": [
        "function test_multi_route_class_views in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.31)"
      ]
    },
    {
      "name": "test_run_defaults",
      "description": "execute a shell command. Function `test_run_defaults`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_run_defaults(monkeypatch, app):\n    rv = {}\n\n    # Mocks werkzeug.serving.run_simple method\n    def run_simple_mock(*args, **kwargs):\n        rv[\"result\"] = \"running...\"\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n    app.run()\n    assert rv[\"result\"] == \"running...\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "monkeypatch": {
            "type": "string",
            "required": true
          },
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "monkeypatch",
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "monkeypatch": "string",
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_run_defaults` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.18,
      "evidence": [
        "function test_run_defaults in tests\\test_basic.py",
        "matched template: execute a shell command (sim=0.16)"
      ]
    },
    {
      "name": "test_run_server_port",
      "description": "execute a shell command. Function `test_run_server_port`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_run_server_port(monkeypatch, app):\n    rv = {}\n\n    # Mocks werkzeug.serving.run_simple method\n    def run_simple_mock(hostname, port, application, *args, **kwargs):\n        rv[\"result\"] = f\"running on {hostname}:{port} ...\"\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n    hostname, port = \"localhost\", 8000\n    app.run(hostname, port, debug=True)\n    assert rv[\"result\"] == f\"running on {hostname}:{port} ...\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "monkeypatch": {
            "type": "string",
            "required": true
          },
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "monkeypatch",
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "monkeypatch": "string",
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_run_server_port` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.18,
      "evidence": [
        "function test_run_server_port in tests\\test_basic.py",
        "matched template: execute a shell command (sim=0.16)"
      ]
    },
    {
      "name": "test_run_from_config",
      "description": "execute a shell command. Function `test_run_from_config`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_run_from_config(\n    monkeypatch, host, port, server_name, expect_host, expect_port, app\n):\n    def run_simple_mock(hostname, port, *args, **kwargs):\n        assert hostname == expect_host\n        assert port == expect_port\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n    app.config[\"SERVER_NAME\"] = server_name\n    app.run(host, port)",
      "input_schema": {
        "type": "object",
        "properties": {
          "monkeypatch": {
            "type": "string",
            "required": true
          },
          "host": {
            "type": "string",
            "required": true
          },
          "port": {
            "type": "string",
            "required": true
          },
          "server_name": {
            "type": "string",
            "required": true
          },
          "expect_host": {
            "type": "string",
            "required": true
          },
          "expect_port": {
            "type": "string",
            "required": true
          },
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "monkeypatch",
          "host",
          "port",
          "server_name",
          "expect_host",
          "expect_port",
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "monkeypatch": "string",
          "host": "string",
          "port": "string",
          "server_name": "string",
          "expect_host": "string",
          "expect_port": "string",
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_run_from_config` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.17,
      "evidence": [
        "function test_run_from_config in tests\\test_basic.py",
        "matched template: execute a shell command (sim=0.14)"
      ]
    },
    {
      "name": "test_max_cookie_size",
      "description": "handle a HTTP route request and return response. Function `test_max_cookie_size`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_max_cookie_size(app, client, recwarn):\n    app.config[\"MAX_COOKIE_SIZE\"] = 100\n\n    # outside app context, default to Werkzeug static value,\n    # which is also the default config\n    response = flask.Response()\n    default = flask.Flask.default_config[\"MAX_COOKIE_SIZE\"]\n    assert response.max_cookie_size == default\n\n    # inside app context, use app config\n    with app.app_context():\n        assert flask.Response().max_cookie_size == 100\n\n    @app.route(\"/\")\n    def index():\n        r = flask.Response(\"\", status=204)\n        r.set_cookie(\"foo\", \"bar\" * 100)\n        return r\n\n    client.get(\"/\")\n    assert len(recwarn) == 1\n    w = recwarn.pop()\n    assert \"cookie is too large\" in str(w.message)\n\n    app.config[\"MAX_COOKIE_SIZE\"] = 0\n\n    client.get(\"/\")\n    assert len(recwarn) == 0",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          },
          "recwarn": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client",
          "recwarn"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string",
          "recwarn": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_max_cookie_size` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.2,
      "evidence": [
        "function test_max_cookie_size in tests\\test_basic.py",
        "matched template: handle a HTTP route request and return response (sim=0.20)"
      ]
    },
    {
      "name": "test_app_freed_on_zero_refcount",
      "description": "cache results to disk or memory. Function `test_app_freed_on_zero_refcount`.",
      "predicted_filename": "tests\\test_basic.py",
      "predicted_code_snippet": "def test_app_freed_on_zero_refcount():\n    # A Flask instance should not create a reference cycle that prevents CPython\n    # from freeing it when all external references to it are released (see #3761).\n    gc.disable()\n    try:\n        app = flask.Flask(__name__)\n        assert app.view_functions[\"static\"]\n        weak = weakref.ref(app)\n        assert weak() is not None\n        del app\n        assert weak() is None\n    finally:\n        gc.enable()",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_app_freed_on_zero_refcount` in tests\\test_basic.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.18,
      "evidence": [
        "function test_app_freed_on_zero_refcount in tests\\test_basic.py",
        "matched template: cache results to disk or memory (sim=0.15)"
      ]
    },
    {
      "name": "test_blueprint_specific_error_handling",
      "description": "handle a HTTP route request and return response. Function `test_blueprint_specific_error_handling`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_blueprint_specific_error_handling(app, client):\n    frontend = flask.Blueprint(\"frontend\", __name__)\n    backend = flask.Blueprint(\"backend\", __name__)\n    sideend = flask.Blueprint(\"sideend\", __name__)\n\n    @frontend.errorhandler(403)\n    def frontend_forbidden(e):\n        return \"frontend says no\", 403\n\n    @frontend.route(\"/frontend-no\")\n    def frontend_no():\n        flask.abort(403)\n\n    @backend.errorhandler(403)\n    def backend_forbidden(e):\n        return \"backend says no\", 403\n\n    @backend.route(\"/backend-no\")\n    def backend_no():\n        flask.abort(403)\n\n    @sideend.route(\"/what-is-a-sideend\")\n    def sideend_no():\n        flask.abort(403)\n\n    app.register_blueprint(frontend)\n    app.register_blueprint(backend)\n    app.register_blueprint(sideend)\n\n    @app.errorhandler(403)\n    def app_forbidden(e):\n        return \"application itself says no\", 403\n\n    assert client.get(\"/frontend-no\").data == b\"frontend says no\"\n    assert client.get(\"/backend-no\").data == b\"backend says no\"\n    assert client.get(\"/what-is-a-sideend\").data == b\"application itself says no\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_blueprint_specific_error_handling` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.24,
      "evidence": [
        "function test_blueprint_specific_error_handling in tests\\test_blueprints.py",
        "matched template: handle a HTTP route request and return response (sim=0.28)"
      ]
    },
    {
      "name": "test_blueprint_specific_user_error_handling",
      "description": "handle a HTTP route request and return response. Function `test_blueprint_specific_user_error_handling`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_blueprint_specific_user_error_handling(app, client):\n    class MyDecoratorException(Exception):\n        pass\n\n    class MyFunctionException(Exception):\n        pass\n\n    blue = flask.Blueprint(\"blue\", __name__)\n\n    @blue.errorhandler(MyDecoratorException)\n    def my_decorator_exception_handler(e):\n        assert isinstance(e, MyDecoratorException)\n        return \"boom\"\n\n    def my_function_exception_handler(e):\n        assert isinstance(e, MyFunctionException)\n        return \"bam\"\n\n    blue.register_error_handler(MyFunctionException, my_function_exception_handler)\n\n    @blue.route(\"/decorator\")\n    def blue_deco_test():\n        raise MyDecoratorException()\n\n    @blue.route(\"/function\")\n    def blue_func_test():\n        raise MyFunctionException()\n\n    app.register_blueprint(blue)\n\n    assert client.get(\"/decorator\").data == b\"boom\"\n    assert client.get(\"/function\").data == b\"bam\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_blueprint_specific_user_error_handling` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_blueprint_specific_user_error_handling in tests\\test_blueprints.py",
        "matched template: handle a HTTP route request and return response (sim=0.18)"
      ]
    },
    {
      "name": "test_blueprint_app_error_handling",
      "description": "handle a HTTP route request and return response. Function `test_blueprint_app_error_handling`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_blueprint_app_error_handling(app, client):\n    errors = flask.Blueprint(\"errors\", __name__)\n\n    @errors.app_errorhandler(403)\n    def forbidden_handler(e):\n        return \"you shall not pass\", 403\n\n    @app.route(\"/forbidden\")\n    def app_forbidden():\n        flask.abort(403)\n\n    forbidden_bp = flask.Blueprint(\"forbidden_bp\", __name__)\n\n    @forbidden_bp.route(\"/nope\")\n    def bp_forbidden():\n        flask.abort(403)\n\n    app.register_blueprint(errors)\n    app.register_blueprint(forbidden_bp)\n\n    assert client.get(\"/forbidden\").data == b\"you shall not pass\"\n    assert client.get(\"/nope\").data == b\"you shall not pass\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_blueprint_app_error_handling` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function test_blueprint_app_error_handling in tests\\test_blueprints.py",
        "matched template: handle a HTTP route request and return response (sim=0.26)"
      ]
    },
    {
      "name": "test_blueprint_prefix_slash",
      "description": "handle a HTTP route request and return response. Function `test_blueprint_prefix_slash`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_blueprint_prefix_slash(app, client, prefix, rule, url):\n    bp = flask.Blueprint(\"test\", __name__, url_prefix=prefix)\n\n    @bp.route(rule)\n    def index():\n        return \"\", 204\n\n    app.register_blueprint(bp)\n    assert client.get(url).status_code == 204",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          },
          "prefix": {
            "type": "string",
            "required": true
          },
          "rule": {
            "type": "string",
            "required": true
          },
          "url": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client",
          "prefix",
          "rule",
          "url"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string",
          "prefix": "string",
          "rule": "string",
          "url": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_blueprint_prefix_slash` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function test_blueprint_prefix_slash in tests\\test_blueprints.py",
        "matched template: handle a HTTP route request and return response (sim=0.25)"
      ]
    },
    {
      "name": "test_blueprint_url_defaults",
      "description": "handle a HTTP route request and return response. Function `test_blueprint_url_defaults`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_blueprint_url_defaults(app, client):\n    bp = flask.Blueprint(\"test\", __name__)\n\n    @bp.route(\"/foo\", defaults={\"baz\": 42})\n    def foo(bar, baz):\n        return f\"{bar}/{baz:d}\"\n\n    @bp.route(\"/bar\")\n    def bar(bar):\n        return str(bar)\n\n    app.register_blueprint(bp, url_prefix=\"/1\", url_defaults={\"bar\": 23})\n    app.register_blueprint(bp, name=\"test2\", url_prefix=\"/2\", url_defaults={\"bar\": 19})\n\n    assert client.get(\"/1/foo\").data == b\"23/42\"\n    assert client.get(\"/2/foo\").data == b\"19/42\"\n    assert client.get(\"/1/bar\").data == b\"23\"\n    assert client.get(\"/2/bar\").data == b\"19\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_blueprint_url_defaults` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function test_blueprint_url_defaults in tests\\test_blueprints.py",
        "matched template: handle a HTTP route request and return response (sim=0.25)"
      ]
    },
    {
      "name": "test_blueprint_url_processors",
      "description": "handle a HTTP route request and return response. Function `test_blueprint_url_processors`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_blueprint_url_processors(app, client):\n    bp = flask.Blueprint(\"frontend\", __name__, url_prefix=\"/<lang_code>\")\n\n    @bp.url_defaults\n    def add_language_code(endpoint, values):\n        values.setdefault(\"lang_code\", flask.g.lang_code)\n\n    @bp.url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop(\"lang_code\")\n\n    @bp.route(\"/\")\n    def index():\n        return flask.url_for(\".about\")\n\n    @bp.route(\"/about\")\n    def about():\n        return flask.url_for(\".index\")\n\n    app.register_blueprint(bp)\n\n    assert client.get(\"/de/\").data == b\"/de/about\"\n    assert client.get(\"/de/about\").data == b\"/de/\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_blueprint_url_processors` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_blueprint_url_processors in tests\\test_blueprints.py",
        "matched template: handle a HTTP route request and return response (sim=0.19)"
      ]
    },
    {
      "name": "test_templates_and_static",
      "description": "write data to a file. Function `test_templates_and_static`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_templates_and_static(test_apps):\n    from blueprintapp import app\n\n    client = app.test_client()\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"Hello from the Frontend\"\n    rv = client.get(\"/admin/\")\n    assert rv.data == b\"Hello from the Admin\"\n    rv = client.get(\"/admin/index2\")\n    assert rv.data == b\"Hello from the Admin\"\n    rv = client.get(\"/admin/static/test.txt\")\n    assert rv.data.strip() == b\"Admin File\"\n    rv.close()\n    rv = client.get(\"/admin/static/css/test.css\")\n    assert rv.data.strip() == b\"/* nested file */\"\n    rv.close()\n\n    # try/finally, in case other tests use this app for Blueprint tests.\n    max_age_default = app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n    try:\n        expected_max_age = 3600\n        if app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] == expected_max_age:\n            expected_max_age = 7200\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = expected_max_age\n        rv = client.get(\"/admin/static/css/test.css\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == expected_max_age\n        rv.close()\n    finally:\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = max_age_default\n\n    with app.test_request_context():\n        assert (\n            flask.url_for(\"admin.static\", filename=\"test.txt\")\n            == \"/admin/static/test.txt\"\n        )\n\n    with app.test_request_context():\n        with pytest.raises(TemplateNotFound) as e:\n            flask.render_template(\"missing.html\")\n        assert e.value.name == \"missing.html\"\n\n    with flask.Flask(__name__).test_request_context():\n        assert flask.render_template(\"nested/nested.txt\") == \"I'm nested\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "test_apps": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "test_apps"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "test_apps": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_templates_and_static` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function test_templates_and_static in tests\\test_blueprints.py",
        "matched template: write data to a file (sim=0.25)"
      ]
    },
    {
      "name": "test_default_static_max_age",
      "description": "write data to a file. Function `test_default_static_max_age`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_default_static_max_age(app):\n    class MyBlueprint(flask.Blueprint):\n        def get_send_file_max_age(self, filename):\n            return 100\n\n    blueprint = MyBlueprint(\"blueprint\", __name__, static_folder=\"static\")\n    app.register_blueprint(blueprint)\n\n    # try/finally, in case other tests use this app for Blueprint tests.\n    max_age_default = app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n    try:\n        with app.test_request_context():\n            unexpected_max_age = 3600\n            if app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] == unexpected_max_age:\n                unexpected_max_age = 7200\n            app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = unexpected_max_age\n            rv = blueprint.send_static_file(\"index.html\")\n            cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n            assert cc.max_age == 100\n            rv.close()\n    finally:\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = max_age_default",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_default_static_max_age` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function test_default_static_max_age in tests\\test_blueprints.py",
        "matched template: write data to a file (sim=0.13)"
      ]
    },
    {
      "name": "test_templates_list",
      "description": "handle a HTTP route request and return response. Function `test_templates_list`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_templates_list(test_apps):\n    from blueprintapp import app\n\n    templates = sorted(app.jinja_env.list_templates())\n    assert templates == [\"admin/index.html\", \"frontend/index.html\"]",
      "input_schema": {
        "type": "object",
        "properties": {
          "test_apps": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "test_apps"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "test_apps": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_templates_list` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_templates_list in tests\\test_blueprints.py",
        "matched template: handle a HTTP route request and return response (sim=0.18)"
      ]
    },
    {
      "name": "test_dotted_name_not_allowed",
      "description": "handle a HTTP route request and return response. Function `test_dotted_name_not_allowed`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_dotted_name_not_allowed(app, client):\n    with pytest.raises(ValueError):\n        flask.Blueprint(\"app.ui\", __name__)",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_dotted_name_not_allowed` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_dotted_name_not_allowed in tests\\test_blueprints.py",
        "matched template: handle a HTTP route request and return response (sim=0.18)"
      ]
    },
    {
      "name": "test_empty_name_not_allowed",
      "description": "handle a HTTP route request and return response. Function `test_empty_name_not_allowed`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_empty_name_not_allowed(app, client):\n    with pytest.raises(ValueError):\n        flask.Blueprint(\"\", __name__)",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_empty_name_not_allowed` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function test_empty_name_not_allowed in tests\\test_blueprints.py",
        "matched template: handle a HTTP route request and return response (sim=0.25)"
      ]
    },
    {
      "name": "test_dotted_names_from_app",
      "description": "handle a HTTP route request and return response. Function `test_dotted_names_from_app`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_dotted_names_from_app(app, client):\n    test = flask.Blueprint(\"test\", __name__)\n\n    @app.route(\"/\")\n    def app_index():\n        return flask.url_for(\"test.index\")\n\n    @test.route(\"/test/\")\n    def index():\n        return flask.url_for(\"app_index\")\n\n    app.register_blueprint(test)\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"/test/\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_dotted_names_from_app` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function test_dotted_names_from_app in tests\\test_blueprints.py",
        "matched template: handle a HTTP route request and return response (sim=0.16)"
      ]
    },
    {
      "name": "test_empty_url_defaults",
      "description": "handle a HTTP route request and return response. Function `test_empty_url_defaults`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_empty_url_defaults(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.route(\"/\", defaults={\"page\": 1})\n    @bp.route(\"/page/<int:page>\")\n    def something(page):\n        return str(page)\n\n    app.register_blueprint(bp)\n\n    assert client.get(\"/\").data == b\"1\"\n    assert client.get(\"/page/2\").data == b\"2\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_empty_url_defaults` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function test_empty_url_defaults in tests\\test_blueprints.py",
        "matched template: handle a HTTP route request and return response (sim=0.25)"
      ]
    },
    {
      "name": "test_route_decorator_custom_endpoint",
      "description": "handle a HTTP route request and return response. Function `test_route_decorator_custom_endpoint`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_route_decorator_custom_endpoint(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.route(\"/foo\")\n    def foo():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar\", endpoint=\"bar\")\n    def foo_bar():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar/123\", endpoint=\"123\")\n    def foo_bar_foo():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar/foo\")\n    def bar_foo():\n        return flask.request.endpoint\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.request.endpoint\n\n    assert client.get(\"/\").data == b\"index\"\n    assert client.get(\"/py/foo\").data == b\"bp.foo\"\n    assert client.get(\"/py/bar\").data == b\"bp.bar\"\n    assert client.get(\"/py/bar/123\").data == b\"bp.123\"\n    assert client.get(\"/py/bar/foo\").data == b\"bp.bar_foo\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_route_decorator_custom_endpoint` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.31,
      "evidence": [
        "function test_route_decorator_custom_endpoint in tests\\test_blueprints.py",
        "matched template: handle a HTTP route request and return response (sim=0.40)"
      ]
    },
    {
      "name": "test_route_decorator_custom_endpoint_with_dots",
      "description": "handle a HTTP route request and return response. Function `test_route_decorator_custom_endpoint_with_dots`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_route_decorator_custom_endpoint_with_dots(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    with pytest.raises(ValueError):\n        bp.route(\"/\", endpoint=\"a.b\")(lambda: \"\")\n\n    with pytest.raises(ValueError):\n        bp.add_url_rule(\"/\", endpoint=\"a.b\")\n\n    def view():\n        return \"\"\n\n    view.__name__ = \"a.b\"\n\n    with pytest.raises(ValueError):\n        bp.add_url_rule(\"/\", view_func=view)",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_route_decorator_custom_endpoint_with_dots` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.26,
      "evidence": [
        "function test_route_decorator_custom_endpoint_with_dots in tests\\test_blueprints.py",
        "matched template: handle a HTTP route request and return response (sim=0.33)"
      ]
    },
    {
      "name": "test_endpoint_decorator",
      "description": "handle a HTTP route request and return response. Function `test_endpoint_decorator`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_endpoint_decorator(app, client):\n    from werkzeug.routing import Rule\n\n    app.url_map.add(Rule(\"/foo\", endpoint=\"bar\"))\n\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.endpoint(\"bar\")\n    def foobar():\n        return flask.request.endpoint\n\n    app.register_blueprint(bp, url_prefix=\"/bp_prefix\")\n\n    assert client.get(\"/foo\").data == b\"bar\"\n    assert client.get(\"/bp_prefix/bar\").status_code == 404",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_endpoint_decorator` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.24,
      "evidence": [
        "function test_endpoint_decorator in tests\\test_blueprints.py",
        "matched template: handle a HTTP route request and return response (sim=0.30)"
      ]
    },
    {
      "name": "test_template_filter",
      "description": "compute cryptographic hash of input data. Function `test_template_filter`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_template_filter(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter()\n    def my_reverse(s):\n        return s[::-1]\n\n    @bp.app_template_filter\n    def my_reverse_2(s):\n        return s[::-1]\n\n    @bp.app_template_filter(\"my_reverse_custom_name_3\")\n    def my_reverse_3(s):\n        return s[::-1]\n\n    @bp.app_template_filter(name=\"my_reverse_custom_name_4\")\n    def my_reverse_4(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n\n    assert \"my_reverse_2\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse_2\"] == my_reverse_2\n    assert app.jinja_env.filters[\"my_reverse_2\"](\"abcd\") == \"dcba\"\n\n    assert \"my_reverse_custom_name_3\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse_custom_name_3\"] == my_reverse_3\n    assert app.jinja_env.filters[\"my_reverse_custom_name_3\"](\"abcd\") == \"dcba\"\n\n    assert \"my_reverse_custom_name_4\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse_custom_name_4\"] == my_reverse_4\n    assert app.jinja_env.filters[\"my_reverse_custom_name_4\"](\"abcd\") == \"dcba\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_template_filter` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function test_template_filter in tests\\test_blueprints.py",
        "matched template: compute cryptographic hash of input data (sim=0.13)"
      ]
    },
    {
      "name": "test_add_template_filter",
      "description": "validate and sanitize user input. Function `test_add_template_filter`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_add_template_filter(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def my_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(my_reverse)\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_add_template_filter` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function test_add_template_filter in tests\\test_blueprints.py",
        "matched template: validate and sanitize user input (sim=0.17)"
      ]
    },
    {
      "name": "test_template_filter_with_name",
      "description": "validate and sanitize user input. Function `test_template_filter_with_name`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_template_filter_with_name(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter(\"strrev\")\n    def my_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_template_filter_with_name` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_template_filter_with_name in tests\\test_blueprints.py",
        "matched template: validate and sanitize user input (sim=0.19)"
      ]
    },
    {
      "name": "test_add_template_filter_with_name",
      "description": "validate and sanitize user input. Function `test_add_template_filter_with_name`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_add_template_filter_with_name(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def my_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(my_reverse, \"strrev\")\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_add_template_filter_with_name` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_add_template_filter_with_name in tests\\test_blueprints.py",
        "matched template: validate and sanitize user input (sim=0.17)"
      ]
    },
    {
      "name": "test_template_filter_with_template",
      "description": "handle a HTTP route request and return response. Function `test_template_filter_with_template`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_template_filter_with_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_template_filter_with_template` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function test_template_filter_with_template in tests\\test_blueprints.py",
        "matched template: handle a HTTP route request and return response (sim=0.21)"
      ]
    },
    {
      "name": "test_template_filter_after_route_with_template",
      "description": "handle a HTTP route request and return response. Function `test_template_filter_after_route_with_template`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_template_filter_after_route_with_template(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_template_filter_after_route_with_template` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function test_template_filter_after_route_with_template in tests\\test_blueprints.py",
        "matched template: handle a HTTP route request and return response (sim=0.28)"
      ]
    },
    {
      "name": "test_add_template_filter_with_template",
      "description": "handle a HTTP route request and return response. Function `test_add_template_filter_with_template`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_add_template_filter_with_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def super_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(super_reverse)\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_add_template_filter_with_template` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function test_add_template_filter_with_template in tests\\test_blueprints.py",
        "matched template: handle a HTTP route request and return response (sim=0.21)"
      ]
    },
    {
      "name": "test_template_filter_with_name_and_template",
      "description": "handle a HTTP route request and return response. Function `test_template_filter_with_name_and_template`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_template_filter_with_name_and_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter(\"super_reverse\")\n    def my_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_template_filter_with_name_and_template` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function test_template_filter_with_name_and_template in tests\\test_blueprints.py",
        "matched template: handle a HTTP route request and return response (sim=0.23)"
      ]
    },
    {
      "name": "test_add_template_filter_with_name_and_template",
      "description": "handle a HTTP route request and return response. Function `test_add_template_filter_with_name_and_template`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_add_template_filter_with_name_and_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def my_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(my_reverse, \"super_reverse\")\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_add_template_filter_with_name_and_template` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function test_add_template_filter_with_name_and_template in tests\\test_blueprints.py",
        "matched template: handle a HTTP route request and return response (sim=0.22)"
      ]
    },
    {
      "name": "test_template_test",
      "description": "validate and sanitize user input. Function `test_template_test`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_template_test(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_test()\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    @bp.app_template_test\n    def boolean_2(value):\n        return isinstance(value, bool)\n\n    @bp.app_template_test(\"my_boolean_custom_name\")\n    def boolean_3(value):\n        return isinstance(value, bool)\n\n    @bp.app_template_test(name=\"my_boolean_custom_name_2\")\n    def boolean_4(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"is_boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"is_boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"is_boolean\"](False)\n\n    assert \"boolean_2\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean_2\"] == boolean_2\n    assert app.jinja_env.tests[\"boolean_2\"](False)\n\n    assert \"my_boolean_custom_name\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"my_boolean_custom_name\"] == boolean_3\n    assert app.jinja_env.tests[\"my_boolean_custom_name\"](False)\n\n    assert \"my_boolean_custom_name_2\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"my_boolean_custom_name_2\"] == boolean_4\n    assert app.jinja_env.tests[\"my_boolean_custom_name_2\"](False)",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_template_test` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function test_template_test in tests\\test_blueprints.py",
        "matched template: validate and sanitize user input (sim=0.17)"
      ]
    },
    {
      "name": "test_add_template_test",
      "description": "validate and sanitize user input. Function `test_add_template_test`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_add_template_test(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    bp.add_app_template_test(is_boolean)\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"is_boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"is_boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"is_boolean\"](False)",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_add_template_test` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_add_template_test in tests\\test_blueprints.py",
        "matched template: validate and sanitize user input (sim=0.18)"
      ]
    },
    {
      "name": "test_template_test_with_name",
      "description": "validate and sanitize user input. Function `test_template_test_with_name`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_template_test_with_name(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"boolean\"](False)",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_template_test_with_name` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_template_test_with_name in tests\\test_blueprints.py",
        "matched template: validate and sanitize user input (sim=0.18)"
      ]
    },
    {
      "name": "test_add_template_test_with_name",
      "description": "validate and sanitize user input. Function `test_add_template_test_with_name`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_add_template_test_with_name(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    bp.add_app_template_test(is_boolean, \"boolean\")\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"boolean\"](False)",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_add_template_test_with_name` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function test_add_template_test_with_name in tests\\test_blueprints.py",
        "matched template: validate and sanitize user input (sim=0.17)"
      ]
    },
    {
      "name": "test_template_test_with_template",
      "description": "handle a HTTP route request and return response. Function `test_template_test_with_template`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_template_test_with_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_template_test_with_template` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function test_template_test_with_template in tests\\test_blueprints.py",
        "matched template: handle a HTTP route request and return response (sim=0.21)"
      ]
    },
    {
      "name": "test_template_test_after_route_with_template",
      "description": "handle a HTTP route request and return response. Function `test_template_test_after_route_with_template`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_template_test_after_route_with_template(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_template_test_after_route_with_template` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.24,
      "evidence": [
        "function test_template_test_after_route_with_template in tests\\test_blueprints.py",
        "matched template: handle a HTTP route request and return response (sim=0.29)"
      ]
    },
    {
      "name": "test_add_template_test_with_template",
      "description": "handle a HTTP route request and return response. Function `test_add_template_test_with_template`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_add_template_test_with_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def boolean(value):\n        return isinstance(value, bool)\n\n    bp.add_app_template_test(boolean)\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_add_template_test_with_template` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function test_add_template_test_with_template in tests\\test_blueprints.py",
        "matched template: handle a HTTP route request and return response (sim=0.21)"
      ]
    },
    {
      "name": "test_template_test_with_name_and_template",
      "description": "handle a HTTP route request and return response. Function `test_template_test_with_name_and_template`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_template_test_with_name_and_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_template_test_with_name_and_template` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function test_template_test_with_name_and_template in tests\\test_blueprints.py",
        "matched template: handle a HTTP route request and return response (sim=0.21)"
      ]
    },
    {
      "name": "test_add_template_test_with_name_and_template",
      "description": "handle a HTTP route request and return response. Function `test_add_template_test_with_name_and_template`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_add_template_test_with_name_and_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    bp.add_app_template_test(is_boolean, \"boolean\")\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_add_template_test_with_name_and_template` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function test_add_template_test_with_name_and_template in tests\\test_blueprints.py",
        "matched template: handle a HTTP route request and return response (sim=0.21)"
      ]
    },
    {
      "name": "test_context_processing",
      "description": "handle a HTTP route request and return response. Function `test_context_processing`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_context_processing(app, client):\n    answer_bp = flask.Blueprint(\"answer_bp\", __name__)\n\n    def template_string():\n        return flask.render_template_string(\n            \"{% if notanswer %}{{ notanswer }} is not the answer. {% endif %}\"\n            \"{% if answer %}{{ answer }} is the answer.{% endif %}\"\n        )\n\n    # App global context processor\n    @answer_bp.app_context_processor\n    def not_answer_context_processor():\n        return {\"notanswer\": 43}\n\n    # Blueprint local context processor\n    @answer_bp.context_processor\n    def answer_context_processor():\n        return {\"answer\": 42}\n\n    # Setup endpoints for testing\n    @answer_bp.route(\"/bp\")\n    def bp_page():\n        return template_string()\n\n    @app.route(\"/\")\n    def app_page():\n        return template_string()\n\n    # Register the blueprint\n    app.register_blueprint(answer_bp)\n\n    app_page_bytes = client.get(\"/\").data\n    answer_page_bytes = client.get(\"/bp\").data\n\n    assert b\"43\" in app_page_bytes\n    assert b\"42\" not in app_page_bytes\n\n    assert b\"42\" in answer_page_bytes\n    assert b\"43\" in answer_page_bytes",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "notanswer": {
            "type": "integer"
          }
        },
        "required": [
          "notanswer"
        ]
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object",
          "properties": {
            "notanswer": {
              "type": "integer"
            }
          },
          "required": [
            "notanswer"
          ]
        }
      },
      "explanation": "Detected Python function `test_context_processing` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.24,
      "evidence": [
        "function test_context_processing in tests\\test_blueprints.py",
        "matched template: handle a HTTP route request and return response (sim=0.29)"
      ]
    },
    {
      "name": "test_template_global",
      "description": "execute a shell command. Function `test_template_global`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_template_global(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_global()\n    def get_answer():\n        return 42\n\n    @bp.app_template_global\n    def get_stuff_1():\n        return \"get_stuff_1\"\n\n    @bp.app_template_global(\"my_get_stuff_custom_name_2\")\n    def get_stuff_2():\n        return \"get_stuff_2\"\n\n    @bp.app_template_global(name=\"my_get_stuff_custom_name_3\")\n    def get_stuff_3():\n        return \"get_stuff_3\"\n\n    # Make sure the function is not in the jinja_env already\n    assert \"get_answer\" not in app.jinja_env.globals.keys()\n    app.register_blueprint(bp)\n\n    # Tests\n    assert \"get_answer\" in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals[\"get_answer\"] is get_answer\n    assert app.jinja_env.globals[\"get_answer\"]() == 42\n\n    assert \"get_stuff_1\" in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals[\"get_stuff_1\"] == get_stuff_1\n    assert app.jinja_env.globals[\"get_stuff_1\"](), \"get_stuff_1\"\n\n    assert \"my_get_stuff_custom_name_2\" in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals[\"my_get_stuff_custom_name_2\"] == get_stuff_2\n    assert app.jinja_env.globals[\"my_get_stuff_custom_name_2\"](), \"get_stuff_2\"\n\n    assert \"my_get_stuff_custom_name_3\" in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals[\"my_get_stuff_custom_name_3\"] == get_stuff_3\n    assert app.jinja_env.globals[\"my_get_stuff_custom_name_3\"](), \"get_stuff_3\"\n\n    with app.app_context():\n        rv = flask.render_template_string(\"{{ get_answer() }}\")\n        assert rv == \"42\"\n\n        rv = flask.render_template_string(\"{{ get_stuff_1() }}\")\n        assert rv == \"get_stuff_1\"\n\n        rv = flask.render_template_string(\"{{ my_get_stuff_custom_name_2() }}\")\n        assert rv == \"get_stuff_2\"\n\n        rv = flask.render_template_string(\"{{ my_get_stuff_custom_name_3() }}\")\n        assert rv == \"get_stuff_3\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_template_global` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function test_template_global in tests\\test_blueprints.py",
        "matched template: execute a shell command (sim=0.13)"
      ]
    },
    {
      "name": "test_request_processing",
      "description": "handle a HTTP route request and return response. Function `test_request_processing`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_request_processing(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n    evts = []\n\n    @bp.before_request\n    def before_bp():\n        evts.append(\"before\")\n\n    @bp.after_request\n    def after_bp(response):\n        response.data += b\"|after\"\n        evts.append(\"after\")\n        return response\n\n    @bp.teardown_request\n    def teardown_bp(exc):\n        evts.append(\"teardown\")\n\n    # Setup routes for testing\n    @bp.route(\"/bp\")\n    def bp_endpoint():\n        return \"request\"\n\n    app.register_blueprint(bp)\n\n    assert evts == []\n    rv = client.get(\"/bp\")\n    assert rv.data == b\"request|after\"\n    assert evts == [\"before\", \"after\", \"teardown\"]",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_request_processing` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.27,
      "evidence": [
        "function test_request_processing in tests\\test_blueprints.py",
        "matched template: handle a HTTP route request and return response (sim=0.33)"
      ]
    },
    {
      "name": "test_app_request_processing",
      "description": "handle a HTTP route request and return response. Function `test_app_request_processing`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_app_request_processing(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n    evts = []\n\n    @bp.before_app_request\n    def before_app():\n        evts.append(\"before\")\n\n    @bp.after_app_request\n    def after_app(response):\n        response.data += b\"|after\"\n        evts.append(\"after\")\n        return response\n\n    @bp.teardown_app_request\n    def teardown_app(exc):\n        evts.append(\"teardown\")\n\n    app.register_blueprint(bp)\n\n    # Setup routes for testing\n    @app.route(\"/\")\n    def bp_endpoint():\n        return \"request\"\n\n    # before first request\n    assert evts == []\n\n    # first request\n    resp = client.get(\"/\").data\n    assert resp == b\"request|after\"\n    assert evts == [\"before\", \"after\", \"teardown\"]\n\n    # second request\n    resp = client.get(\"/\").data\n    assert resp == b\"request|after\"\n    assert evts == [\"before\", \"after\", \"teardown\"] * 2",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_app_request_processing` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.29,
      "evidence": [
        "function test_app_request_processing in tests\\test_blueprints.py",
        "matched template: handle a HTTP route request and return response (sim=0.37)"
      ]
    },
    {
      "name": "test_app_url_processors",
      "description": "handle a HTTP route request and return response. Function `test_app_url_processors`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_app_url_processors(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    # Register app-wide url defaults and preprocessor on blueprint\n    @bp.app_url_defaults\n    def add_language_code(endpoint, values):\n        values.setdefault(\"lang_code\", flask.g.lang_code)\n\n    @bp.app_url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop(\"lang_code\")\n\n    # Register route rules at the app level\n    @app.route(\"/<lang_code>/\")\n    def index():\n        return flask.url_for(\"about\")\n\n    @app.route(\"/<lang_code>/about\")\n    def about():\n        return flask.url_for(\"index\")\n\n    app.register_blueprint(bp)\n\n    assert client.get(\"/de/\").data == b\"/de/about\"\n    assert client.get(\"/de/about\").data == b\"/de/\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_app_url_processors` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function test_app_url_processors in tests\\test_blueprints.py",
        "matched template: handle a HTTP route request and return response (sim=0.26)"
      ]
    },
    {
      "name": "test_nested_blueprint",
      "description": "handle a HTTP route request and return response. Function `test_nested_blueprint`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_nested_blueprint(app, client):\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__)\n    grandchild = flask.Blueprint(\"grandchild\", __name__)\n\n    @parent.errorhandler(403)\n    def forbidden(e):\n        return \"Parent no\", 403\n\n    @parent.route(\"/\")\n    def parent_index():\n        return \"Parent yes\"\n\n    @parent.route(\"/no\")\n    def parent_no():\n        flask.abort(403)\n\n    @child.route(\"/\")\n    def child_index():\n        return \"Child yes\"\n\n    @child.route(\"/no\")\n    def child_no():\n        flask.abort(403)\n\n    @grandchild.errorhandler(403)\n    def grandchild_forbidden(e):\n        return \"Grandchild no\", 403\n\n    @grandchild.route(\"/\")\n    def grandchild_index():\n        return \"Grandchild yes\"\n\n    @grandchild.route(\"/no\")\n    def grandchild_no():\n        flask.abort(403)\n\n    child.register_blueprint(grandchild, url_prefix=\"/grandchild\")\n    parent.register_blueprint(child, url_prefix=\"/child\")\n    app.register_blueprint(parent, url_prefix=\"/parent\")\n\n    assert client.get(\"/parent/\").data == b\"Parent yes\"\n    assert client.get(\"/parent/child/\").data == b\"Child yes\"\n    assert client.get(\"/parent/child/grandchild/\").data == b\"Grandchild yes\"\n    assert client.get(\"/parent/no\").data == b\"Parent no\"\n    assert client.get(\"/parent/child/no\").data == b\"Parent no\"\n    assert client.get(\"/parent/child/grandchild/no\").data == b\"Grandchild no\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_nested_blueprint` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function test_nested_blueprint in tests\\test_blueprints.py",
        "matched template: handle a HTTP route request and return response (sim=0.26)"
      ]
    },
    {
      "name": "test_nested_callback_order",
      "description": "stream data over websocket. Function `test_nested_callback_order`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_nested_callback_order(app, client):\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__)\n\n    @app.before_request\n    def app_before1():\n        flask.g.setdefault(\"seen\", []).append(\"app_1\")\n\n    @app.teardown_request\n    def app_teardown1(e=None):\n        assert flask.g.seen.pop() == \"app_1\"\n\n    @app.before_request\n    def app_before2():\n        flask.g.setdefault(\"seen\", []).append(\"app_2\")\n\n    @app.teardown_request\n    def app_teardown2(e=None):\n        assert flask.g.seen.pop() == \"app_2\"\n\n    @app.context_processor\n    def app_ctx():\n        return dict(key=\"app\")\n\n    @parent.before_request\n    def parent_before1():\n        flask.g.setdefault(\"seen\", []).append(\"parent_1\")\n\n    @parent.teardown_request\n    def parent_teardown1(e=None):\n        assert flask.g.seen.pop() == \"parent_1\"\n\n    @parent.before_request\n    def parent_before2():\n        flask.g.setdefault(\"seen\", []).append(\"parent_2\")\n\n    @parent.teardown_request\n    def parent_teardown2(e=None):\n        assert flask.g.seen.pop() == \"parent_2\"\n\n    @parent.context_processor\n    def parent_ctx():\n        return dict(key=\"parent\")\n\n    @child.before_request\n    def child_before1():\n        flask.g.setdefault(\"seen\", []).append(\"child_1\")\n\n    @child.teardown_request\n    def child_teardown1(e=None):\n        assert flask.g.seen.pop() == \"child_1\"\n\n    @child.before_request\n    def child_before2():\n        flask.g.setdefault(\"seen\", []).append(\"child_2\")\n\n    @child.teardown_request\n    def child_teardown2(e=None):\n        assert flask.g.seen.pop() == \"child_2\"\n\n    @child.context_processor\n    def child_ctx():\n        return dict(key=\"child\")\n\n    @child.route(\"/a\")\n    def a():\n        return \", \".join(flask.g.seen)\n\n    @child.route(\"/b\")\n    def b():\n        return flask.render_template_string(\"{{ key }}\")\n\n    parent.register_blueprint(child)\n    app.register_blueprint(parent)\n    assert (\n        client.get(\"/a\").data == b\"app_1, app_2, parent_1, parent_2, child_1, child_2\"\n    )\n    assert client.get(\"/b\").data == b\"child\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_nested_callback_order` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function test_nested_callback_order in tests\\test_blueprints.py",
        "matched template: stream data over websocket (sim=0.15)"
      ]
    },
    {
      "name": "test_nesting_url_prefixes",
      "description": "handle a HTTP route request and return response. Function `test_nesting_url_prefixes`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_nesting_url_prefixes(\n    parent_init,\n    child_init,\n    parent_registration,\n    child_registration,\n    app,\n    client,\n) -> None:\n    parent = flask.Blueprint(\"parent\", __name__, url_prefix=parent_init)\n    child = flask.Blueprint(\"child\", __name__, url_prefix=child_init)\n\n    @child.route(\"/\")\n    def index():\n        return \"index\"\n\n    parent.register_blueprint(child, url_prefix=child_registration)\n    app.register_blueprint(parent, url_prefix=parent_registration)\n\n    response = client.get(\"/parent/child/\")\n    assert response.status_code == 200",
      "input_schema": {
        "type": "object",
        "properties": {
          "parent_init": {
            "type": "string",
            "required": true
          },
          "child_init": {
            "type": "string",
            "required": true
          },
          "parent_registration": {
            "type": "string",
            "required": true
          },
          "child_registration": {
            "type": "string",
            "required": true
          },
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "parent_init",
          "child_init",
          "parent_registration",
          "child_registration",
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "parent_init": "string",
          "child_init": "string",
          "parent_registration": "string",
          "child_registration": "string",
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `test_nesting_url_prefixes` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function test_nesting_url_prefixes in tests\\test_blueprints.py",
        "matched template: handle a HTTP route request and return response (sim=0.21)"
      ]
    },
    {
      "name": "test_nesting_subdomains",
      "description": "handle a HTTP route request and return response. Function `test_nesting_subdomains`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_nesting_subdomains(app, client) -> None:\n    app.subdomain_matching = True\n    app.config[\"SERVER_NAME\"] = \"example.test\"\n    client.allow_subdomain_redirects = True\n\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__)\n\n    @child.route(\"/child/\")\n    def index():\n        return \"child\"\n\n    parent.register_blueprint(child)\n    app.register_blueprint(parent, subdomain=\"api\")\n\n    response = client.get(\"/child/\", base_url=\"http://api.example.test\")\n    assert response.status_code == 200",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `test_nesting_subdomains` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function test_nesting_subdomains in tests\\test_blueprints.py",
        "matched template: handle a HTTP route request and return response (sim=0.25)"
      ]
    },
    {
      "name": "test_child_and_parent_subdomain",
      "description": "handle a HTTP route request and return response. Function `test_child_and_parent_subdomain`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_child_and_parent_subdomain(app, client) -> None:\n    app.subdomain_matching = True\n    app.config[\"SERVER_NAME\"] = \"example.test\"\n    client.allow_subdomain_redirects = True\n\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__, subdomain=\"api\")\n\n    @child.route(\"/\")\n    def index():\n        return \"child\"\n\n    parent.register_blueprint(child)\n    app.register_blueprint(parent, subdomain=\"parent\")\n\n    response = client.get(\"/\", base_url=\"http://api.parent.example.test\")\n    assert response.status_code == 200\n\n    response = client.get(\"/\", base_url=\"http://parent.example.test\")\n    assert response.status_code == 404",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `test_child_and_parent_subdomain` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function test_child_and_parent_subdomain in tests\\test_blueprints.py",
        "matched template: handle a HTTP route request and return response (sim=0.28)"
      ]
    },
    {
      "name": "test_unique_blueprint_names",
      "description": "validate and sanitize user input. Function `test_unique_blueprint_names`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_unique_blueprint_names(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    bp2 = flask.Blueprint(\"bp\", __name__)\n\n    app.register_blueprint(bp)\n\n    with pytest.raises(ValueError):\n        app.register_blueprint(bp)  # same bp, same name, error\n\n    app.register_blueprint(bp, name=\"again\")  # same bp, different name, ok\n\n    with pytest.raises(ValueError):\n        app.register_blueprint(bp2)  # different bp, same name, error\n\n    app.register_blueprint(bp2, name=\"alt\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `test_unique_blueprint_names` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function test_unique_blueprint_names in tests\\test_blueprints.py",
        "matched template: validate and sanitize user input (sim=0.16)"
      ]
    },
    {
      "name": "test_self_registration",
      "description": "handle a HTTP route request and return response. Function `test_self_registration`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_self_registration(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    with pytest.raises(ValueError):\n        bp.register_blueprint(bp)",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `test_self_registration` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_self_registration in tests\\test_blueprints.py",
        "matched template: handle a HTTP route request and return response (sim=0.19)"
      ]
    },
    {
      "name": "test_blueprint_renaming",
      "description": "make an HTTP request to an external API. Function `test_blueprint_renaming`.",
      "predicted_filename": "tests\\test_blueprints.py",
      "predicted_code_snippet": "def test_blueprint_renaming(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    bp2 = flask.Blueprint(\"bp2\", __name__)\n\n    @bp.get(\"/\")\n    def index():\n        return flask.request.endpoint\n\n    @bp.get(\"/error\")\n    def error():\n        flask.abort(403)\n\n    @bp.errorhandler(403)\n    def forbidden(_: Exception):\n        return \"Error\", 403\n\n    @bp2.get(\"/\")\n    def index2():\n        return flask.request.endpoint\n\n    bp.register_blueprint(bp2, url_prefix=\"/a\", name=\"sub\")\n    app.register_blueprint(bp, url_prefix=\"/a\")\n    app.register_blueprint(bp, url_prefix=\"/b\", name=\"alt\")\n\n    assert client.get(\"/a/\").data == b\"bp.index\"\n    assert client.get(\"/b/\").data == b\"alt.index\"\n    assert client.get(\"/a/a/\").data == b\"bp.sub.index2\"\n    assert client.get(\"/b/a/\").data == b\"alt.sub.index2\"\n    assert client.get(\"/a/error\").data == b\"Error\"\n    assert client.get(\"/b/error\").data == b\"Error\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `test_blueprint_renaming` in tests\\test_blueprints.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function test_blueprint_renaming in tests\\test_blueprints.py",
        "matched template: make an HTTP request to an external API (sim=0.21)"
      ]
    },
    {
      "name": "runner",
      "description": "execute a shell command. Function `runner`.",
      "predicted_filename": "tests\\test_cli.py",
      "predicted_code_snippet": "def runner():\n    return CliRunner()",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `runner` in tests\\test_cli.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function runner in tests\\test_cli.py",
        "matched template: execute a shell command (sim=0.27)"
      ]
    },
    {
      "name": "test_cli_name",
      "description": "execute a shell command. Function `test_cli_name`.",
      "predicted_filename": "tests\\test_cli.py",
      "predicted_code_snippet": "def test_cli_name(test_apps):\n    \"\"\"Make sure the CLI object's name is the app's name and not the app itself\"\"\"\n    from cliapp.app import testapp\n\n    assert testapp.cli.name == testapp.name",
      "input_schema": {
        "type": "object",
        "properties": {
          "test_apps": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "test_apps"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "test_apps": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_cli_name` in tests\\test_cli.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function test_cli_name in tests\\test_cli.py",
        "matched template: execute a shell command (sim=0.16)"
      ]
    },
    {
      "name": "test_find_best_app",
      "description": "validate and sanitize user input. Function `test_find_best_app`.",
      "predicted_filename": "tests\\test_cli.py",
      "predicted_code_snippet": "def test_find_best_app(test_apps):\n    class Module:\n        app = Flask(\"appname\")\n\n    assert find_best_app(Module) == Module.app\n\n    class Module:\n        application = Flask(\"appname\")\n\n    assert find_best_app(Module) == Module.application\n\n    class Module:\n        myapp = Flask(\"appname\")\n\n    assert find_best_app(Module) == Module.myapp\n\n    class Module:\n        @staticmethod\n        def create_app():\n            return Flask(\"appname\")\n\n    app = find_best_app(Module)\n    assert isinstance(app, Flask)\n    assert app.name == \"appname\"\n\n    class Module:\n        @staticmethod\n        def create_app(**kwargs):\n            return Flask(\"appname\")\n\n    app = find_best_app(Module)\n    assert isinstance(app, Flask)\n    assert app.name == \"appname\"\n\n    class Module:\n        @staticmethod\n        def make_app():\n            return Flask(\"appname\")\n\n    app = find_best_app(Module)\n    assert isinstance(app, Flask)\n    assert app.name == \"appname\"\n\n    class Module:\n        myapp = Flask(\"appname1\")\n\n        @staticmethod\n        def create_app():\n            return Flask(\"appname2\")\n\n    assert find_best_app(Module) == Module.myapp\n\n    class Module:\n        myapp = Flask(\"appname1\")\n\n        @staticmethod\n        def create_app():\n            return Flask(\"appname2\")\n\n    assert find_best_app(Module) == Module.myapp\n\n    class Module:\n        pass\n\n    pytest.raises(NoAppException, find_best_app, Module)\n\n    class Module:\n        myapp1 = Flask(\"appname1\")\n        myapp2 = Flask(\"appname2\")\n\n    pytest.raises(NoAppException, find_best_app, Module)\n\n    class Module:\n        @staticmethod\n        def create_app(foo, bar):\n            return Flask(\"appname2\")\n\n    pytest.raises(NoAppException, find_best_app, Module)\n\n    class Module:\n        @staticmethod\n        def create_app():\n            raise TypeError(\"bad bad factory!\")\n\n    pytest.raises(TypeError, find_best_app, Module)",
      "input_schema": {
        "type": "object",
        "properties": {
          "test_apps": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "test_apps"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "test_apps": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_find_best_app` in tests\\test_cli.py",
      "possible_syscalls": [],
      "confidence": 0.16,
      "evidence": [
        "function test_find_best_app in tests\\test_cli.py",
        "matched template: validate and sanitize user input (sim=0.08)"
      ]
    },
    {
      "name": "test_prepare_import",
      "description": "write data to a file. Function `test_prepare_import`.",
      "predicted_filename": "tests\\test_cli.py",
      "predicted_code_snippet": "def test_prepare_import(request, value, path, result):\n    \"\"\"Expect the correct path to be set and the correct import and app names\n    to be returned.\n\n    :func:`prepare_exec_for_file` has a side effect where the parent directory\n    of the given import is added to :data:`sys.path`. This is reset after the\n    test runs.\n    \"\"\"\n    original_path = sys.path[:]\n\n    def reset_path():\n        sys.path[:] = original_path\n\n    request.addfinalizer(reset_path)\n\n    assert prepare_import(value) == result\n    assert sys.path[0] == str(path)",
      "input_schema": {
        "type": "object",
        "properties": {
          "request": {
            "type": "string",
            "required": true
          },
          "value": {
            "type": "string",
            "required": true
          },
          "path": {
            "type": "string",
            "required": true
          },
          "result": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "request",
          "value",
          "path",
          "result"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "request": "string",
          "value": "string",
          "path": "string",
          "result": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_prepare_import` in tests\\test_cli.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_prepare_import in tests\\test_cli.py",
        "matched template: write data to a file (sim=0.18)"
      ]
    },
    {
      "name": "test_locate_app",
      "description": "execute a shell command. Function `test_locate_app`.",
      "predicted_filename": "tests\\test_cli.py",
      "predicted_code_snippet": "def test_locate_app(test_apps, iname, aname, result):\n    assert locate_app(iname, aname).name == result",
      "input_schema": {
        "type": "object",
        "properties": {
          "test_apps": {
            "type": "string",
            "required": true
          },
          "iname": {
            "type": "string",
            "required": true
          },
          "aname": {
            "type": "string",
            "required": true
          },
          "result": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "test_apps",
          "iname",
          "aname",
          "result"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "test_apps": "string",
          "iname": "string",
          "aname": "string",
          "result": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_locate_app` in tests\\test_cli.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_locate_app in tests\\test_cli.py",
        "matched template: execute a shell command (sim=0.18)"
      ]
    },
    {
      "name": "test_locate_app_raises",
      "description": "execute a shell command. Function `test_locate_app_raises`.",
      "predicted_filename": "tests\\test_cli.py",
      "predicted_code_snippet": "def test_locate_app_raises(test_apps, iname, aname):\n    with pytest.raises(NoAppException):\n        locate_app(iname, aname)",
      "input_schema": {
        "type": "object",
        "properties": {
          "test_apps": {
            "type": "string",
            "required": true
          },
          "iname": {
            "type": "string",
            "required": true
          },
          "aname": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "test_apps",
          "iname",
          "aname"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "test_apps": "string",
          "iname": "string",
          "aname": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_locate_app_raises` in tests\\test_cli.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_locate_app_raises in tests\\test_cli.py",
        "matched template: execute a shell command (sim=0.18)"
      ]
    },
    {
      "name": "test_locate_app_suppress_raise",
      "description": "validate and sanitize user input. Function `test_locate_app_suppress_raise`.",
      "predicted_filename": "tests\\test_cli.py",
      "predicted_code_snippet": "def test_locate_app_suppress_raise(test_apps):\n    app = locate_app(\"notanapp.py\", None, raise_if_not_found=False)\n    assert app is None\n\n    # only direct import error is suppressed\n    with pytest.raises(NoAppException):\n        locate_app(\"cliapp.importerrorapp\", None, raise_if_not_found=False)",
      "input_schema": {
        "type": "object",
        "properties": {
          "test_apps": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "test_apps"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "test_apps": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_locate_app_suppress_raise` in tests\\test_cli.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function test_locate_app_suppress_raise in tests\\test_cli.py",
        "matched template: validate and sanitize user input (sim=0.12)"
      ]
    },
    {
      "name": "test_get_version",
      "description": "cache results to disk or memory. Function `test_get_version`.",
      "predicted_filename": "tests\\test_cli.py",
      "predicted_code_snippet": "def test_get_version(test_apps, capsys):\n    class MockCtx:\n        resilient_parsing = False\n        color = None\n\n        def exit(self):\n            return\n\n    ctx = MockCtx()\n    get_version(ctx, None, \"test\")\n    out, err = capsys.readouterr()\n    assert f\"Python {platform.python_version()}\" in out\n    assert f\"Flask {importlib.metadata.version('flask')}\" in out\n    assert f\"Werkzeug {importlib.metadata.version('werkzeug')}\" in out",
      "input_schema": {
        "type": "object",
        "properties": {
          "test_apps": {
            "type": "string",
            "required": true
          },
          "capsys": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "test_apps",
          "capsys"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "test_apps": "string",
          "capsys": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_get_version` in tests\\test_cli.py",
      "possible_syscalls": [],
      "confidence": 0.16,
      "evidence": [
        "function test_get_version in tests\\test_cli.py",
        "matched template: cache results to disk or memory (sim=0.08)"
      ]
    },
    {
      "name": "test_scriptinfo",
      "description": "execute a shell command. Function `test_scriptinfo`.",
      "predicted_filename": "tests\\test_cli.py",
      "predicted_code_snippet": "def test_scriptinfo(test_apps, monkeypatch):\n    obj = ScriptInfo(app_import_path=\"cliapp.app:testapp\")\n    app = obj.load_app()\n    assert app.name == \"testapp\"\n    assert obj.load_app() is app\n\n    # import app with module's absolute path\n    cli_app_path = str(test_path / \"cliapp\" / \"app.py\")\n\n    obj = ScriptInfo(app_import_path=cli_app_path)\n    app = obj.load_app()\n    assert app.name == \"testapp\"\n    assert obj.load_app() is app\n    obj = ScriptInfo(app_import_path=f\"{cli_app_path}:testapp\")\n    app = obj.load_app()\n    assert app.name == \"testapp\"\n    assert obj.load_app() is app\n\n    def create_app():\n        return Flask(\"createapp\")\n\n    obj = ScriptInfo(create_app=create_app)\n    app = obj.load_app()\n    assert app.name == \"createapp\"\n    assert obj.load_app() is app\n\n    obj = ScriptInfo()\n    pytest.raises(NoAppException, obj.load_app)\n\n    # import app from wsgi.py in current directory\n    monkeypatch.chdir(test_path / \"helloworld\")\n    obj = ScriptInfo()\n    app = obj.load_app()\n    assert app.name == \"hello\"\n\n    # import app from app.py in current directory\n    monkeypatch.chdir(test_path / \"cliapp\")\n    obj = ScriptInfo()\n    app = obj.load_app()\n    assert app.name == \"testapp\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "test_apps": {
            "type": "string",
            "required": true
          },
          "monkeypatch": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "test_apps",
          "monkeypatch"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "test_apps": "string",
          "monkeypatch": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_scriptinfo` in tests\\test_cli.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function test_scriptinfo in tests\\test_cli.py",
        "matched template: execute a shell command (sim=0.14)"
      ]
    },
    {
      "name": "test_app_cli_has_app_context",
      "description": "execute a shell command. Function `test_app_cli_has_app_context`.",
      "predicted_filename": "tests\\test_cli.py",
      "predicted_code_snippet": "def test_app_cli_has_app_context(app, runner):\n    def _param_cb(ctx, param, value):\n        # current_app should be available in parameter callbacks\n        return bool(current_app)\n\n    @app.cli.command()\n    @click.argument(\"value\", callback=_param_cb)\n    def check(value):\n        app = click.get_current_context().obj.load_app()\n        # the loaded app should be the same as current_app\n        same_app = current_app._get_current_object() is app\n        return same_app, value\n\n    cli = FlaskGroup(create_app=lambda: app)\n    result = runner.invoke(cli, [\"check\", \"x\"], standalone_mode=False)\n    assert result.return_value == (True, True)",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "runner": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "runner"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "runner": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_app_cli_has_app_context` in tests\\test_cli.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function test_app_cli_has_app_context in tests\\test_cli.py",
        "matched template: execute a shell command (sim=0.21)"
      ]
    },
    {
      "name": "test_with_appcontext",
      "description": "execute a shell command. Function `test_with_appcontext`.",
      "predicted_filename": "tests\\test_cli.py",
      "predicted_code_snippet": "def test_with_appcontext(runner):\n    @click.command()\n    @with_appcontext\n    def testcmd():\n        click.echo(current_app.name)\n\n    obj = ScriptInfo(create_app=lambda: Flask(\"testapp\"))\n\n    result = runner.invoke(testcmd, obj=obj)\n    assert result.exit_code == 0\n    assert result.output == \"testapp\\n\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "runner": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "runner"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "runner": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_with_appcontext` in tests\\test_cli.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function test_with_appcontext in tests\\test_cli.py",
        "matched template: execute a shell command (sim=0.23)"
      ]
    },
    {
      "name": "test_appgroup_app_context",
      "description": "execute a shell command. Function `test_appgroup_app_context`.",
      "predicted_filename": "tests\\test_cli.py",
      "predicted_code_snippet": "def test_appgroup_app_context(runner):\n    @click.group(cls=AppGroup)\n    def cli():\n        pass\n\n    @cli.command()\n    def test():\n        click.echo(current_app.name)\n\n    @cli.group()\n    def subgroup():\n        pass\n\n    @subgroup.command()\n    def test2():\n        click.echo(current_app.name)\n\n    obj = ScriptInfo(create_app=lambda: Flask(\"testappgroup\"))\n\n    result = runner.invoke(cli, [\"test\"], obj=obj)\n    assert result.exit_code == 0\n    assert result.output == \"testappgroup\\n\"\n\n    result = runner.invoke(cli, [\"subgroup\", \"test2\"], obj=obj)\n    assert result.exit_code == 0\n    assert result.output == \"testappgroup\\n\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "runner": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "runner"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "runner": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_appgroup_app_context` in tests\\test_cli.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function test_appgroup_app_context in tests\\test_cli.py",
        "matched template: execute a shell command (sim=0.24)"
      ]
    },
    {
      "name": "test_flaskgroup_app_context",
      "description": "execute a shell command. Function `test_flaskgroup_app_context`.",
      "predicted_filename": "tests\\test_cli.py",
      "predicted_code_snippet": "def test_flaskgroup_app_context(runner):\n    def create_app():\n        return Flask(\"flaskgroup\")\n\n    @click.group(cls=FlaskGroup, create_app=create_app)\n    def cli(**params):\n        pass\n\n    @cli.command()\n    def test():\n        click.echo(current_app.name)\n\n    result = runner.invoke(cli, [\"test\"])\n    assert result.exit_code == 0\n    assert result.output == \"flaskgroup\\n\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "runner": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "runner"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "runner": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_flaskgroup_app_context` in tests\\test_cli.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function test_flaskgroup_app_context in tests\\test_cli.py",
        "matched template: execute a shell command (sim=0.22)"
      ]
    },
    {
      "name": "test_flaskgroup_debug",
      "description": "execute a shell command. Function `test_flaskgroup_debug`.",
      "predicted_filename": "tests\\test_cli.py",
      "predicted_code_snippet": "def test_flaskgroup_debug(runner, set_debug_flag):\n    def create_app():\n        app = Flask(\"flaskgroup\")\n        app.debug = True\n        return app\n\n    @click.group(cls=FlaskGroup, create_app=create_app, set_debug_flag=set_debug_flag)\n    def cli(**params):\n        pass\n\n    @cli.command()\n    def test():\n        click.echo(str(current_app.debug))\n\n    result = runner.invoke(cli, [\"test\"])\n    assert result.exit_code == 0\n    assert result.output == f\"{not set_debug_flag}\\n\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "runner": {
            "type": "string",
            "required": true
          },
          "set_debug_flag": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "runner",
          "set_debug_flag"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "runner": "string",
          "set_debug_flag": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_flaskgroup_debug` in tests\\test_cli.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function test_flaskgroup_debug in tests\\test_cli.py",
        "matched template: execute a shell command (sim=0.23)"
      ]
    },
    {
      "name": "test_flaskgroup_nested",
      "description": "execute a shell command. Function `test_flaskgroup_nested`.",
      "predicted_filename": "tests\\test_cli.py",
      "predicted_code_snippet": "def test_flaskgroup_nested(app, runner):\n    cli = click.Group(\"cli\")\n    flask_group = FlaskGroup(name=\"flask\", create_app=lambda: app)\n    cli.add_command(flask_group)\n\n    @flask_group.command()\n    def show():\n        click.echo(current_app.name)\n\n    result = runner.invoke(cli, [\"flask\", \"show\"])\n    assert result.output == \"flask_test\\n\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "runner": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "runner"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "runner": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_flaskgroup_nested` in tests\\test_cli.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function test_flaskgroup_nested in tests\\test_cli.py",
        "matched template: execute a shell command (sim=0.21)"
      ]
    },
    {
      "name": "test_no_command_echo_loading_error",
      "description": "execute a shell command. Function `test_no_command_echo_loading_error`.",
      "predicted_filename": "tests\\test_cli.py",
      "predicted_code_snippet": "def test_no_command_echo_loading_error():\n    from flask.cli import cli\n\n    try:\n        runner = CliRunner(mix_stderr=False)\n    except (DeprecationWarning, TypeError):\n        # Click >= 8.2\n        runner = CliRunner()\n\n    result = runner.invoke(cli, [\"missing\"])\n    assert result.exit_code == 2\n    assert \"FLASK_APP\" in result.stderr\n    assert \"Usage:\" in result.stderr",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_no_command_echo_loading_error` in tests\\test_cli.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function test_no_command_echo_loading_error in tests\\test_cli.py",
        "matched template: execute a shell command (sim=0.26)"
      ]
    },
    {
      "name": "test_help_echo_loading_error",
      "description": "execute a shell command. Function `test_help_echo_loading_error`.",
      "predicted_filename": "tests\\test_cli.py",
      "predicted_code_snippet": "def test_help_echo_loading_error():\n    from flask.cli import cli\n\n    try:\n        runner = CliRunner(mix_stderr=False)\n    except (DeprecationWarning, TypeError):\n        # Click >= 8.2\n        runner = CliRunner()\n\n    result = runner.invoke(cli, [\"--help\"])\n    assert result.exit_code == 0\n    assert \"FLASK_APP\" in result.stderr\n    assert \"Usage:\" in result.stdout",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_help_echo_loading_error` in tests\\test_cli.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function test_help_echo_loading_error in tests\\test_cli.py",
        "matched template: execute a shell command (sim=0.22)"
      ]
    },
    {
      "name": "test_help_echo_exception",
      "description": "execute a shell command. Function `test_help_echo_exception`.",
      "predicted_filename": "tests\\test_cli.py",
      "predicted_code_snippet": "def test_help_echo_exception():\n    def create_app():\n        raise Exception(\"oh no\")\n\n    cli = FlaskGroup(create_app=create_app)\n\n    try:\n        runner = CliRunner(mix_stderr=False)\n    except (DeprecationWarning, TypeError):\n        # Click >= 8.2\n        runner = CliRunner()\n\n    result = runner.invoke(cli, [\"--help\"])\n    assert result.exit_code == 0\n    assert \"Exception: oh no\" in result.stderr\n    assert \"Usage:\" in result.stdout",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_help_echo_exception` in tests\\test_cli.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function test_help_echo_exception in tests\\test_cli.py",
        "matched template: execute a shell command (sim=0.22)"
      ]
    },
    {
      "name": "dotenv_not_available",
      "description": "execute a shell command. Function `dotenv_not_available`.",
      "predicted_filename": "tests\\test_cli.py",
      "predicted_code_snippet": "def dotenv_not_available():\n    try:\n        import dotenv  # noqa: F401\n    except ImportError:\n        return True\n\n    return False",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `dotenv_not_available` in tests\\test_cli.py",
      "possible_syscalls": [],
      "confidence": 0.16,
      "evidence": [
        "function dotenv_not_available in tests\\test_cli.py",
        "matched template: execute a shell command (sim=0.11)"
      ]
    },
    {
      "name": "test_load_dotenv",
      "description": "write data to a file. Function `test_load_dotenv`.",
      "predicted_filename": "tests\\test_cli.py",
      "predicted_code_snippet": "def test_load_dotenv(monkeypatch):\n    # can't use monkeypatch.delitem since the keys don't exist yet\n    for item in (\"FOO\", \"BAR\", \"SPAM\", \"HAM\"):\n        monkeypatch._setitem.append((os.environ, item, notset))\n\n    monkeypatch.setenv(\"EGGS\", \"3\")\n    monkeypatch.chdir(test_path)\n    assert load_dotenv()\n    assert Path.cwd() == test_path\n    # .flaskenv doesn't overwrite .env\n    assert os.environ[\"FOO\"] == \"env\"\n    # set only in .flaskenv\n    assert os.environ[\"BAR\"] == \"bar\"\n    # set only in .env\n    assert os.environ[\"SPAM\"] == \"1\"\n    # set manually, files don't overwrite\n    assert os.environ[\"EGGS\"] == \"3\"\n    # test env file encoding\n    assert os.environ[\"HAM\"] == \"\u706b\u817f\"\n    # Non existent file should not load\n    assert not load_dotenv(\"non-existent-file\", load_defaults=False)",
      "input_schema": {
        "type": "object",
        "properties": {
          "monkeypatch": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "monkeypatch"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "monkeypatch": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_load_dotenv` in tests\\test_cli.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function test_load_dotenv in tests\\test_cli.py",
        "matched template: write data to a file (sim=0.12)"
      ]
    },
    {
      "name": "test_dotenv_path",
      "description": "execute a shell command. Function `test_dotenv_path`.",
      "predicted_filename": "tests\\test_cli.py",
      "predicted_code_snippet": "def test_dotenv_path(monkeypatch):\n    for item in (\"FOO\", \"BAR\", \"EGGS\"):\n        monkeypatch._setitem.append((os.environ, item, notset))\n\n    load_dotenv(test_path / \".flaskenv\")\n    assert Path.cwd() == cwd\n    assert \"FOO\" in os.environ",
      "input_schema": {
        "type": "object",
        "properties": {
          "monkeypatch": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "monkeypatch"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "monkeypatch": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_dotenv_path` in tests\\test_cli.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function test_dotenv_path in tests\\test_cli.py",
        "matched template: execute a shell command (sim=0.16)"
      ]
    },
    {
      "name": "test_dotenv_optional",
      "description": "execute a shell command. Function `test_dotenv_optional`.",
      "predicted_filename": "tests\\test_cli.py",
      "predicted_code_snippet": "def test_dotenv_optional(monkeypatch):\n    monkeypatch.setitem(sys.modules, \"dotenv\", None)\n    monkeypatch.chdir(test_path)\n    load_dotenv()\n    assert \"FOO\" not in os.environ",
      "input_schema": {
        "type": "object",
        "properties": {
          "monkeypatch": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "monkeypatch"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "monkeypatch": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_dotenv_optional` in tests\\test_cli.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function test_dotenv_optional in tests\\test_cli.py",
        "matched template: execute a shell command (sim=0.15)"
      ]
    },
    {
      "name": "test_disable_dotenv_from_env",
      "description": "execute a shell command. Function `test_disable_dotenv_from_env`.",
      "predicted_filename": "tests\\test_cli.py",
      "predicted_code_snippet": "def test_disable_dotenv_from_env(monkeypatch, runner):\n    monkeypatch.chdir(test_path)\n    monkeypatch.setitem(os.environ, \"FLASK_SKIP_DOTENV\", \"1\")\n    runner.invoke(FlaskGroup())\n    assert \"FOO\" not in os.environ",
      "input_schema": {
        "type": "object",
        "properties": {
          "monkeypatch": {
            "type": "string",
            "required": true
          },
          "runner": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "monkeypatch",
          "runner"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "monkeypatch": "string",
          "runner": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_disable_dotenv_from_env` in tests\\test_cli.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function test_disable_dotenv_from_env in tests\\test_cli.py",
        "matched template: execute a shell command (sim=0.15)"
      ]
    },
    {
      "name": "test_run_cert_path",
      "description": "execute a shell command. Function `test_run_cert_path`.",
      "predicted_filename": "tests\\test_cli.py",
      "predicted_code_snippet": "def test_run_cert_path():\n    # no key\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", __file__])\n\n    # no cert\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--key\", __file__])\n\n    # cert specified first\n    ctx = run_command.make_context(\"run\", [\"--cert\", __file__, \"--key\", __file__])\n    assert ctx.params[\"cert\"] == (__file__, __file__)\n\n    # key specified first\n    ctx = run_command.make_context(\"run\", [\"--key\", __file__, \"--cert\", __file__])\n    assert ctx.params[\"cert\"] == (__file__, __file__)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_run_cert_path` in tests\\test_cli.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_run_cert_path in tests\\test_cli.py",
        "matched template: execute a shell command (sim=0.17)"
      ]
    },
    {
      "name": "test_run_cert_adhoc",
      "description": "compute cryptographic hash of input data. Function `test_run_cert_adhoc`.",
      "predicted_filename": "tests\\test_cli.py",
      "predicted_code_snippet": "def test_run_cert_adhoc(monkeypatch):\n    monkeypatch.setitem(sys.modules, \"cryptography\", None)\n\n    # cryptography not installed\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"adhoc\"])\n\n    # cryptography installed\n    monkeypatch.setitem(sys.modules, \"cryptography\", types.ModuleType(\"cryptography\"))\n    ctx = run_command.make_context(\"run\", [\"--cert\", \"adhoc\"])\n    assert ctx.params[\"cert\"] == \"adhoc\"\n\n    # no key with adhoc\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"adhoc\", \"--key\", __file__])",
      "input_schema": {
        "type": "object",
        "properties": {
          "monkeypatch": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "monkeypatch"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "monkeypatch": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_run_cert_adhoc` in tests\\test_cli.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function test_run_cert_adhoc in tests\\test_cli.py",
        "matched template: compute cryptographic hash of input data (sim=0.20)"
      ]
    },
    {
      "name": "test_run_cert_import",
      "description": "compute cryptographic hash of input data. Function `test_run_cert_import`.",
      "predicted_filename": "tests\\test_cli.py",
      "predicted_code_snippet": "def test_run_cert_import(monkeypatch):\n    monkeypatch.setitem(sys.modules, \"not_here\", None)\n\n    # ImportError\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"not_here\"])\n\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"flask\"])\n\n    # SSLContext\n    ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n\n    monkeypatch.setitem(sys.modules, \"ssl_context\", ssl_context)\n    ctx = run_command.make_context(\"run\", [\"--cert\", \"ssl_context\"])\n    assert ctx.params[\"cert\"] is ssl_context\n\n    # no --key with SSLContext\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"ssl_context\", \"--key\", __file__])",
      "input_schema": {
        "type": "object",
        "properties": {
          "monkeypatch": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "monkeypatch"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "monkeypatch": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_run_cert_import` in tests\\test_cli.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function test_run_cert_import in tests\\test_cli.py",
        "matched template: compute cryptographic hash of input data (sim=0.13)"
      ]
    },
    {
      "name": "test_run_cert_no_ssl",
      "description": "compute cryptographic hash of input data. Function `test_run_cert_no_ssl`.",
      "predicted_filename": "tests\\test_cli.py",
      "predicted_code_snippet": "def test_run_cert_no_ssl(monkeypatch):\n    monkeypatch.setitem(sys.modules, \"ssl\", None)\n\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"not_here\"])",
      "input_schema": {
        "type": "object",
        "properties": {
          "monkeypatch": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "monkeypatch"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "monkeypatch": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_run_cert_no_ssl` in tests\\test_cli.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function test_run_cert_no_ssl in tests\\test_cli.py",
        "matched template: compute cryptographic hash of input data (sim=0.16)"
      ]
    },
    {
      "name": "test_cli_blueprints",
      "description": "execute a shell command. Function `test_cli_blueprints`.",
      "predicted_filename": "tests\\test_cli.py",
      "predicted_code_snippet": "def test_cli_blueprints(app):\n    \"\"\"Test blueprint commands register correctly to the application\"\"\"\n    custom = Blueprint(\"custom\", __name__, cli_group=\"customized\")\n    nested = Blueprint(\"nested\", __name__)\n    merged = Blueprint(\"merged\", __name__, cli_group=None)\n    late = Blueprint(\"late\", __name__)\n\n    @custom.cli.command(\"custom\")\n    def custom_command():\n        click.echo(\"custom_result\")\n\n    @nested.cli.command(\"nested\")\n    def nested_command():\n        click.echo(\"nested_result\")\n\n    @merged.cli.command(\"merged\")\n    def merged_command():\n        click.echo(\"merged_result\")\n\n    @late.cli.command(\"late\")\n    def late_command():\n        click.echo(\"late_result\")\n\n    app.register_blueprint(custom)\n    app.register_blueprint(nested)\n    app.register_blueprint(merged)\n    app.register_blueprint(late, cli_group=\"late_registration\")\n\n    app_runner = app.test_cli_runner()\n\n    result = app_runner.invoke(args=[\"customized\", \"custom\"])\n    assert \"custom_result\" in result.output\n\n    result = app_runner.invoke(args=[\"nested\", \"nested\"])\n    assert \"nested_result\" in result.output\n\n    result = app_runner.invoke(args=[\"merged\"])\n    assert \"merged_result\" in result.output\n\n    result = app_runner.invoke(args=[\"late_registration\", \"late\"])\n    assert \"late_result\" in result.output",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_cli_blueprints` in tests\\test_cli.py",
      "possible_syscalls": [],
      "confidence": 0.25,
      "evidence": [
        "function test_cli_blueprints in tests\\test_cli.py",
        "matched template: execute a shell command (sim=0.30)"
      ]
    },
    {
      "name": "test_cli_empty",
      "description": "execute a shell command. Function `test_cli_empty`.",
      "predicted_filename": "tests\\test_cli.py",
      "predicted_code_snippet": "def test_cli_empty(app):\n    \"\"\"If a Blueprint's CLI group is empty, do not register it.\"\"\"\n    bp = Blueprint(\"blue\", __name__, cli_group=\"blue\")\n    app.register_blueprint(bp)\n\n    result = app.test_cli_runner().invoke(args=[\"blue\", \"--help\"])\n    assert result.exit_code == 2, f\"Unexpected success:\\n\\n{result.output}\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_cli_empty` in tests\\test_cli.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function test_cli_empty in tests\\test_cli.py",
        "matched template: execute a shell command (sim=0.21)"
      ]
    },
    {
      "name": "test_run_exclude_patterns",
      "description": "validate and sanitize user input. Function `test_run_exclude_patterns`.",
      "predicted_filename": "tests\\test_cli.py",
      "predicted_code_snippet": "def test_run_exclude_patterns():\n    ctx = run_command.make_context(\"run\", [\"--exclude-patterns\", __file__])\n    assert ctx.params[\"exclude_patterns\"] == [__file__]",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_run_exclude_patterns` in tests\\test_cli.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function test_run_exclude_patterns in tests\\test_cli.py",
        "matched template: validate and sanitize user input (sim=0.14)"
      ]
    },
    {
      "name": "common_object_test",
      "description": "parse JSON input and validate fields. Function `common_object_test`.",
      "predicted_filename": "tests\\test_config.py",
      "predicted_code_snippet": "def common_object_test(app):\n    assert app.secret_key == \"config\"\n    assert app.config[\"TEST_KEY\"] == \"foo\"\n    assert \"TestConfig\" not in app.config",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `common_object_test` in tests\\test_config.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function common_object_test in tests\\test_config.py",
        "matched template: parse JSON input and validate fields (sim=0.13)"
      ]
    },
    {
      "name": "test_config_from_pyfile",
      "description": "write data to a file. Function `test_config_from_pyfile`.",
      "predicted_filename": "tests\\test_config.py",
      "predicted_code_snippet": "def test_config_from_pyfile():\n    app = flask.Flask(__name__)\n    app.config.from_pyfile(f\"{__file__.rsplit('.', 1)[0]}.py\")\n    common_object_test(app)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_config_from_pyfile` in tests\\test_config.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_config_from_pyfile in tests\\test_config.py",
        "matched template: write data to a file (sim=0.20)"
      ]
    },
    {
      "name": "test_config_from_object",
      "description": "parse JSON input and validate fields. Function `test_config_from_object`.",
      "predicted_filename": "tests\\test_config.py",
      "predicted_code_snippet": "def test_config_from_object():\n    app = flask.Flask(__name__)\n    app.config.from_object(__name__)\n    common_object_test(app)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_config_from_object` in tests\\test_config.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function test_config_from_object in tests\\test_config.py",
        "matched template: parse JSON input and validate fields (sim=0.12)"
      ]
    },
    {
      "name": "test_config_from_file_json",
      "description": "write data to a file. Function `test_config_from_file_json`.",
      "predicted_filename": "tests\\test_config.py",
      "predicted_code_snippet": "def test_config_from_file_json():\n    app = flask.Flask(__name__)\n    current_dir = os.path.dirname(os.path.abspath(__file__))\n    app.config.from_file(os.path.join(current_dir, \"static\", \"config.json\"), json.load)\n    common_object_test(app)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_config_from_file_json` in tests\\test_config.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_config_from_file_json in tests\\test_config.py",
        "matched template: write data to a file (sim=0.20)"
      ]
    },
    {
      "name": "test_config_from_file_toml",
      "description": "write data to a file. Function `test_config_from_file_toml`.",
      "predicted_filename": "tests\\test_config.py",
      "predicted_code_snippet": "def test_config_from_file_toml():\n    tomllib = pytest.importorskip(\"tomllib\", reason=\"tomllib added in 3.11\")\n    app = flask.Flask(__name__)\n    current_dir = os.path.dirname(os.path.abspath(__file__))\n    app.config.from_file(\n        os.path.join(current_dir, \"static\", \"config.toml\"), tomllib.load, text=False\n    )\n    common_object_test(app)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_config_from_file_toml` in tests\\test_config.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_config_from_file_toml in tests\\test_config.py",
        "matched template: write data to a file (sim=0.18)"
      ]
    },
    {
      "name": "test_from_prefixed_env",
      "description": "parse JSON input and validate fields. Function `test_from_prefixed_env`.",
      "predicted_filename": "tests\\test_config.py",
      "predicted_code_snippet": "def test_from_prefixed_env(monkeypatch):\n    monkeypatch.setenv(\"FLASK_STRING\", \"value\")\n    monkeypatch.setenv(\"FLASK_BOOL\", \"true\")\n    monkeypatch.setenv(\"FLASK_INT\", \"1\")\n    monkeypatch.setenv(\"FLASK_FLOAT\", \"1.2\")\n    monkeypatch.setenv(\"FLASK_LIST\", \"[1, 2]\")\n    monkeypatch.setenv(\"FLASK_DICT\", '{\"k\": \"v\"}')\n    monkeypatch.setenv(\"NOT_FLASK_OTHER\", \"other\")\n\n    app = flask.Flask(__name__)\n    app.config.from_prefixed_env()\n\n    assert app.config[\"STRING\"] == \"value\"\n    assert app.config[\"BOOL\"] is True\n    assert app.config[\"INT\"] == 1\n    assert app.config[\"FLOAT\"] == 1.2\n    assert app.config[\"LIST\"] == [1, 2]\n    assert app.config[\"DICT\"] == {\"k\": \"v\"}\n    assert \"OTHER\" not in app.config",
      "input_schema": {
        "type": "object",
        "properties": {
          "monkeypatch": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "monkeypatch"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "monkeypatch": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_from_prefixed_env` in tests\\test_config.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function test_from_prefixed_env in tests\\test_config.py",
        "matched template: parse JSON input and validate fields (sim=0.13)"
      ]
    },
    {
      "name": "test_from_prefixed_env_custom_prefix",
      "description": "parse JSON input and validate fields. Function `test_from_prefixed_env_custom_prefix`.",
      "predicted_filename": "tests\\test_config.py",
      "predicted_code_snippet": "def test_from_prefixed_env_custom_prefix(monkeypatch):\n    monkeypatch.setenv(\"FLASK_A\", \"a\")\n    monkeypatch.setenv(\"NOT_FLASK_A\", \"b\")\n\n    app = flask.Flask(__name__)\n    app.config.from_prefixed_env(\"NOT_FLASK\")\n\n    assert app.config[\"A\"] == \"b\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "monkeypatch": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "monkeypatch"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "monkeypatch": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_from_prefixed_env_custom_prefix` in tests\\test_config.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function test_from_prefixed_env_custom_prefix in tests\\test_config.py",
        "matched template: parse JSON input and validate fields (sim=0.12)"
      ]
    },
    {
      "name": "test_from_prefixed_env_nested",
      "description": "parse JSON input and validate fields. Function `test_from_prefixed_env_nested`.",
      "predicted_filename": "tests\\test_config.py",
      "predicted_code_snippet": "def test_from_prefixed_env_nested(monkeypatch):\n    monkeypatch.setenv(\"FLASK_EXIST__ok\", \"other\")\n    monkeypatch.setenv(\"FLASK_EXIST__inner__ik\", \"2\")\n    monkeypatch.setenv(\"FLASK_EXIST__new__more\", '{\"k\": false}')\n    monkeypatch.setenv(\"FLASK_NEW__K\", \"v\")\n\n    app = flask.Flask(__name__)\n    app.config[\"EXIST\"] = {\"ok\": \"value\", \"flag\": True, \"inner\": {\"ik\": 1}}\n    app.config.from_prefixed_env()\n\n    if os.name != \"nt\":\n        assert app.config[\"EXIST\"] == {\n            \"ok\": \"other\",\n            \"flag\": True,\n            \"inner\": {\"ik\": 2},\n            \"new\": {\"more\": {\"k\": False}},\n        }\n    else:\n        # Windows env var keys are always uppercase.\n        assert app.config[\"EXIST\"] == {\n            \"ok\": \"value\",\n            \"OK\": \"other\",\n            \"flag\": True,\n            \"inner\": {\"ik\": 1},\n            \"INNER\": {\"IK\": 2},\n            \"NEW\": {\"MORE\": {\"k\": False}},\n        }\n\n    assert app.config[\"NEW\"] == {\"K\": \"v\"}",
      "input_schema": {
        "type": "object",
        "properties": {
          "monkeypatch": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "monkeypatch"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "monkeypatch": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_from_prefixed_env_nested` in tests\\test_config.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function test_from_prefixed_env_nested in tests\\test_config.py",
        "matched template: parse JSON input and validate fields (sim=0.14)"
      ]
    },
    {
      "name": "test_config_from_mapping",
      "description": "compute cryptographic hash of input data. Function `test_config_from_mapping`.",
      "predicted_filename": "tests\\test_config.py",
      "predicted_code_snippet": "def test_config_from_mapping():\n    app = flask.Flask(__name__)\n    app.config.from_mapping({\"SECRET_KEY\": \"config\", \"TEST_KEY\": \"foo\"})\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    app.config.from_mapping([(\"SECRET_KEY\", \"config\"), (\"TEST_KEY\", \"foo\")])\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    app.config.from_mapping(SECRET_KEY=\"config\", TEST_KEY=\"foo\")\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    app.config.from_mapping(SECRET_KEY=\"config\", TEST_KEY=\"foo\", skip_key=\"skip\")\n    common_object_test(app)\n\n    app = flask.Flask(__name__)\n    with pytest.raises(TypeError):\n        app.config.from_mapping({}, {})",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_config_from_mapping` in tests\\test_config.py",
      "possible_syscalls": [],
      "confidence": 0.16,
      "evidence": [
        "function test_config_from_mapping in tests\\test_config.py",
        "matched template: compute cryptographic hash of input data (sim=0.09)"
      ]
    },
    {
      "name": "test_config_from_class",
      "description": "serialize object to JSON. Function `test_config_from_class`.",
      "predicted_filename": "tests\\test_config.py",
      "predicted_code_snippet": "def test_config_from_class():\n    class Base:\n        TEST_KEY = \"foo\"\n\n    class Test(Base):\n        SECRET_KEY = \"config\"\n\n    app = flask.Flask(__name__)\n    app.config.from_object(Test)\n    common_object_test(app)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_config_from_class` in tests\\test_config.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function test_config_from_class in tests\\test_config.py",
        "matched template: serialize object to JSON (sim=0.13)"
      ]
    },
    {
      "name": "test_config_from_envvar",
      "description": "write data to a file. Function `test_config_from_envvar`.",
      "predicted_filename": "tests\\test_config.py",
      "predicted_code_snippet": "def test_config_from_envvar(monkeypatch):\n    monkeypatch.setattr(\"os.environ\", {})\n    app = flask.Flask(__name__)\n\n    with pytest.raises(RuntimeError) as e:\n        app.config.from_envvar(\"FOO_SETTINGS\")\n\n    assert \"'FOO_SETTINGS' is not set\" in str(e.value)\n    assert not app.config.from_envvar(\"FOO_SETTINGS\", silent=True)\n\n    monkeypatch.setattr(\n        \"os.environ\", {\"FOO_SETTINGS\": f\"{__file__.rsplit('.', 1)[0]}.py\"}\n    )\n    assert app.config.from_envvar(\"FOO_SETTINGS\")\n    common_object_test(app)",
      "input_schema": {
        "type": "object",
        "properties": {
          "monkeypatch": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "monkeypatch"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "monkeypatch": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_config_from_envvar` in tests\\test_config.py",
      "possible_syscalls": [],
      "confidence": 0.16,
      "evidence": [
        "function test_config_from_envvar in tests\\test_config.py",
        "matched template: write data to a file (sim=0.10)"
      ]
    },
    {
      "name": "test_config_from_envvar_missing",
      "description": "write data to a file. Function `test_config_from_envvar_missing`.",
      "predicted_filename": "tests\\test_config.py",
      "predicted_code_snippet": "def test_config_from_envvar_missing(monkeypatch):\n    monkeypatch.setattr(\"os.environ\", {\"FOO_SETTINGS\": \"missing.cfg\"})\n    app = flask.Flask(__name__)\n    with pytest.raises(IOError) as e:\n        app.config.from_envvar(\"FOO_SETTINGS\")\n    msg = str(e.value)\n    assert msg.startswith(\n        \"[Errno 2] Unable to load configuration file (No such file or directory):\"\n    )\n    assert msg.endswith(\"missing.cfg'\")\n    assert not app.config.from_envvar(\"FOO_SETTINGS\", silent=True)",
      "input_schema": {
        "type": "object",
        "properties": {
          "monkeypatch": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "monkeypatch"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "monkeypatch": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_config_from_envvar_missing` in tests\\test_config.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function test_config_from_envvar_missing in tests\\test_config.py",
        "matched template: write data to a file (sim=0.12)"
      ]
    },
    {
      "name": "test_config_missing",
      "description": "write data to a file. Function `test_config_missing`.",
      "predicted_filename": "tests\\test_config.py",
      "predicted_code_snippet": "def test_config_missing():\n    app = flask.Flask(__name__)\n    with pytest.raises(IOError) as e:\n        app.config.from_pyfile(\"missing.cfg\")\n    msg = str(e.value)\n    assert msg.startswith(\n        \"[Errno 2] Unable to load configuration file (No such file or directory):\"\n    )\n    assert msg.endswith(\"missing.cfg'\")\n    assert not app.config.from_pyfile(\"missing.cfg\", silent=True)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_config_missing` in tests\\test_config.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function test_config_missing in tests\\test_config.py",
        "matched template: write data to a file (sim=0.15)"
      ]
    },
    {
      "name": "test_config_missing_file",
      "description": "write data to a file. Function `test_config_missing_file`.",
      "predicted_filename": "tests\\test_config.py",
      "predicted_code_snippet": "def test_config_missing_file():\n    app = flask.Flask(__name__)\n    with pytest.raises(IOError) as e:\n        app.config.from_file(\"missing.json\", load=json.load)\n    msg = str(e.value)\n    assert msg.startswith(\n        \"[Errno 2] Unable to load configuration file (No such file or directory):\"\n    )\n    assert msg.endswith(\"missing.json'\")\n    assert not app.config.from_file(\"missing.json\", load=json.load, silent=True)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_config_missing_file` in tests\\test_config.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_config_missing_file in tests\\test_config.py",
        "matched template: write data to a file (sim=0.18)"
      ]
    },
    {
      "name": "test_custom_config_class",
      "description": "write data to a file. Function `test_custom_config_class`.",
      "predicted_filename": "tests\\test_config.py",
      "predicted_code_snippet": "def test_custom_config_class():\n    class Config(flask.Config):\n        pass\n\n    class Flask(flask.Flask):\n        config_class = Config\n\n    app = Flask(__name__)\n    assert isinstance(app.config, Config)\n    app.config.from_object(__name__)\n    common_object_test(app)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_custom_config_class` in tests\\test_config.py",
      "possible_syscalls": [],
      "confidence": 0.16,
      "evidence": [
        "function test_custom_config_class in tests\\test_config.py",
        "matched template: write data to a file (sim=0.09)"
      ]
    },
    {
      "name": "test_session_lifetime",
      "description": "authenticate a user and return a token. Function `test_session_lifetime`.",
      "predicted_filename": "tests\\test_config.py",
      "predicted_code_snippet": "def test_session_lifetime():\n    app = flask.Flask(__name__)\n    app.config[\"PERMANENT_SESSION_LIFETIME\"] = 42\n    assert app.permanent_session_lifetime.seconds == 42",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_session_lifetime` in tests\\test_config.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function test_session_lifetime in tests\\test_config.py",
        "matched template: authenticate a user and return a token (sim=0.13)"
      ]
    },
    {
      "name": "test_get_namespace",
      "description": "parse JSON input and validate fields. Function `test_get_namespace`.",
      "predicted_filename": "tests\\test_config.py",
      "predicted_code_snippet": "def test_get_namespace():\n    app = flask.Flask(__name__)\n    app.config[\"FOO_OPTION_1\"] = \"foo option 1\"\n    app.config[\"FOO_OPTION_2\"] = \"foo option 2\"\n    app.config[\"BAR_STUFF_1\"] = \"bar stuff 1\"\n    app.config[\"BAR_STUFF_2\"] = \"bar stuff 2\"\n    foo_options = app.config.get_namespace(\"FOO_\")\n    assert 2 == len(foo_options)\n    assert \"foo option 1\" == foo_options[\"option_1\"]\n    assert \"foo option 2\" == foo_options[\"option_2\"]\n    bar_options = app.config.get_namespace(\"BAR_\", lowercase=False)\n    assert 2 == len(bar_options)\n    assert \"bar stuff 1\" == bar_options[\"STUFF_1\"]\n    assert \"bar stuff 2\" == bar_options[\"STUFF_2\"]\n    foo_options = app.config.get_namespace(\"FOO_\", trim_namespace=False)\n    assert 2 == len(foo_options)\n    assert \"foo option 1\" == foo_options[\"foo_option_1\"]\n    assert \"foo option 2\" == foo_options[\"foo_option_2\"]\n    bar_options = app.config.get_namespace(\n        \"BAR_\", lowercase=False, trim_namespace=False\n    )\n    assert 2 == len(bar_options)\n    assert \"bar stuff 1\" == bar_options[\"BAR_STUFF_1\"]\n    assert \"bar stuff 2\" == bar_options[\"BAR_STUFF_2\"]",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_get_namespace` in tests\\test_config.py",
      "possible_syscalls": [],
      "confidence": 0.16,
      "evidence": [
        "function test_get_namespace in tests\\test_config.py",
        "matched template: parse JSON input and validate fields (sim=0.11)"
      ]
    },
    {
      "name": "test_from_pyfile_weird_encoding",
      "description": "write data to a file. Function `test_from_pyfile_weird_encoding`.",
      "predicted_filename": "tests\\test_config.py",
      "predicted_code_snippet": "def test_from_pyfile_weird_encoding(tmp_path, encoding):\n    f = tmp_path / \"my_config.py\"\n    f.write_text(f'# -*- coding: {encoding} -*-\\nTEST_VALUE = \"f\u00f6\u00f6\"\\n', encoding)\n    app = flask.Flask(__name__)\n    app.config.from_pyfile(os.fspath(f))\n    value = app.config[\"TEST_VALUE\"]\n    assert value == \"f\u00f6\u00f6\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "tmp_path": {
            "type": "string",
            "required": true
          },
          "encoding": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "tmp_path",
          "encoding"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "tmp_path": "string",
          "encoding": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_from_pyfile_weird_encoding` in tests\\test_config.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function test_from_pyfile_weird_encoding in tests\\test_config.py",
        "matched template: write data to a file (sim=0.27)"
      ]
    },
    {
      "name": "test_custom_converters",
      "description": "handle a HTTP route request and return response. Function `test_custom_converters`.",
      "predicted_filename": "tests\\test_converters.py",
      "predicted_code_snippet": "def test_custom_converters(app, client):\n    class ListConverter(BaseConverter):\n        def to_python(self, value):\n            return value.split(\",\")\n\n        def to_url(self, value):\n            base_to_url = super().to_url\n            return \",\".join(base_to_url(x) for x in value)\n\n    app.url_map.converters[\"list\"] = ListConverter\n\n    @app.route(\"/<list:args>\")\n    def index(args):\n        return \"|\".join(args)\n\n    assert client.get(\"/1,2,3\").data == b\"1|2|3\"\n\n    with app.test_request_context():\n        assert url_for(\"index\", args=[4, 5, 6]) == \"/4,5,6\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_custom_converters` in tests\\test_converters.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function test_custom_converters in tests\\test_converters.py",
        "matched template: handle a HTTP route request and return response (sim=0.25)"
      ]
    },
    {
      "name": "test_context_available",
      "description": "handle a HTTP route request and return response. Function `test_context_available`.",
      "predicted_filename": "tests\\test_converters.py",
      "predicted_code_snippet": "def test_context_available(app, client):\n    class ContextConverter(BaseConverter):\n        def to_python(self, value):\n            assert request is not None\n            assert session is not None\n            return value\n\n    app.url_map.converters[\"ctx\"] = ContextConverter\n\n    @app.get(\"/<ctx:name>\")\n    def index(name):\n        return name\n\n    assert client.get(\"/admin\").data == b\"admin\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_context_available` in tests\\test_converters.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function test_context_available in tests\\test_converters.py",
        "matched template: handle a HTTP route request and return response (sim=0.22)"
      ]
    },
    {
      "name": "test_redirect_no_app",
      "description": "handle a HTTP route request and return response. Function `test_redirect_no_app`.",
      "predicted_filename": "tests\\test_helpers.py",
      "predicted_code_snippet": "def test_redirect_no_app():\n    response = flask.redirect(\"https://localhost\", 307)\n    assert response.location == \"https://localhost\"\n    assert response.status_code == 307",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_redirect_no_app` in tests\\test_helpers.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function test_redirect_no_app in tests\\test_helpers.py",
        "matched template: handle a HTTP route request and return response (sim=0.26)"
      ]
    },
    {
      "name": "test_redirect_with_app",
      "description": "handle a HTTP route request and return response. Function `test_redirect_with_app`.",
      "predicted_filename": "tests\\test_helpers.py",
      "predicted_code_snippet": "def test_redirect_with_app(app):\n    def redirect(location, code=302):\n        raise ValueError\n\n    app.redirect = redirect\n\n    with app.app_context(), pytest.raises(ValueError):\n        flask.redirect(\"other\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_redirect_with_app` in tests\\test_helpers.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_redirect_with_app in tests\\test_helpers.py",
        "matched template: handle a HTTP route request and return response (sim=0.19)"
      ]
    },
    {
      "name": "test_abort_no_app",
      "description": "validate and sanitize user input. Function `test_abort_no_app`.",
      "predicted_filename": "tests\\test_helpers.py",
      "predicted_code_snippet": "def test_abort_no_app():\n    with pytest.raises(werkzeug.exceptions.Unauthorized):\n        flask.abort(401)\n\n    with pytest.raises(LookupError):\n        flask.abort(900)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_abort_no_app` in tests\\test_helpers.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function test_abort_no_app in tests\\test_helpers.py",
        "matched template: validate and sanitize user input (sim=0.14)"
      ]
    },
    {
      "name": "test_app_aborter_class",
      "description": "validate and sanitize user input. Function `test_app_aborter_class`.",
      "predicted_filename": "tests\\test_helpers.py",
      "predicted_code_snippet": "def test_app_aborter_class():\n    class MyAborter(werkzeug.exceptions.Aborter):\n        pass\n\n    class MyFlask(flask.Flask):\n        aborter_class = MyAborter\n\n    app = MyFlask(__name__)\n    assert isinstance(app.aborter, MyAborter)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_app_aborter_class` in tests\\test_helpers.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function test_app_aborter_class in tests\\test_helpers.py",
        "matched template: validate and sanitize user input (sim=0.14)"
      ]
    },
    {
      "name": "test_abort_with_app",
      "description": "handle a HTTP route request and return response. Function `test_abort_with_app`.",
      "predicted_filename": "tests\\test_helpers.py",
      "predicted_code_snippet": "def test_abort_with_app(app):\n    class My900Error(werkzeug.exceptions.HTTPException):\n        code = 900\n\n    app.aborter.mapping[900] = My900Error\n\n    with app.app_context(), pytest.raises(My900Error):\n        flask.abort(900)",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_abort_with_app` in tests\\test_helpers.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function test_abort_with_app in tests\\test_helpers.py",
        "matched template: handle a HTTP route request and return response (sim=0.12)"
      ]
    },
    {
      "name": "test_open_resource",
      "description": "list files in a directory. Function `test_open_resource`.",
      "predicted_filename": "tests\\test_helpers.py",
      "predicted_code_snippet": "def test_open_resource(mode):\n    app = flask.Flask(__name__)\n\n    with app.open_resource(\"static/index.html\", mode) as f:\n        assert \"<h1>Hello World!</h1>\" in str(f.read())",
      "input_schema": {
        "type": "object",
        "properties": {
          "mode": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "mode"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "mode": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_open_resource` in tests\\test_helpers.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function test_open_resource in tests\\test_helpers.py",
        "matched template: list files in a directory (sim=0.15)"
      ]
    },
    {
      "name": "test_open_resource_exceptions",
      "description": "list files in a directory. Function `test_open_resource_exceptions`.",
      "predicted_filename": "tests\\test_helpers.py",
      "predicted_code_snippet": "def test_open_resource_exceptions(mode):\n    app = flask.Flask(__name__)\n\n    with pytest.raises(ValueError):\n        app.open_resource(\"static/index.html\", mode)",
      "input_schema": {
        "type": "object",
        "properties": {
          "mode": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "mode"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "mode": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_open_resource_exceptions` in tests\\test_helpers.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function test_open_resource_exceptions in tests\\test_helpers.py",
        "matched template: list files in a directory (sim=0.13)"
      ]
    },
    {
      "name": "test_open_resource_with_encoding",
      "description": "write data to a file. Function `test_open_resource_with_encoding`.",
      "predicted_filename": "tests\\test_helpers.py",
      "predicted_code_snippet": "def test_open_resource_with_encoding(tmp_path, encoding):\n    app = flask.Flask(__name__, root_path=os.fspath(tmp_path))\n    (tmp_path / \"test\").write_text(\"test\", encoding=encoding)\n\n    with app.open_resource(\"test\", mode=\"rt\", encoding=encoding) as f:\n        assert f.read() == \"test\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "tmp_path": {
            "type": "string",
            "required": true
          },
          "encoding": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "tmp_path",
          "encoding"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "tmp_path": "string",
          "encoding": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_open_resource_with_encoding` in tests\\test_helpers.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_open_resource_with_encoding in tests\\test_helpers.py",
        "matched template: write data to a file (sim=0.17)"
      ]
    },
    {
      "name": "test_explicit_instance_paths",
      "description": "execute a shell command. Function `test_explicit_instance_paths`.",
      "predicted_filename": "tests\\test_instance_config.py",
      "predicted_code_snippet": "def test_explicit_instance_paths(modules_tmp_path):\n    with pytest.raises(ValueError, match=\".*must be absolute\"):\n        flask.Flask(__name__, instance_path=\"instance\")\n\n    app = flask.Flask(__name__, instance_path=os.fspath(modules_tmp_path))\n    assert app.instance_path == os.fspath(modules_tmp_path)",
      "input_schema": {
        "type": "object",
        "properties": {
          "modules_tmp_path": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "modules_tmp_path"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "modules_tmp_path": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_explicit_instance_paths` in tests\\test_instance_config.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function test_explicit_instance_paths in tests\\test_instance_config.py",
        "matched template: execute a shell command (sim=0.11)"
      ]
    },
    {
      "name": "test_uninstalled_module_paths",
      "description": "execute a shell command. Function `test_uninstalled_module_paths`.",
      "predicted_filename": "tests\\test_instance_config.py",
      "predicted_code_snippet": "def test_uninstalled_module_paths(modules_tmp_path, purge_module):\n    (modules_tmp_path / \"config_module_app.py\").write_text(\n        \"import os\\n\"\n        \"import flask\\n\"\n        \"here = os.path.abspath(os.path.dirname(__file__))\\n\"\n        \"app = flask.Flask(__name__)\\n\"\n    )\n    purge_module(\"config_module_app\")\n\n    from config_module_app import app\n\n    assert app.instance_path == os.fspath(modules_tmp_path / \"instance\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "modules_tmp_path": {
            "type": "string",
            "required": true
          },
          "purge_module": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "modules_tmp_path",
          "purge_module"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "modules_tmp_path": "string",
          "purge_module": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_uninstalled_module_paths` in tests\\test_instance_config.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function test_uninstalled_module_paths in tests\\test_instance_config.py",
        "matched template: execute a shell command (sim=0.11)"
      ]
    },
    {
      "name": "test_uninstalled_package_paths",
      "description": "execute a shell command. Function `test_uninstalled_package_paths`.",
      "predicted_filename": "tests\\test_instance_config.py",
      "predicted_code_snippet": "def test_uninstalled_package_paths(modules_tmp_path, purge_module):\n    app = modules_tmp_path / \"config_package_app\"\n    app.mkdir()\n    (app / \"__init__.py\").write_text(\n        \"import os\\n\"\n        \"import flask\\n\"\n        \"here = os.path.abspath(os.path.dirname(__file__))\\n\"\n        \"app = flask.Flask(__name__)\\n\"\n    )\n    purge_module(\"config_package_app\")\n\n    from config_package_app import app\n\n    assert app.instance_path == os.fspath(modules_tmp_path / \"instance\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "modules_tmp_path": {
            "type": "string",
            "required": true
          },
          "purge_module": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "modules_tmp_path",
          "purge_module"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "modules_tmp_path": "string",
          "purge_module": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_uninstalled_package_paths` in tests\\test_instance_config.py",
      "possible_syscalls": [],
      "confidence": 0.16,
      "evidence": [
        "function test_uninstalled_package_paths in tests\\test_instance_config.py",
        "matched template: execute a shell command (sim=0.10)"
      ]
    },
    {
      "name": "test_uninstalled_namespace_paths",
      "description": "list files in a directory. Function `test_uninstalled_namespace_paths`.",
      "predicted_filename": "tests\\test_instance_config.py",
      "predicted_code_snippet": "def test_uninstalled_namespace_paths(tmp_path, monkeypatch, purge_module):\n    def create_namespace(package):\n        project = tmp_path / f\"project-{package}\"\n        monkeypatch.syspath_prepend(os.fspath(project))\n        ns = project / \"namespace\" / package\n        ns.mkdir(parents=True)\n        (ns / \"__init__.py\").write_text(\"import flask\\napp = flask.Flask(__name__)\\n\")\n        return project\n\n    _ = create_namespace(\"package1\")\n    project2 = create_namespace(\"package2\")\n    purge_module(\"namespace.package2\")\n    purge_module(\"namespace\")\n\n    from namespace.package2 import app\n\n    assert app.instance_path == os.fspath(project2 / \"instance\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "tmp_path": {
            "type": "string",
            "required": true
          },
          "monkeypatch": {
            "type": "string",
            "required": true
          },
          "purge_module": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "tmp_path",
          "monkeypatch",
          "purge_module"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "tmp_path": "string",
          "monkeypatch": "string",
          "purge_module": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_uninstalled_namespace_paths` in tests\\test_instance_config.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function test_uninstalled_namespace_paths in tests\\test_instance_config.py",
        "matched template: list files in a directory (sim=0.11)"
      ]
    },
    {
      "name": "test_installed_module_paths",
      "description": "execute a shell command. Function `test_installed_module_paths`.",
      "predicted_filename": "tests\\test_instance_config.py",
      "predicted_code_snippet": "def test_installed_module_paths(\n    modules_tmp_path, modules_tmp_path_prefix, purge_module, site_packages\n):\n    (site_packages / \"site_app.py\").write_text(\n        \"import flask\\napp = flask.Flask(__name__)\\n\"\n    )\n    purge_module(\"site_app\")\n\n    from site_app import app\n\n    assert app.instance_path == os.fspath(\n        modules_tmp_path / \"var\" / \"site_app-instance\"\n    )",
      "input_schema": {
        "type": "object",
        "properties": {
          "modules_tmp_path": {
            "type": "string",
            "required": true
          },
          "modules_tmp_path_prefix": {
            "type": "string",
            "required": true
          },
          "purge_module": {
            "type": "string",
            "required": true
          },
          "site_packages": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "modules_tmp_path",
          "modules_tmp_path_prefix",
          "purge_module",
          "site_packages"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "modules_tmp_path": "string",
          "modules_tmp_path_prefix": "string",
          "purge_module": "string",
          "site_packages": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_installed_module_paths` in tests\\test_instance_config.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function test_installed_module_paths in tests\\test_instance_config.py",
        "matched template: execute a shell command (sim=0.13)"
      ]
    },
    {
      "name": "test_installed_package_paths",
      "description": "execute a shell command. Function `test_installed_package_paths`.",
      "predicted_filename": "tests\\test_instance_config.py",
      "predicted_code_snippet": "def test_installed_package_paths(\n    modules_tmp_path, modules_tmp_path_prefix, purge_module, monkeypatch\n):\n    installed_path = modules_tmp_path / \"path\"\n    installed_path.mkdir()\n    monkeypatch.syspath_prepend(installed_path)\n\n    app = installed_path / \"installed_package\"\n    app.mkdir()\n    (app / \"__init__.py\").write_text(\"import flask\\napp = flask.Flask(__name__)\\n\")\n    purge_module(\"installed_package\")\n\n    from installed_package import app\n\n    assert app.instance_path == os.fspath(\n        modules_tmp_path / \"var\" / \"installed_package-instance\"\n    )",
      "input_schema": {
        "type": "object",
        "properties": {
          "modules_tmp_path": {
            "type": "string",
            "required": true
          },
          "modules_tmp_path_prefix": {
            "type": "string",
            "required": true
          },
          "purge_module": {
            "type": "string",
            "required": true
          },
          "monkeypatch": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "modules_tmp_path",
          "modules_tmp_path_prefix",
          "purge_module",
          "monkeypatch"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "modules_tmp_path": "string",
          "modules_tmp_path_prefix": "string",
          "purge_module": "string",
          "monkeypatch": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_installed_package_paths` in tests\\test_instance_config.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function test_installed_package_paths in tests\\test_instance_config.py",
        "matched template: execute a shell command (sim=0.14)"
      ]
    },
    {
      "name": "test_prefix_package_paths",
      "description": "execute a shell command. Function `test_prefix_package_paths`.",
      "predicted_filename": "tests\\test_instance_config.py",
      "predicted_code_snippet": "def test_prefix_package_paths(\n    modules_tmp_path, modules_tmp_path_prefix, purge_module, site_packages\n):\n    app = site_packages / \"site_package\"\n    app.mkdir()\n    (app / \"__init__.py\").write_text(\"import flask\\napp = flask.Flask(__name__)\\n\")\n    purge_module(\"site_package\")\n\n    import site_package\n\n    assert site_package.app.instance_path == os.fspath(\n        modules_tmp_path / \"var\" / \"site_package-instance\"\n    )",
      "input_schema": {
        "type": "object",
        "properties": {
          "modules_tmp_path": {
            "type": "string",
            "required": true
          },
          "modules_tmp_path_prefix": {
            "type": "string",
            "required": true
          },
          "purge_module": {
            "type": "string",
            "required": true
          },
          "site_packages": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "modules_tmp_path",
          "modules_tmp_path_prefix",
          "purge_module",
          "site_packages"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "modules_tmp_path": "string",
          "modules_tmp_path_prefix": "string",
          "purge_module": "string",
          "site_packages": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_prefix_package_paths` in tests\\test_instance_config.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function test_prefix_package_paths in tests\\test_instance_config.py",
        "matched template: execute a shell command (sim=0.12)"
      ]
    },
    {
      "name": "test_bad_request_debug_message",
      "description": "parse JSON input and validate fields. Function `test_bad_request_debug_message`.",
      "predicted_filename": "tests\\test_json.py",
      "predicted_code_snippet": "def test_bad_request_debug_message(app, client, debug):\n    app.config[\"DEBUG\"] = debug\n    app.config[\"TRAP_BAD_REQUEST_ERRORS\"] = False\n\n    @app.route(\"/json\", methods=[\"POST\"])\n    def post_json():\n        flask.request.get_json()\n        return None\n\n    rv = client.post(\"/json\", data=None, content_type=\"application/json\")\n    assert rv.status_code == 400\n    contains = b\"Failed to decode JSON object\" in rv.data\n    assert contains == debug",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          },
          "debug": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client",
          "debug"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string",
          "debug": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_bad_request_debug_message` in tests\\test_json.py",
      "possible_syscalls": [],
      "confidence": 0.24,
      "evidence": [
        "function test_bad_request_debug_message in tests\\test_json.py",
        "matched template: parse JSON input and validate fields (sim=0.29)"
      ]
    },
    {
      "name": "test_json_bad_requests",
      "description": "parse JSON input and validate fields. Function `test_json_bad_requests`.",
      "predicted_filename": "tests\\test_json.py",
      "predicted_code_snippet": "def test_json_bad_requests(app, client):\n    @app.route(\"/json\", methods=[\"POST\"])\n    def return_json():\n        return flask.jsonify(foo=str(flask.request.get_json()))\n\n    rv = client.post(\"/json\", data=\"malformed\", content_type=\"application/json\")\n    assert rv.status_code == 400",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_json_bad_requests` in tests\\test_json.py",
      "possible_syscalls": [],
      "confidence": 0.25,
      "evidence": [
        "function test_json_bad_requests in tests\\test_json.py",
        "matched template: parse JSON input and validate fields (sim=0.31)"
      ]
    },
    {
      "name": "test_json_custom_mimetypes",
      "description": "parse JSON input and validate fields. Function `test_json_custom_mimetypes`.",
      "predicted_filename": "tests\\test_json.py",
      "predicted_code_snippet": "def test_json_custom_mimetypes(app, client):\n    @app.route(\"/json\", methods=[\"POST\"])\n    def return_json():\n        return flask.request.get_json()\n\n    rv = client.post(\"/json\", data='\"foo\"', content_type=\"application/x+json\")\n    assert rv.data == b\"foo\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_json_custom_mimetypes` in tests\\test_json.py",
      "possible_syscalls": [],
      "confidence": 0.26,
      "evidence": [
        "function test_json_custom_mimetypes in tests\\test_json.py",
        "matched template: parse JSON input and validate fields (sim=0.32)"
      ]
    },
    {
      "name": "test_json_as_unicode",
      "description": "parse JSON input and validate fields. Function `test_json_as_unicode`.",
      "predicted_filename": "tests\\test_json.py",
      "predicted_code_snippet": "def test_json_as_unicode(test_value, expected, app, app_ctx):\n    app.json.ensure_ascii = test_value\n    rv = app.json.dumps(\"\\N{SNOWMAN}\")\n    assert rv == expected",
      "input_schema": {
        "type": "object",
        "properties": {
          "test_value": {
            "type": "string",
            "required": true
          },
          "expected": {
            "type": "string",
            "required": true
          },
          "app": {
            "type": "string",
            "required": true
          },
          "app_ctx": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "test_value",
          "expected",
          "app",
          "app_ctx"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "test_value": "string",
          "expected": "string",
          "app": "string",
          "app_ctx": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_json_as_unicode` in tests\\test_json.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function test_json_as_unicode in tests\\test_json.py",
        "matched template: parse JSON input and validate fields (sim=0.28)"
      ]
    },
    {
      "name": "test_json_dump_to_file",
      "description": "parse JSON input and validate fields. Function `test_json_dump_to_file`.",
      "predicted_filename": "tests\\test_json.py",
      "predicted_code_snippet": "def test_json_dump_to_file(app, app_ctx):\n    test_data = {\"name\": \"Flask\"}\n    out = io.StringIO()\n\n    flask.json.dump(test_data, out)\n    out.seek(0)\n    rv = flask.json.load(out)\n    assert rv == test_data",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "app_ctx": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "app_ctx"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "app_ctx": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_json_dump_to_file` in tests\\test_json.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function test_json_dump_to_file in tests\\test_json.py",
        "matched template: parse JSON input and validate fields (sim=0.28)"
      ]
    },
    {
      "name": "test_jsonify_basic_types",
      "description": "parse JSON input and validate fields. Function `test_jsonify_basic_types`.",
      "predicted_filename": "tests\\test_json.py",
      "predicted_code_snippet": "def test_jsonify_basic_types(test_value, app, client):\n    url = \"/jsonify_basic_types\"\n    app.add_url_rule(url, url, lambda x=test_value: flask.jsonify(x))\n    rv = client.get(url)\n    assert rv.mimetype == \"application/json\"\n    assert flask.json.loads(rv.data) == test_value",
      "input_schema": {
        "type": "object",
        "properties": {
          "test_value": {
            "type": "string",
            "required": true
          },
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "test_value",
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "test_value": "string",
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_jsonify_basic_types` in tests\\test_json.py",
      "possible_syscalls": [],
      "confidence": 0.24,
      "evidence": [
        "function test_jsonify_basic_types in tests\\test_json.py",
        "matched template: parse JSON input and validate fields (sim=0.29)"
      ]
    },
    {
      "name": "test_jsonify_dicts",
      "description": "parse JSON input and validate fields. Function `test_jsonify_dicts`.",
      "predicted_filename": "tests\\test_json.py",
      "predicted_code_snippet": "def test_jsonify_dicts(app, client):\n    d = {\n        \"a\": 0,\n        \"b\": 23,\n        \"c\": 3.14,\n        \"d\": \"t\",\n        \"e\": \"Hi\",\n        \"f\": True,\n        \"g\": False,\n        \"h\": [\"test list\", 10, False],\n        \"i\": {\"test\": \"dict\"},\n    }\n\n    @app.route(\"/kw\")\n    def return_kwargs():\n        return flask.jsonify(**d)\n\n    @app.route(\"/dict\")\n    def return_dict():\n        return flask.jsonify(d)\n\n    for url in \"/kw\", \"/dict\":\n        rv = client.get(url)\n        assert rv.mimetype == \"application/json\"\n        assert flask.json.loads(rv.data) == d",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_jsonify_dicts` in tests\\test_json.py",
      "possible_syscalls": [],
      "confidence": 0.26,
      "evidence": [
        "function test_jsonify_dicts in tests\\test_json.py",
        "matched template: parse JSON input and validate fields (sim=0.33)"
      ]
    },
    {
      "name": "test_jsonify_arrays",
      "description": "parse JSON input and validate fields. Function `test_jsonify_arrays`.",
      "predicted_filename": "tests\\test_json.py",
      "predicted_code_snippet": "def test_jsonify_arrays(app, client):\n    \"\"\"Test jsonify of lists and args unpacking.\"\"\"\n    a_list = [\n        0,\n        42,\n        3.14,\n        \"t\",\n        \"hello\",\n        True,\n        False,\n        [\"test list\", 2, False],\n        {\"test\": \"dict\"},\n    ]\n\n    @app.route(\"/args_unpack\")\n    def return_args_unpack():\n        return flask.jsonify(*a_list)\n\n    @app.route(\"/array\")\n    def return_array():\n        return flask.jsonify(a_list)\n\n    for url in \"/args_unpack\", \"/array\":\n        rv = client.get(url)\n        assert rv.mimetype == \"application/json\"\n        assert flask.json.loads(rv.data) == a_list",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_jsonify_arrays` in tests\\test_json.py",
      "possible_syscalls": [],
      "confidence": 0.25,
      "evidence": [
        "function test_jsonify_arrays in tests\\test_json.py",
        "matched template: parse JSON input and validate fields (sim=0.31)"
      ]
    },
    {
      "name": "test_jsonify_datetime",
      "description": "parse JSON input and validate fields. Function `test_jsonify_datetime`.",
      "predicted_filename": "tests\\test_json.py",
      "predicted_code_snippet": "def test_jsonify_datetime(app, client, value):\n    @app.route(\"/\")\n    def index():\n        return flask.jsonify(value=value)\n\n    r = client.get()\n    assert r.json[\"value\"] == http_date(value)",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          },
          "value": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client",
          "value"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string",
          "value": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_jsonify_datetime` in tests\\test_json.py",
      "possible_syscalls": [],
      "confidence": 0.25,
      "evidence": [
        "function test_jsonify_datetime in tests\\test_json.py",
        "matched template: parse JSON input and validate fields (sim=0.30)"
      ]
    },
    {
      "name": "test_jsonify_aware_datetimes",
      "description": "parse JSON input and validate fields. Function `test_jsonify_aware_datetimes`.",
      "predicted_filename": "tests\\test_json.py",
      "predicted_code_snippet": "def test_jsonify_aware_datetimes(tz):\n    \"\"\"Test if aware datetime.datetime objects are converted into GMT.\"\"\"\n    tzinfo = FixedOffset(hours=tz[1], name=tz[0])\n    dt = datetime.datetime(2017, 1, 1, 12, 34, 56, tzinfo=tzinfo)\n    gmt = FixedOffset(hours=0, name=\"GMT\")\n    expected = dt.astimezone(gmt).strftime('\"%a, %d %b %Y %H:%M:%S %Z\"')\n    assert flask.json.dumps(dt) == expected",
      "input_schema": {
        "type": "object",
        "properties": {
          "tz": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "tz"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "tz": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_jsonify_aware_datetimes` in tests\\test_json.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function test_jsonify_aware_datetimes in tests\\test_json.py",
        "matched template: parse JSON input and validate fields (sim=0.25)"
      ]
    },
    {
      "name": "test_jsonify_uuid_types",
      "description": "stream data over websocket. Function `test_jsonify_uuid_types`.",
      "predicted_filename": "tests\\test_json.py",
      "predicted_code_snippet": "def test_jsonify_uuid_types(app, client):\n    \"\"\"Test jsonify with uuid.UUID types\"\"\"\n\n    test_uuid = uuid.UUID(bytes=b\"\\xde\\xad\\xbe\\xef\" * 4)\n    url = \"/uuid_test\"\n    app.add_url_rule(url, url, lambda: flask.jsonify(x=test_uuid))\n\n    rv = client.get(url)\n\n    rv_x = flask.json.loads(rv.data)[\"x\"]\n    assert rv_x == str(test_uuid)\n    rv_uuid = uuid.UUID(rv_x)\n    assert rv_uuid == test_uuid",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_jsonify_uuid_types` in tests\\test_json.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function test_jsonify_uuid_types in tests\\test_json.py",
        "matched template: stream data over websocket (sim=0.26)"
      ]
    },
    {
      "name": "test_json_decimal",
      "description": "parse JSON input and validate fields. Function `test_json_decimal`.",
      "predicted_filename": "tests\\test_json.py",
      "predicted_code_snippet": "def test_json_decimal():\n    rv = flask.json.dumps(decimal.Decimal(\"0.003\"))\n    assert rv == '\"0.003\"'",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_json_decimal` in tests\\test_json.py",
      "possible_syscalls": [],
      "confidence": 0.24,
      "evidence": [
        "function test_json_decimal in tests\\test_json.py",
        "matched template: parse JSON input and validate fields (sim=0.29)"
      ]
    },
    {
      "name": "test_json_attr",
      "description": "parse JSON input and validate fields. Function `test_json_attr`.",
      "predicted_filename": "tests\\test_json.py",
      "predicted_code_snippet": "def test_json_attr(app, client):\n    @app.route(\"/add\", methods=[\"POST\"])\n    def add():\n        json = flask.request.get_json()\n        return str(json[\"a\"] + json[\"b\"])\n\n    rv = client.post(\n        \"/add\",\n        data=flask.json.dumps({\"a\": 1, \"b\": 2}),\n        content_type=\"application/json\",\n    )\n    assert rv.data == b\"3\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_json_attr` in tests\\test_json.py",
      "possible_syscalls": [],
      "confidence": 0.24,
      "evidence": [
        "function test_json_attr in tests\\test_json.py",
        "matched template: parse JSON input and validate fields (sim=0.30)"
      ]
    },
    {
      "name": "test_tojson_filter",
      "description": "parse JSON input and validate fields. Function `test_tojson_filter`.",
      "predicted_filename": "tests\\test_json.py",
      "predicted_code_snippet": "def test_tojson_filter(app, req_ctx):\n    # The tojson filter is tested in Jinja, this confirms that it's\n    # using Flask's dumps.\n    rv = flask.render_template_string(\n        \"const data = {{ data|tojson }};\",\n        data={\"name\": \"</script>\", \"time\": datetime.datetime(2021, 2, 1, 7, 15)},\n    )\n    assert rv == (\n        'const data = {\"name\": \"\\\\u003c/script\\\\u003e\",'\n        ' \"time\": \"Mon, 01 Feb 2021 07:15:00 GMT\"};'\n    )",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "req_ctx": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "req_ctx"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "req_ctx": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_tojson_filter` in tests\\test_json.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function test_tojson_filter in tests\\test_json.py",
        "matched template: parse JSON input and validate fields (sim=0.24)"
      ]
    },
    {
      "name": "test_json_customization",
      "description": "serialize object to JSON. Function `test_json_customization`.",
      "predicted_filename": "tests\\test_json.py",
      "predicted_code_snippet": "def test_json_customization(app, client):\n    class X:  # noqa: B903, for Python2 compatibility\n        def __init__(self, val):\n            self.val = val\n\n    def default(o):\n        if isinstance(o, X):\n            return f\"<{o.val}>\"\n\n        return DefaultJSONProvider.default(o)\n\n    class CustomProvider(DefaultJSONProvider):\n        def object_hook(self, obj):\n            if len(obj) == 1 and \"_foo\" in obj:\n                return X(obj[\"_foo\"])\n\n            return obj\n\n        def loads(self, s, **kwargs):\n            kwargs.setdefault(\"object_hook\", self.object_hook)\n            return super().loads(s, **kwargs)\n\n    app.json = CustomProvider(app)\n    app.json.default = default\n\n    @app.route(\"/\", methods=[\"POST\"])\n    def index():\n        return flask.json.dumps(flask.request.get_json()[\"x\"])\n\n    rv = client.post(\n        \"/\",\n        data=flask.json.dumps({\"x\": {\"_foo\": 42}}),\n        content_type=\"application/json\",\n    )\n    assert rv.data == b'\"<42>\"'",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_json_customization` in tests\\test_json.py",
      "possible_syscalls": [],
      "confidence": 0.24,
      "evidence": [
        "function test_json_customization in tests\\test_json.py",
        "matched template: serialize object to JSON (sim=0.30)"
      ]
    },
    {
      "name": "_has_encoding",
      "description": "parse JSON input and validate fields. Function `_has_encoding`.",
      "predicted_filename": "tests\\test_json.py",
      "predicted_code_snippet": "def _has_encoding(name):\n    try:\n        import codecs\n\n        codecs.lookup(name)\n        return True\n    except LookupError:\n        return False",
      "input_schema": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "name"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "name": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `_has_encoding` in tests\\test_json.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function _has_encoding in tests\\test_json.py",
        "matched template: parse JSON input and validate fields (sim=0.26)"
      ]
    },
    {
      "name": "test_json_key_sorting",
      "description": "parse JSON input and validate fields. Function `test_json_key_sorting`.",
      "predicted_filename": "tests\\test_json.py",
      "predicted_code_snippet": "def test_json_key_sorting(app, client):\n    app.debug = True\n    assert app.json.sort_keys\n    d = dict.fromkeys(range(20), \"foo\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.jsonify(values=d)\n\n    rv = client.get(\"/\")\n    lines = [x.strip() for x in rv.data.strip().decode(\"utf-8\").splitlines()]\n    sorted_by_str = [\n        \"{\",\n        '\"values\": {',\n        '\"0\": \"foo\",',\n        '\"1\": \"foo\",',\n        '\"10\": \"foo\",',\n        '\"11\": \"foo\",',\n        '\"12\": \"foo\",',\n        '\"13\": \"foo\",',\n        '\"14\": \"foo\",',\n        '\"15\": \"foo\",',\n        '\"16\": \"foo\",',\n        '\"17\": \"foo\",',\n        '\"18\": \"foo\",',\n        '\"19\": \"foo\",',\n        '\"2\": \"foo\",',\n        '\"3\": \"foo\",',\n        '\"4\": \"foo\",',\n        '\"5\": \"foo\",',\n        '\"6\": \"foo\",',\n        '\"7\": \"foo\",',\n        '\"8\": \"foo\",',\n        '\"9\": \"foo\"',\n        \"}\",\n        \"}\",\n    ]\n    sorted_by_int = [\n        \"{\",\n        '\"values\": {',\n        '\"0\": \"foo\",',\n        '\"1\": \"foo\",',\n        '\"2\": \"foo\",',\n        '\"3\": \"foo\",',\n        '\"4\": \"foo\",',\n        '\"5\": \"foo\",',\n        '\"6\": \"foo\",',\n        '\"7\": \"foo\",',\n        '\"8\": \"foo\",',\n        '\"9\": \"foo\",',\n        '\"10\": \"foo\",',\n        '\"11\": \"foo\",',\n        '\"12\": \"foo\",',\n        '\"13\": \"foo\",',\n        '\"14\": \"foo\",',\n        '\"15\": \"foo\",',\n        '\"16\": \"foo\",',\n        '\"17\": \"foo\",',\n        '\"18\": \"foo\",',\n        '\"19\": \"foo\"',\n        \"}\",\n        \"}\",\n    ]\n\n    try:\n        assert lines == sorted_by_int\n    except AssertionError:\n        assert lines == sorted_by_str",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_json_key_sorting` in tests\\test_json.py",
      "possible_syscalls": [],
      "confidence": 0.28,
      "evidence": [
        "function test_json_key_sorting in tests\\test_json.py",
        "matched template: parse JSON input and validate fields (sim=0.35)"
      ]
    },
    {
      "name": "test_html_method",
      "description": "make an HTTP request to an external API. Function `test_html_method`.",
      "predicted_filename": "tests\\test_json.py",
      "predicted_code_snippet": "def test_html_method():\n    class ObjectWithHTML:\n        def __html__(self):\n            return \"<p>test</p>\"\n\n    result = json.dumps(ObjectWithHTML())\n    assert result == '\"<p>test</p>\"'",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_html_method` in tests\\test_json.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function test_html_method in tests\\test_json.py",
        "matched template: make an HTTP request to an external API (sim=0.27)"
      ]
    },
    {
      "name": "test_dump_load_unchanged",
      "description": "parse JSON input and validate fields. Function `test_dump_load_unchanged`.",
      "predicted_filename": "tests\\test_json_tag.py",
      "predicted_code_snippet": "def test_dump_load_unchanged(data):\n    s = TaggedJSONSerializer()\n    assert s.loads(s.dumps(data)) == data",
      "input_schema": {
        "type": "object",
        "properties": {
          "data": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "data"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "data": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_dump_load_unchanged` in tests\\test_json_tag.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function test_dump_load_unchanged in tests\\test_json_tag.py",
        "matched template: parse JSON input and validate fields (sim=0.26)"
      ]
    },
    {
      "name": "test_duplicate_tag",
      "description": "parse JSON input and validate fields. Function `test_duplicate_tag`.",
      "predicted_filename": "tests\\test_json_tag.py",
      "predicted_code_snippet": "def test_duplicate_tag():\n    class TagDict(JSONTag):\n        key = \" d\"\n\n    s = TaggedJSONSerializer()\n    pytest.raises(KeyError, s.register, TagDict)\n    s.register(TagDict, force=True, index=0)\n    assert isinstance(s.tags[\" d\"], TagDict)\n    assert isinstance(s.order[0], TagDict)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_duplicate_tag` in tests\\test_json_tag.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function test_duplicate_tag in tests\\test_json_tag.py",
        "matched template: parse JSON input and validate fields (sim=0.27)"
      ]
    },
    {
      "name": "test_custom_tag",
      "description": "parse JSON input and validate fields. Function `test_custom_tag`.",
      "predicted_filename": "tests\\test_json_tag.py",
      "predicted_code_snippet": "def test_custom_tag():\n    class Foo:  # noqa: B903, for Python2 compatibility\n        def __init__(self, data):\n            self.data = data\n\n    class TagFoo(JSONTag):\n        __slots__ = ()\n        key = \" f\"\n\n        def check(self, value):\n            return isinstance(value, Foo)\n\n        def to_json(self, value):\n            return self.serializer.tag(value.data)\n\n        def to_python(self, value):\n            return Foo(value)\n\n    s = TaggedJSONSerializer()\n    s.register(TagFoo)\n    assert s.loads(s.dumps(Foo(\"bar\"))).data == \"bar\"",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_custom_tag` in tests\\test_json_tag.py",
      "possible_syscalls": [],
      "confidence": 0.27,
      "evidence": [
        "function test_custom_tag in tests\\test_json_tag.py",
        "matched template: parse JSON input and validate fields (sim=0.34)"
      ]
    },
    {
      "name": "test_tag_interface",
      "description": "parse JSON input and validate fields. Function `test_tag_interface`.",
      "predicted_filename": "tests\\test_json_tag.py",
      "predicted_code_snippet": "def test_tag_interface():\n    t = JSONTag(None)\n    pytest.raises(NotImplementedError, t.check, None)\n    pytest.raises(NotImplementedError, t.to_json, None)\n    pytest.raises(NotImplementedError, t.to_python, None)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_tag_interface` in tests\\test_json_tag.py",
      "possible_syscalls": [],
      "confidence": 0.26,
      "evidence": [
        "function test_tag_interface in tests\\test_json_tag.py",
        "matched template: parse JSON input and validate fields (sim=0.33)"
      ]
    },
    {
      "name": "test_tag_order",
      "description": "parse JSON input and validate fields. Function `test_tag_order`.",
      "predicted_filename": "tests\\test_json_tag.py",
      "predicted_code_snippet": "def test_tag_order():\n    class Tag1(JSONTag):\n        key = \" 1\"\n\n    class Tag2(JSONTag):\n        key = \" 2\"\n\n    s = TaggedJSONSerializer()\n\n    s.register(Tag1, index=-1)\n    assert isinstance(s.order[-2], Tag1)\n\n    s.register(Tag2, index=None)\n    assert isinstance(s.order[-1], Tag2)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_tag_order` in tests\\test_json_tag.py",
      "possible_syscalls": [],
      "confidence": 0.25,
      "evidence": [
        "function test_tag_order in tests\\test_json_tag.py",
        "matched template: parse JSON input and validate fields (sim=0.30)"
      ]
    },
    {
      "name": "reset_logging",
      "description": "write data to a file. Function `reset_logging`.",
      "predicted_filename": "tests\\test_logging.py",
      "predicted_code_snippet": "def reset_logging(pytestconfig):\n    root_handlers = logging.root.handlers[:]\n    logging.root.handlers = []\n    root_level = logging.root.level\n\n    logger = logging.getLogger(\"flask_test\")\n    logger.handlers = []\n    logger.setLevel(logging.NOTSET)\n\n    logging_plugin = pytestconfig.pluginmanager.unregister(name=\"logging-plugin\")\n\n    yield\n\n    logging.root.handlers[:] = root_handlers\n    logging.root.setLevel(root_level)\n\n    logger.handlers = []\n    logger.setLevel(logging.NOTSET)\n\n    if logging_plugin:\n        pytestconfig.pluginmanager.register(logging_plugin, \"logging-plugin\")",
      "input_schema": {
        "type": "object",
        "properties": {
          "pytestconfig": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "pytestconfig"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "pytestconfig": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `reset_logging` in tests\\test_logging.py",
      "possible_syscalls": [],
      "confidence": 0.16,
      "evidence": [
        "function reset_logging in tests\\test_logging.py",
        "matched template: write data to a file (sim=0.09)"
      ]
    },
    {
      "name": "test_logger",
      "description": "write data to a file. Function `test_logger`.",
      "predicted_filename": "tests\\test_logging.py",
      "predicted_code_snippet": "def test_logger(app):\n    assert app.logger.name == \"flask_test\"\n    assert app.logger.level == logging.NOTSET\n    assert app.logger.handlers == [default_handler]",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_logger` in tests\\test_logging.py",
      "possible_syscalls": [],
      "confidence": 0.16,
      "evidence": [
        "function test_logger in tests\\test_logging.py",
        "matched template: write data to a file (sim=0.10)"
      ]
    },
    {
      "name": "test_logger_debug",
      "description": "write data to a file. Function `test_logger_debug`.",
      "predicted_filename": "tests\\test_logging.py",
      "predicted_code_snippet": "def test_logger_debug(app):\n    app.debug = True\n    assert app.logger.level == logging.DEBUG\n    assert app.logger.handlers == [default_handler]",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_logger_debug` in tests\\test_logging.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function test_logger_debug in tests\\test_logging.py",
        "matched template: write data to a file (sim=0.11)"
      ]
    },
    {
      "name": "test_existing_handler",
      "description": "stream data over websocket. Function `test_existing_handler`.",
      "predicted_filename": "tests\\test_logging.py",
      "predicted_code_snippet": "def test_existing_handler(app):\n    logging.root.addHandler(logging.StreamHandler())\n    assert app.logger.level == logging.NOTSET\n    assert not app.logger.handlers",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_existing_handler` in tests\\test_logging.py",
      "possible_syscalls": [],
      "confidence": 0.16,
      "evidence": [
        "function test_existing_handler in tests\\test_logging.py",
        "matched template: stream data over websocket (sim=0.11)"
      ]
    },
    {
      "name": "test_wsgi_errors_stream",
      "description": "stream data over websocket. Function `test_wsgi_errors_stream`.",
      "predicted_filename": "tests\\test_logging.py",
      "predicted_code_snippet": "def test_wsgi_errors_stream(app, client):\n    @app.route(\"/\")\n    def index():\n        app.logger.error(\"test\")\n        return \"\"\n\n    stream = StringIO()\n    client.get(\"/\", errors_stream=stream)\n    assert \"ERROR in test_logging: test\" in stream.getvalue()\n\n    assert wsgi_errors_stream._get_current_object() is sys.stderr\n\n    with app.test_request_context(errors_stream=stream):\n        assert wsgi_errors_stream._get_current_object() is stream",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_wsgi_errors_stream` in tests\\test_logging.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_wsgi_errors_stream in tests\\test_logging.py",
        "matched template: stream data over websocket (sim=0.18)"
      ]
    },
    {
      "name": "test_has_level_handler",
      "description": "handle a HTTP route request and return response. Function `test_has_level_handler`.",
      "predicted_filename": "tests\\test_logging.py",
      "predicted_code_snippet": "def test_has_level_handler():\n    logger = logging.getLogger(\"flask.app\")\n    assert not has_level_handler(logger)\n\n    handler = logging.StreamHandler()\n    logging.root.addHandler(handler)\n    assert has_level_handler(logger)\n\n    logger.propagate = False\n    assert not has_level_handler(logger)\n    logger.propagate = True\n\n    handler.setLevel(logging.ERROR)\n    assert not has_level_handler(logger)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_has_level_handler` in tests\\test_logging.py",
      "possible_syscalls": [],
      "confidence": 0.16,
      "evidence": [
        "function test_has_level_handler in tests\\test_logging.py",
        "matched template: handle a HTTP route request and return response (sim=0.09)"
      ]
    },
    {
      "name": "test_log_view_exception",
      "description": "handle a HTTP route request and return response. Function `test_log_view_exception`.",
      "predicted_filename": "tests\\test_logging.py",
      "predicted_code_snippet": "def test_log_view_exception(app, client):\n    @app.route(\"/\")\n    def index():\n        raise Exception(\"test\")\n\n    app.testing = False\n    stream = StringIO()\n    rv = client.get(\"/\", errors_stream=stream)\n    assert rv.status_code == 500\n    assert rv.data\n    err = stream.getvalue()\n    assert \"Exception on / [GET]\" in err\n    assert \"Exception: test\" in err",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_log_view_exception` in tests\\test_logging.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_log_view_exception in tests\\test_logging.py",
        "matched template: handle a HTTP route request and return response (sim=0.18)"
      ]
    },
    {
      "name": "test_aborting",
      "description": "handle a HTTP route request and return response. Function `test_aborting`.",
      "predicted_filename": "tests\\test_regression.py",
      "predicted_code_snippet": "def test_aborting(app):\n    class Foo(Exception):\n        whatever = 42\n\n    @app.errorhandler(Foo)\n    def handle_foo(e):\n        return str(e.whatever)\n\n    @app.route(\"/\")\n    def index():\n        raise flask.abort(flask.redirect(flask.url_for(\"test\")))\n\n    @app.route(\"/test\")\n    def test():\n        raise Foo()\n\n    with app.test_client() as c:\n        rv = c.get(\"/\")\n        location_parts = rv.headers[\"Location\"].rpartition(\"/\")\n\n        if location_parts[0]:\n            # For older Werkzeug that used absolute redirects.\n            assert location_parts[0] == \"http://localhost\"\n\n        assert location_parts[2] == \"test\"\n        rv = c.get(\"/test\")\n        assert rv.data == b\"42\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_aborting` in tests\\test_regression.py",
      "possible_syscalls": [],
      "confidence": 0.3,
      "evidence": [
        "function test_aborting in tests\\test_regression.py",
        "matched template: handle a HTTP route request and return response (sim=0.39)"
      ]
    },
    {
      "name": "test_teardown_on_pop",
      "description": "handle a HTTP route request and return response. Function `test_teardown_on_pop`.",
      "predicted_filename": "tests\\test_reqctx.py",
      "predicted_code_snippet": "def test_teardown_on_pop(app):\n    buffer = []\n\n    @app.teardown_request\n    def end_of_request(exception):\n        buffer.append(exception)\n\n    ctx = app.test_request_context()\n    ctx.push()\n    assert buffer == []\n    ctx.pop()\n    assert buffer == [None]",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_teardown_on_pop` in tests\\test_reqctx.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function test_teardown_on_pop in tests\\test_reqctx.py",
        "matched template: handle a HTTP route request and return response (sim=0.15)"
      ]
    },
    {
      "name": "test_teardown_with_previous_exception",
      "description": "handle a HTTP route request and return response. Function `test_teardown_with_previous_exception`.",
      "predicted_filename": "tests\\test_reqctx.py",
      "predicted_code_snippet": "def test_teardown_with_previous_exception(app):\n    buffer = []\n\n    @app.teardown_request\n    def end_of_request(exception):\n        buffer.append(exception)\n\n    try:\n        raise Exception(\"dummy\")\n    except Exception:\n        pass\n\n    with app.test_request_context():\n        assert buffer == []\n    assert buffer == [None]",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_teardown_with_previous_exception` in tests\\test_reqctx.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function test_teardown_with_previous_exception in tests\\test_reqctx.py",
        "matched template: handle a HTTP route request and return response (sim=0.16)"
      ]
    },
    {
      "name": "test_teardown_with_handled_exception",
      "description": "handle a HTTP route request and return response. Function `test_teardown_with_handled_exception`.",
      "predicted_filename": "tests\\test_reqctx.py",
      "predicted_code_snippet": "def test_teardown_with_handled_exception(app):\n    buffer = []\n\n    @app.teardown_request\n    def end_of_request(exception):\n        buffer.append(exception)\n\n    with app.test_request_context():\n        assert buffer == []\n        try:\n            raise Exception(\"dummy\")\n        except Exception:\n            pass\n    assert buffer == [None]",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_teardown_with_handled_exception` in tests\\test_reqctx.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_teardown_with_handled_exception in tests\\test_reqctx.py",
        "matched template: handle a HTTP route request and return response (sim=0.18)"
      ]
    },
    {
      "name": "test_proper_test_request_context",
      "description": "handle a HTTP route request and return response. Function `test_proper_test_request_context`.",
      "predicted_filename": "tests\\test_reqctx.py",
      "predicted_code_snippet": "def test_proper_test_request_context(app):\n    app.config.update(SERVER_NAME=\"localhost.localdomain:5000\")\n\n    @app.route(\"/\")\n    def index():\n        return None\n\n    @app.route(\"/\", subdomain=\"foo\")\n    def sub():\n        return None\n\n    with app.test_request_context(\"/\"):\n        assert (\n            flask.url_for(\"index\", _external=True)\n            == \"http://localhost.localdomain:5000/\"\n        )\n\n    with app.test_request_context(\"/\"):\n        assert (\n            flask.url_for(\"sub\", _external=True)\n            == \"http://foo.localhost.localdomain:5000/\"\n        )\n\n    # suppress Werkzeug 0.15 warning about name mismatch\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\n            \"ignore\", \"Current server name\", UserWarning, \"flask.app\"\n        )\n        with app.test_request_context(\n            \"/\", environ_overrides={\"HTTP_HOST\": \"localhost\"}\n        ):\n            pass\n\n    app.config.update(SERVER_NAME=\"localhost\")\n    with app.test_request_context(\"/\", environ_overrides={\"SERVER_NAME\": \"localhost\"}):\n        pass\n\n    app.config.update(SERVER_NAME=\"localhost:80\")\n    with app.test_request_context(\n        \"/\", environ_overrides={\"SERVER_NAME\": \"localhost:80\"}\n    ):\n        pass",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_proper_test_request_context` in tests\\test_reqctx.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function test_proper_test_request_context in tests\\test_reqctx.py",
        "matched template: handle a HTTP route request and return response (sim=0.28)"
      ]
    },
    {
      "name": "test_context_binding",
      "description": "handle a HTTP route request and return response. Function `test_context_binding`.",
      "predicted_filename": "tests\\test_reqctx.py",
      "predicted_code_snippet": "def test_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    @app.route(\"/meh\")\n    def meh():\n        return flask.request.url\n\n    with app.test_request_context(\"/?name=World\"):\n        assert index() == \"Hello World!\"\n    with app.test_request_context(\"/meh\"):\n        assert meh() == \"http://localhost/meh\"\n    assert not flask.request",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_context_binding` in tests\\test_reqctx.py",
      "possible_syscalls": [],
      "confidence": 0.24,
      "evidence": [
        "function test_context_binding in tests\\test_reqctx.py",
        "matched template: handle a HTTP route request and return response (sim=0.29)"
      ]
    },
    {
      "name": "test_context_test",
      "description": "handle a HTTP route request and return response. Function `test_context_test`.",
      "predicted_filename": "tests\\test_reqctx.py",
      "predicted_code_snippet": "def test_context_test(app):\n    assert not flask.request\n    assert not flask.has_request_context()\n    ctx = app.test_request_context()\n    ctx.push()\n    try:\n        assert flask.request\n        assert flask.has_request_context()\n    finally:\n        ctx.pop()",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_context_test` in tests\\test_reqctx.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function test_context_test in tests\\test_reqctx.py",
        "matched template: handle a HTTP route request and return response (sim=0.16)"
      ]
    },
    {
      "name": "test_manual_context_binding",
      "description": "handle a HTTP route request and return response. Function `test_manual_context_binding`.",
      "predicted_filename": "tests\\test_reqctx.py",
      "predicted_code_snippet": "def test_manual_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    ctx = app.test_request_context(\"/?name=World\")\n    ctx.push()\n    assert index() == \"Hello World!\"\n    ctx.pop()\n    with pytest.raises(RuntimeError):\n        index()",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_manual_context_binding` in tests\\test_reqctx.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function test_manual_context_binding in tests\\test_reqctx.py",
        "matched template: handle a HTTP route request and return response (sim=0.23)"
      ]
    },
    {
      "name": "test_session_error_pops_context",
      "description": "handle a HTTP route request and return response. Function `test_session_error_pops_context`.",
      "predicted_filename": "tests\\test_reqctx.py",
      "predicted_code_snippet": "def test_session_error_pops_context():\n    class SessionError(Exception):\n        pass\n\n    class FailingSessionInterface(SessionInterface):\n        def open_session(self, app, request):\n            raise SessionError()\n\n    class CustomFlask(flask.Flask):\n        session_interface = FailingSessionInterface()\n\n    app = CustomFlask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        # shouldn't get here\n        AssertionError()\n\n    response = app.test_client().get(\"/\")\n    assert response.status_code == 500\n    assert not flask.request\n    assert not flask.current_app",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_session_error_pops_context` in tests\\test_reqctx.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function test_session_error_pops_context in tests\\test_reqctx.py",
        "matched template: handle a HTTP route request and return response (sim=0.24)"
      ]
    },
    {
      "name": "test_session_dynamic_cookie_name",
      "description": "handle a HTTP route request and return response. Function `test_session_dynamic_cookie_name`.",
      "predicted_filename": "tests\\test_reqctx.py",
      "predicted_code_snippet": "def test_session_dynamic_cookie_name():\n    # This session interface will use a cookie with a different name if the\n    # requested url ends with the string \"dynamic_cookie\"\n    class PathAwareSessionInterface(SecureCookieSessionInterface):\n        def get_cookie_name(self, app):\n            if flask.request.url.endswith(\"dynamic_cookie\"):\n                return \"dynamic_cookie_name\"\n            else:\n                return super().get_cookie_name(app)\n\n    class CustomFlask(flask.Flask):\n        session_interface = PathAwareSessionInterface()\n\n    app = CustomFlask(__name__)\n    app.secret_key = \"secret_key\"\n\n    @app.route(\"/set\", methods=[\"POST\"])\n    def set():\n        flask.session[\"value\"] = flask.request.form[\"value\"]\n        return \"value set\"\n\n    @app.route(\"/get\")\n    def get():\n        v = flask.session.get(\"value\", \"None\")\n        return v\n\n    @app.route(\"/set_dynamic_cookie\", methods=[\"POST\"])\n    def set_dynamic_cookie():\n        flask.session[\"value\"] = flask.request.form[\"value\"]\n        return \"value set\"\n\n    @app.route(\"/get_dynamic_cookie\")\n    def get_dynamic_cookie():\n        v = flask.session.get(\"value\", \"None\")\n        return v\n\n    test_client = app.test_client()\n\n    # first set the cookie in both /set urls but each with a different value\n    assert test_client.post(\"/set\", data={\"value\": \"42\"}).data == b\"value set\"\n    assert (\n        test_client.post(\"/set_dynamic_cookie\", data={\"value\": \"616\"}).data\n        == b\"value set\"\n    )\n\n    # now check that the relevant values come back - meaning that different\n    # cookies are being used for the urls that end with \"dynamic cookie\"\n    assert test_client.get(\"/get\").data == b\"42\"\n    assert test_client.get(\"/get_dynamic_cookie\").data == b\"616\"",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_session_dynamic_cookie_name` in tests\\test_reqctx.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function test_session_dynamic_cookie_name in tests\\test_reqctx.py",
        "matched template: handle a HTTP route request and return response (sim=0.27)"
      ]
    },
    {
      "name": "test_bad_environ_raises_bad_request",
      "description": "make an HTTP request to an external API. Function `test_bad_environ_raises_bad_request`.",
      "predicted_filename": "tests\\test_reqctx.py",
      "predicted_code_snippet": "def test_bad_environ_raises_bad_request():\n    app = flask.Flask(__name__)\n\n    from flask.testing import EnvironBuilder\n\n    builder = EnvironBuilder(app)\n    environ = builder.get_environ()\n\n    # use a non-printable character in the Host - this is key to this test\n    environ[\"HTTP_HOST\"] = \"\\x8a\"\n\n    with app.request_context(environ) as ctx:\n        response = app.full_dispatch_request(ctx)\n\n    assert response.status_code == 400",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_bad_environ_raises_bad_request` in tests\\test_reqctx.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function test_bad_environ_raises_bad_request in tests\\test_reqctx.py",
        "matched template: make an HTTP request to an external API (sim=0.21)"
      ]
    },
    {
      "name": "test_environ_for_valid_idna_completes",
      "description": "handle a HTTP route request and return response. Function `test_environ_for_valid_idna_completes`.",
      "predicted_filename": "tests\\test_reqctx.py",
      "predicted_code_snippet": "def test_environ_for_valid_idna_completes():\n    app = flask.Flask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        return \"Hello World!\"\n\n    from flask.testing import EnvironBuilder\n\n    builder = EnvironBuilder(app)\n    environ = builder.get_environ()\n\n    # these characters are all IDNA-compatible\n    environ[\"HTTP_HOST\"] = \"\u0105\u015b\u017a\u00e4\u00fc\u0436\u0160\u00df\u044f.com\"\n\n    with app.request_context(environ) as ctx:\n        response = app.full_dispatch_request(ctx)\n\n    assert response.status_code == 200",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_environ_for_valid_idna_completes` in tests\\test_reqctx.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function test_environ_for_valid_idna_completes in tests\\test_reqctx.py",
        "matched template: handle a HTTP route request and return response (sim=0.26)"
      ]
    },
    {
      "name": "test_normal_environ_completes",
      "description": "handle a HTTP route request and return response. Function `test_normal_environ_completes`.",
      "predicted_filename": "tests\\test_reqctx.py",
      "predicted_code_snippet": "def test_normal_environ_completes():\n    app = flask.Flask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        return \"Hello World!\"\n\n    response = app.test_client().get(\"/\", headers={\"host\": \"xn--on-0ia.com\"})\n    assert response.status_code == 200",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_normal_environ_completes` in tests\\test_reqctx.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function test_normal_environ_completes in tests\\test_reqctx.py",
        "matched template: handle a HTTP route request and return response (sim=0.26)"
      ]
    },
    {
      "name": "test_max_content_length",
      "description": "write data to a file. Function `test_max_content_length`.",
      "predicted_filename": "tests\\test_request.py",
      "predicted_code_snippet": "def test_max_content_length(app: Flask, client: FlaskClient) -> None:\n    app.config[\"MAX_CONTENT_LENGTH\"] = 50\n\n    @app.post(\"/\")\n    def index():\n        request.form[\"myfile\"]\n        AssertionError()\n\n    @app.errorhandler(413)\n    def catcher(error):\n        return \"42\"\n\n    rv = client.post(\"/\", data={\"myfile\": \"foo\" * 50})\n    assert rv.data == b\"42\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `test_max_content_length` in tests\\test_request.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function test_max_content_length in tests\\test_request.py",
        "matched template: write data to a file (sim=0.21)"
      ]
    },
    {
      "name": "test_limit_config",
      "description": "validate and sanitize user input. Function `test_limit_config`.",
      "predicted_filename": "tests\\test_request.py",
      "predicted_code_snippet": "def test_limit_config(app: Flask):\n    app.config[\"MAX_CONTENT_LENGTH\"] = 100\n    app.config[\"MAX_FORM_MEMORY_SIZE\"] = 50\n    app.config[\"MAX_FORM_PARTS\"] = 3\n    r = Request({})\n\n    # no app context, use Werkzeug defaults\n    assert r.max_content_length is None\n    assert r.max_form_memory_size == 500_000\n    assert r.max_form_parts == 1_000\n\n    # in app context, use config\n    with app.app_context():\n        assert r.max_content_length == 100\n        assert r.max_form_memory_size == 50\n        assert r.max_form_parts == 3\n\n    # regardless of app context, use override\n    r.max_content_length = 90\n    r.max_form_memory_size = 30\n    r.max_form_parts = 4\n\n    assert r.max_content_length == 90\n    assert r.max_form_memory_size == 30\n    assert r.max_form_parts == 4\n\n    with app.app_context():\n        assert r.max_content_length == 90\n        assert r.max_form_memory_size == 30\n        assert r.max_form_parts == 4",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_limit_config` in tests\\test_request.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function test_limit_config in tests\\test_request.py",
        "matched template: validate and sanitize user input (sim=0.12)"
      ]
    },
    {
      "name": "test_trusted_hosts_config",
      "description": "make an HTTP request to an external API. Function `test_trusted_hosts_config`.",
      "predicted_filename": "tests\\test_request.py",
      "predicted_code_snippet": "def test_trusted_hosts_config(app: Flask) -> None:\n    app.config[\"TRUSTED_HOSTS\"] = [\"example.test\", \".other.test\"]\n\n    @app.get(\"/\")\n    def index() -> str:\n        return \"\"\n\n    client = app.test_client()\n    r = client.get(base_url=\"http://example.test\")\n    assert r.status_code == 200\n    r = client.get(base_url=\"http://a.other.test\")\n    assert r.status_code == 200\n    r = client.get(base_url=\"http://bad.test\")\n    assert r.status_code == 400",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `test_trusted_hosts_config` in tests\\test_request.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function test_trusted_hosts_config in tests\\test_request.py",
        "matched template: make an HTTP request to an external API (sim=0.24)"
      ]
    },
    {
      "name": "test_open_session_with_endpoint",
      "description": "handle a HTTP route request and return response. Function `test_open_session_with_endpoint`.",
      "predicted_filename": "tests\\test_session_interface.py",
      "predicted_code_snippet": "def test_open_session_with_endpoint():\n    \"\"\"If request.endpoint (or other URL matching behavior) is needed\n    while loading the session, RequestContext.match_request() can be\n    called manually.\n    \"\"\"\n\n    class MySessionInterface(SessionInterface):\n        def save_session(self, app, session, response):\n            pass\n\n        def open_session(self, app, request):\n            app_ctx.match_request()\n            assert request.endpoint is not None\n\n    app = flask.Flask(__name__)\n    app.session_interface = MySessionInterface()\n\n    @app.get(\"/\")\n    def index():\n        return \"Hello, World!\"\n\n    response = app.test_client().get(\"/\")\n    assert response.status_code == 200",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_open_session_with_endpoint` in tests\\test_session_interface.py",
      "possible_syscalls": [],
      "confidence": 0.26,
      "evidence": [
        "function test_open_session_with_endpoint in tests\\test_session_interface.py",
        "matched template: handle a HTTP route request and return response (sim=0.32)"
      ]
    },
    {
      "name": "test_template_rendered",
      "description": "handle a HTTP route request and return response. Function `test_template_rendered`.",
      "predicted_filename": "tests\\test_signals.py",
      "predicted_code_snippet": "def test_template_rendered(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"simple_template.html\", whiskey=42)\n\n    recorded = []\n\n    def record(sender, template, context):\n        recorded.append((template, context))\n\n    flask.template_rendered.connect(record, app)\n    try:\n        client.get(\"/\")\n        assert len(recorded) == 1\n        template, context = recorded[0]\n        assert template.name == \"simple_template.html\"\n        assert context[\"whiskey\"] == 42\n    finally:\n        flask.template_rendered.disconnect(record, app)",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_template_rendered` in tests\\test_signals.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function test_template_rendered in tests\\test_signals.py",
        "matched template: handle a HTTP route request and return response (sim=0.28)"
      ]
    },
    {
      "name": "test_before_render_template",
      "description": "handle a HTTP route request and return response. Function `test_before_render_template`.",
      "predicted_filename": "tests\\test_signals.py",
      "predicted_code_snippet": "def test_before_render_template():\n    app = flask.Flask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"simple_template.html\", whiskey=42)\n\n    recorded = []\n\n    def record(sender, template, context):\n        context[\"whiskey\"] = 43\n        recorded.append((template, context))\n\n    flask.before_render_template.connect(record, app)\n    try:\n        rv = app.test_client().get(\"/\")\n        assert len(recorded) == 1\n        template, context = recorded[0]\n        assert template.name == \"simple_template.html\"\n        assert context[\"whiskey\"] == 43\n        assert rv.data == b\"<h1>43</h1>\"\n    finally:\n        flask.before_render_template.disconnect(record, app)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_before_render_template` in tests\\test_signals.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function test_before_render_template in tests\\test_signals.py",
        "matched template: handle a HTTP route request and return response (sim=0.27)"
      ]
    },
    {
      "name": "test_request_signals",
      "description": "handle a HTTP route request and return response. Function `test_request_signals`.",
      "predicted_filename": "tests\\test_signals.py",
      "predicted_code_snippet": "def test_request_signals():\n    app = flask.Flask(__name__)\n    calls = []\n\n    def before_request_signal(sender):\n        calls.append(\"before-signal\")\n\n    def after_request_signal(sender, response):\n        assert response.data == b\"stuff\"\n        calls.append(\"after-signal\")\n\n    @app.before_request\n    def before_request_handler():\n        calls.append(\"before-handler\")\n\n    @app.after_request\n    def after_request_handler(response):\n        calls.append(\"after-handler\")\n        response.data = \"stuff\"\n        return response\n\n    @app.route(\"/\")\n    def index():\n        calls.append(\"handler\")\n        return \"ignored anyway\"\n\n    flask.request_started.connect(before_request_signal, app)\n    flask.request_finished.connect(after_request_signal, app)\n\n    try:\n        rv = app.test_client().get(\"/\")\n        assert rv.data == b\"stuff\"\n\n        assert calls == [\n            \"before-signal\",\n            \"before-handler\",\n            \"handler\",\n            \"after-handler\",\n            \"after-signal\",\n        ]\n    finally:\n        flask.request_started.disconnect(before_request_signal, app)\n        flask.request_finished.disconnect(after_request_signal, app)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_request_signals` in tests\\test_signals.py",
      "possible_syscalls": [],
      "confidence": 0.26,
      "evidence": [
        "function test_request_signals in tests\\test_signals.py",
        "matched template: handle a HTTP route request and return response (sim=0.32)"
      ]
    },
    {
      "name": "test_request_exception_signal",
      "description": "handle a HTTP route request and return response. Function `test_request_exception_signal`.",
      "predicted_filename": "tests\\test_signals.py",
      "predicted_code_snippet": "def test_request_exception_signal():\n    app = flask.Flask(__name__)\n    recorded = []\n\n    @app.route(\"/\")\n    def index():\n        raise ZeroDivisionError\n\n    def record(sender, exception):\n        recorded.append(exception)\n\n    flask.got_request_exception.connect(record, app)\n    try:\n        assert app.test_client().get(\"/\").status_code == 500\n        assert len(recorded) == 1\n        assert isinstance(recorded[0], ZeroDivisionError)\n    finally:\n        flask.got_request_exception.disconnect(record, app)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_request_exception_signal` in tests\\test_signals.py",
      "possible_syscalls": [],
      "confidence": 0.25,
      "evidence": [
        "function test_request_exception_signal in tests\\test_signals.py",
        "matched template: handle a HTTP route request and return response (sim=0.30)"
      ]
    },
    {
      "name": "test_appcontext_signals",
      "description": "stream data over websocket. Function `test_appcontext_signals`.",
      "predicted_filename": "tests\\test_signals.py",
      "predicted_code_snippet": "def test_appcontext_signals(app, client):\n    recorded = []\n\n    def record_push(sender, **kwargs):\n        recorded.append(\"push\")\n\n    def record_pop(sender, **kwargs):\n        recorded.append(\"pop\")\n\n    @app.route(\"/\")\n    def index():\n        return \"Hello\"\n\n    flask.appcontext_pushed.connect(record_push, app)\n    flask.appcontext_popped.connect(record_pop, app)\n    try:\n        rv = client.get(\"/\")\n        assert rv.data == b\"Hello\"\n        assert recorded == [\"push\", \"pop\"]\n    finally:\n        flask.appcontext_pushed.disconnect(record_push, app)\n        flask.appcontext_popped.disconnect(record_pop, app)",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_appcontext_signals` in tests\\test_signals.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function test_appcontext_signals in tests\\test_signals.py",
        "matched template: stream data over websocket (sim=0.27)"
      ]
    },
    {
      "name": "test_flash_signal",
      "description": "stream data over websocket. Function `test_flash_signal`.",
      "predicted_filename": "tests\\test_signals.py",
      "predicted_code_snippet": "def test_flash_signal(app):\n    @app.route(\"/\")\n    def index():\n        flask.flash(\"This is a flash message\", category=\"notice\")\n        return flask.redirect(\"/other\")\n\n    recorded = []\n\n    def record(sender, message, category):\n        recorded.append((message, category))\n\n    flask.message_flashed.connect(record, app)\n    try:\n        client = app.test_client()\n        with client.session_transaction():\n            client.get(\"/\")\n            assert len(recorded) == 1\n            message, category = recorded[0]\n            assert message == \"This is a flash message\"\n            assert category == \"notice\"\n    finally:\n        flask.message_flashed.disconnect(record, app)",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_flash_signal` in tests\\test_signals.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function test_flash_signal in tests\\test_signals.py",
        "matched template: stream data over websocket (sim=0.25)"
      ]
    },
    {
      "name": "test_appcontext_tearing_down_signal",
      "description": "stream data over websocket. Function `test_appcontext_tearing_down_signal`.",
      "predicted_filename": "tests\\test_signals.py",
      "predicted_code_snippet": "def test_appcontext_tearing_down_signal(app, client):\n    app.testing = False\n    recorded = []\n\n    def record_teardown(sender, exc):\n        recorded.append(exc)\n\n    @app.route(\"/\")\n    def index():\n        raise ZeroDivisionError\n\n    flask.appcontext_tearing_down.connect(record_teardown, app)\n    try:\n        rv = client.get(\"/\")\n        assert rv.status_code == 500\n        assert len(recorded) == 1\n        assert isinstance(recorded[0], ZeroDivisionError)\n    finally:\n        flask.appcontext_tearing_down.disconnect(record_teardown, app)",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_appcontext_tearing_down_signal` in tests\\test_signals.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_appcontext_tearing_down_signal in tests\\test_signals.py",
        "matched template: stream data over websocket (sim=0.18)"
      ]
    },
    {
      "name": "test_suppressed_exception_logging",
      "description": "handle a HTTP route request and return response. Function `test_suppressed_exception_logging`.",
      "predicted_filename": "tests\\test_subclassing.py",
      "predicted_code_snippet": "def test_suppressed_exception_logging():\n    class SuppressedFlask(flask.Flask):\n        def log_exception(self, ctx, exc_info):\n            pass\n\n    out = StringIO()\n    app = SuppressedFlask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        raise Exception(\"test\")\n\n    rv = app.test_client().get(\"/\", errors_stream=out)\n    assert rv.status_code == 500\n    assert b\"Internal Server Error\" in rv.data\n    assert not out.getvalue()",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_suppressed_exception_logging` in tests\\test_subclassing.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_suppressed_exception_logging in tests\\test_subclassing.py",
        "matched template: handle a HTTP route request and return response (sim=0.19)"
      ]
    },
    {
      "name": "test_context_processing",
      "description": "handle a HTTP route request and return response. Function `test_context_processing`.",
      "predicted_filename": "tests\\test_templating.py",
      "predicted_code_snippet": "def test_context_processing(app, client):\n    @app.context_processor\n    def context_processor():\n        return {\"injected_value\": 42}\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"context_template.html\", value=23)\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"<p>23|42\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "injected_value": {
            "type": "integer"
          }
        },
        "required": [
          "injected_value"
        ]
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object",
          "properties": {
            "injected_value": {
              "type": "integer"
            }
          },
          "required": [
            "injected_value"
          ]
        }
      },
      "explanation": "Detected Python function `test_context_processing` in tests\\test_templating.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function test_context_processing in tests\\test_templating.py",
        "matched template: handle a HTTP route request and return response (sim=0.24)"
      ]
    },
    {
      "name": "test_original_win",
      "description": "handle a HTTP route request and return response. Function `test_original_win`.",
      "predicted_filename": "tests\\test_templating.py",
      "predicted_code_snippet": "def test_original_win(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.render_template_string(\"{{ config }}\", config=42)\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"42\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_original_win` in tests\\test_templating.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function test_original_win in tests\\test_templating.py",
        "matched template: handle a HTTP route request and return response (sim=0.26)"
      ]
    },
    {
      "name": "test_simple_stream",
      "description": "stream data over websocket. Function `test_simple_stream`.",
      "predicted_filename": "tests\\test_templating.py",
      "predicted_code_snippet": "def test_simple_stream(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.stream_template_string(\"{{ config }}\", config=42)\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"42\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_simple_stream` in tests\\test_templating.py",
      "possible_syscalls": [],
      "confidence": 0.25,
      "evidence": [
        "function test_simple_stream in tests\\test_templating.py",
        "matched template: stream data over websocket (sim=0.30)"
      ]
    },
    {
      "name": "test_request_less_rendering",
      "description": "handle a HTTP route request and return response. Function `test_request_less_rendering`.",
      "predicted_filename": "tests\\test_templating.py",
      "predicted_code_snippet": "def test_request_less_rendering(app, app_ctx):\n    app.config[\"WORLD_NAME\"] = \"Special World\"\n\n    @app.context_processor\n    def context_processor():\n        return dict(foo=42)\n\n    rv = flask.render_template_string(\"Hello {{ config.WORLD_NAME }} {{ foo }}\")\n    assert rv == \"Hello Special World 42\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "app_ctx": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "app_ctx"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "app_ctx": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_request_less_rendering` in tests\\test_templating.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function test_request_less_rendering in tests\\test_templating.py",
        "matched template: handle a HTTP route request and return response (sim=0.23)"
      ]
    },
    {
      "name": "test_standard_context",
      "description": "handle a HTTP route request and return response. Function `test_standard_context`.",
      "predicted_filename": "tests\\test_templating.py",
      "predicted_code_snippet": "def test_standard_context(app, client):\n    @app.route(\"/\")\n    def index():\n        flask.g.foo = 23\n        flask.session[\"test\"] = \"aha\"\n        return flask.render_template_string(\n            \"\"\"\n            {{ request.args.foo }}\n            {{ g.foo }}\n            {{ config.DEBUG }}\n            {{ session.test }}\n        \"\"\"\n        )\n\n    rv = client.get(\"/?foo=42\")\n    assert rv.data.split() == [b\"42\", b\"23\", b\"False\", b\"aha\"]",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_standard_context` in tests\\test_templating.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function test_standard_context in tests\\test_templating.py",
        "matched template: handle a HTTP route request and return response (sim=0.27)"
      ]
    },
    {
      "name": "test_escaping",
      "description": "handle a HTTP route request and return response. Function `test_escaping`.",
      "predicted_filename": "tests\\test_templating.py",
      "predicted_code_snippet": "def test_escaping(app, client):\n    text = \"<p>Hello World!\"\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\n            \"escaping_template.html\", text=text, html=Markup(text)\n        )\n\n    lines = client.get(\"/\").data.splitlines()\n    assert lines == [\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n    ]",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_escaping` in tests\\test_templating.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function test_escaping in tests\\test_templating.py",
        "matched template: handle a HTTP route request and return response (sim=0.24)"
      ]
    },
    {
      "name": "test_no_escaping",
      "description": "write data to a file. Function `test_no_escaping`.",
      "predicted_filename": "tests\\test_templating.py",
      "predicted_code_snippet": "def test_no_escaping(app, client):\n    text = \"<p>Hello World!\"\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\n            \"non_escaping_template.txt\", text=text, html=Markup(text)\n        )\n\n    lines = client.get(\"/\").data.splitlines()\n    assert lines == [\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n    ]",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_no_escaping` in tests\\test_templating.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function test_no_escaping in tests\\test_templating.py",
        "matched template: write data to a file (sim=0.28)"
      ]
    },
    {
      "name": "test_escaping_without_template_filename",
      "description": "write data to a file. Function `test_escaping_without_template_filename`.",
      "predicted_filename": "tests\\test_templating.py",
      "predicted_code_snippet": "def test_escaping_without_template_filename(app, client, req_ctx):\n    assert flask.render_template_string(\"{{ foo }}\", foo=\"<test>\") == \"&lt;test&gt;\"\n    assert flask.render_template(\"mail.txt\", foo=\"<test>\") == \"<test> Mail\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          },
          "req_ctx": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client",
          "req_ctx"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string",
          "req_ctx": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_escaping_without_template_filename` in tests\\test_templating.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function test_escaping_without_template_filename in tests\\test_templating.py",
        "matched template: write data to a file (sim=0.27)"
      ]
    },
    {
      "name": "test_macros",
      "description": "handle a HTTP route request and return response. Function `test_macros`.",
      "predicted_filename": "tests\\test_templating.py",
      "predicted_code_snippet": "def test_macros(app, req_ctx):\n    macro = flask.get_template_attribute(\"_macro.html\", \"hello\")\n    assert macro(\"World\") == \"Hello World!\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "req_ctx": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "req_ctx"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "req_ctx": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_macros` in tests\\test_templating.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_macros in tests\\test_templating.py",
        "matched template: handle a HTTP route request and return response (sim=0.19)"
      ]
    },
    {
      "name": "test_template_filter",
      "description": "compute cryptographic hash of input data. Function `test_template_filter`.",
      "predicted_filename": "tests\\test_templating.py",
      "predicted_code_snippet": "def test_template_filter(app):\n    @app.template_filter()\n    def my_reverse(s):\n        return s[::-1]\n\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n\n    @app.template_filter\n    def my_reverse_2(s):\n        return s[::-1]\n\n    assert \"my_reverse_2\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse_2\"] == my_reverse_2\n    assert app.jinja_env.filters[\"my_reverse_2\"](\"abcd\") == \"dcba\"\n\n    @app.template_filter(\"my_reverse_custom_name_3\")\n    def my_reverse_3(s):\n        return s[::-1]\n\n    assert \"my_reverse_custom_name_3\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse_custom_name_3\"] == my_reverse_3\n    assert app.jinja_env.filters[\"my_reverse_custom_name_3\"](\"abcd\") == \"dcba\"\n\n    @app.template_filter(name=\"my_reverse_custom_name_4\")\n    def my_reverse_4(s):\n        return s[::-1]\n\n    assert \"my_reverse_custom_name_4\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse_custom_name_4\"] == my_reverse_4\n    assert app.jinja_env.filters[\"my_reverse_custom_name_4\"](\"abcd\") == \"dcba\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_template_filter` in tests\\test_templating.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_template_filter in tests\\test_templating.py",
        "matched template: compute cryptographic hash of input data (sim=0.17)"
      ]
    },
    {
      "name": "test_add_template_filter",
      "description": "handle a HTTP route request and return response. Function `test_add_template_filter`.",
      "predicted_filename": "tests\\test_templating.py",
      "predicted_code_snippet": "def test_add_template_filter(app):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse)\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_add_template_filter` in tests\\test_templating.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function test_add_template_filter in tests\\test_templating.py",
        "matched template: handle a HTTP route request and return response (sim=0.23)"
      ]
    },
    {
      "name": "test_template_filter_with_name",
      "description": "handle a HTTP route request and return response. Function `test_template_filter_with_name`.",
      "predicted_filename": "tests\\test_templating.py",
      "predicted_code_snippet": "def test_template_filter_with_name(app):\n    @app.template_filter(\"strrev\")\n    def my_reverse(s):\n        return s[::-1]\n\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_template_filter_with_name` in tests\\test_templating.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function test_template_filter_with_name in tests\\test_templating.py",
        "matched template: handle a HTTP route request and return response (sim=0.20)"
      ]
    },
    {
      "name": "test_add_template_filter_with_name",
      "description": "handle a HTTP route request and return response. Function `test_add_template_filter_with_name`.",
      "predicted_filename": "tests\\test_templating.py",
      "predicted_code_snippet": "def test_add_template_filter_with_name(app):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse, \"strrev\")\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_add_template_filter_with_name` in tests\\test_templating.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_add_template_filter_with_name in tests\\test_templating.py",
        "matched template: handle a HTTP route request and return response (sim=0.18)"
      ]
    },
    {
      "name": "test_template_filter_with_template",
      "description": "handle a HTTP route request and return response. Function `test_template_filter_with_template`.",
      "predicted_filename": "tests\\test_templating.py",
      "predicted_code_snippet": "def test_template_filter_with_template(app, client):\n    @app.template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_template_filter_with_template` in tests\\test_templating.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function test_template_filter_with_template in tests\\test_templating.py",
        "matched template: handle a HTTP route request and return response (sim=0.26)"
      ]
    },
    {
      "name": "test_add_template_filter_with_template",
      "description": "handle a HTTP route request and return response. Function `test_add_template_filter_with_template`.",
      "predicted_filename": "tests\\test_templating.py",
      "predicted_code_snippet": "def test_add_template_filter_with_template(app, client):\n    def super_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(super_reverse)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_add_template_filter_with_template` in tests\\test_templating.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function test_add_template_filter_with_template in tests\\test_templating.py",
        "matched template: handle a HTTP route request and return response (sim=0.27)"
      ]
    },
    {
      "name": "test_template_filter_with_name_and_template",
      "description": "handle a HTTP route request and return response. Function `test_template_filter_with_name_and_template`.",
      "predicted_filename": "tests\\test_templating.py",
      "predicted_code_snippet": "def test_template_filter_with_name_and_template(app, client):\n    @app.template_filter(\"super_reverse\")\n    def my_reverse(s):\n        return s[::-1]\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_template_filter_with_name_and_template` in tests\\test_templating.py",
      "possible_syscalls": [],
      "confidence": 0.23,
      "evidence": [
        "function test_template_filter_with_name_and_template in tests\\test_templating.py",
        "matched template: handle a HTTP route request and return response (sim=0.27)"
      ]
    },
    {
      "name": "test_add_template_filter_with_name_and_template",
      "description": "handle a HTTP route request and return response. Function `test_add_template_filter_with_name_and_template`.",
      "predicted_filename": "tests\\test_templating.py",
      "predicted_code_snippet": "def test_add_template_filter_with_name_and_template(app, client):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse, \"super_reverse\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_add_template_filter_with_name_and_template` in tests\\test_templating.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function test_add_template_filter_with_name_and_template in tests\\test_templating.py",
        "matched template: handle a HTTP route request and return response (sim=0.25)"
      ]
    },
    {
      "name": "test_template_test",
      "description": "validate and sanitize user input. Function `test_template_test`.",
      "predicted_filename": "tests\\test_templating.py",
      "predicted_code_snippet": "def test_template_test(app):\n    @app.template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == boolean\n    assert app.jinja_env.tests[\"boolean\"](False)\n\n    @app.template_test\n    def boolean_2(value):\n        return isinstance(value, bool)\n\n    assert \"boolean_2\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean_2\"] == boolean_2\n    assert app.jinja_env.tests[\"boolean_2\"](False)\n\n    @app.template_test(\"my_boolean_custom_name\")\n    def boolean_3(value):\n        return isinstance(value, bool)\n\n    assert \"my_boolean_custom_name\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"my_boolean_custom_name\"] == boolean_3\n    assert app.jinja_env.tests[\"my_boolean_custom_name\"](False)\n\n    @app.template_test(name=\"my_boolean_custom_name_2\")\n    def boolean_4(value):\n        return isinstance(value, bool)\n\n    assert \"my_boolean_custom_name_2\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"my_boolean_custom_name_2\"] == boolean_4\n    assert app.jinja_env.tests[\"my_boolean_custom_name_2\"](False)",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_template_test` in tests\\test_templating.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_template_test in tests\\test_templating.py",
        "matched template: validate and sanitize user input (sim=0.17)"
      ]
    },
    {
      "name": "test_add_template_test",
      "description": "handle a HTTP route request and return response. Function `test_add_template_test`.",
      "predicted_filename": "tests\\test_templating.py",
      "predicted_code_snippet": "def test_add_template_test(app):\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(boolean)\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == boolean\n    assert app.jinja_env.tests[\"boolean\"](False)",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_add_template_test` in tests\\test_templating.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function test_add_template_test in tests\\test_templating.py",
        "matched template: handle a HTTP route request and return response (sim=0.16)"
      ]
    },
    {
      "name": "test_template_test_with_name",
      "description": "validate and sanitize user input. Function `test_template_test_with_name`.",
      "predicted_filename": "tests\\test_templating.py",
      "predicted_code_snippet": "def test_template_test_with_name(app):\n    @app.template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"boolean\"](False)",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_template_test_with_name` in tests\\test_templating.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function test_template_test_with_name in tests\\test_templating.py",
        "matched template: validate and sanitize user input (sim=0.16)"
      ]
    },
    {
      "name": "test_add_template_test_with_name",
      "description": "validate and sanitize user input. Function `test_add_template_test_with_name`.",
      "predicted_filename": "tests\\test_templating.py",
      "predicted_code_snippet": "def test_add_template_test_with_name(app):\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(is_boolean, \"boolean\")\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"boolean\"](False)",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_add_template_test_with_name` in tests\\test_templating.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function test_add_template_test_with_name in tests\\test_templating.py",
        "matched template: validate and sanitize user input (sim=0.16)"
      ]
    },
    {
      "name": "test_template_test_with_template",
      "description": "handle a HTTP route request and return response. Function `test_template_test_with_template`.",
      "predicted_filename": "tests\\test_templating.py",
      "predicted_code_snippet": "def test_template_test_with_template(app, client):\n    @app.template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_template_test_with_template` in tests\\test_templating.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function test_template_test_with_template in tests\\test_templating.py",
        "matched template: handle a HTTP route request and return response (sim=0.25)"
      ]
    },
    {
      "name": "test_add_template_test_with_template",
      "description": "handle a HTTP route request and return response. Function `test_add_template_test_with_template`.",
      "predicted_filename": "tests\\test_templating.py",
      "predicted_code_snippet": "def test_add_template_test_with_template(app, client):\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(boolean)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_add_template_test_with_template` in tests\\test_templating.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function test_add_template_test_with_template in tests\\test_templating.py",
        "matched template: handle a HTTP route request and return response (sim=0.25)"
      ]
    },
    {
      "name": "test_template_test_with_name_and_template",
      "description": "handle a HTTP route request and return response. Function `test_template_test_with_name_and_template`.",
      "predicted_filename": "tests\\test_templating.py",
      "predicted_code_snippet": "def test_template_test_with_name_and_template(app, client):\n    @app.template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_template_test_with_name_and_template` in tests\\test_templating.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function test_template_test_with_name_and_template in tests\\test_templating.py",
        "matched template: handle a HTTP route request and return response (sim=0.24)"
      ]
    },
    {
      "name": "test_add_template_test_with_name_and_template",
      "description": "handle a HTTP route request and return response. Function `test_add_template_test_with_name_and_template`.",
      "predicted_filename": "tests\\test_templating.py",
      "predicted_code_snippet": "def test_add_template_test_with_name_and_template(app, client):\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(is_boolean, \"boolean\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_add_template_test_with_name_and_template` in tests\\test_templating.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function test_add_template_test_with_name_and_template in tests\\test_templating.py",
        "matched template: handle a HTTP route request and return response (sim=0.21)"
      ]
    },
    {
      "name": "test_add_template_global",
      "description": "handle a HTTP route request and return response. Function `test_add_template_global`.",
      "predicted_filename": "tests\\test_templating.py",
      "predicted_code_snippet": "def test_add_template_global(app, app_ctx):\n    @app.template_global()\n    def get_stuff():\n        return 42\n\n    assert \"get_stuff\" in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals[\"get_stuff\"] == get_stuff\n    assert app.jinja_env.globals[\"get_stuff\"](), 42\n\n    rv = flask.render_template_string(\"{{ get_stuff() }}\")\n    assert rv == \"42\"\n\n    @app.template_global\n    def get_stuff_1():\n        return \"get_stuff_1\"\n\n    assert \"get_stuff_1\" in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals[\"get_stuff_1\"] == get_stuff_1\n    assert app.jinja_env.globals[\"get_stuff_1\"](), \"get_stuff_1\"\n\n    rv = flask.render_template_string(\"{{ get_stuff_1() }}\")\n    assert rv == \"get_stuff_1\"\n\n    @app.template_global(\"my_get_stuff_custom_name_2\")\n    def get_stuff_2():\n        return \"get_stuff_2\"\n\n    assert \"my_get_stuff_custom_name_2\" in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals[\"my_get_stuff_custom_name_2\"] == get_stuff_2\n    assert app.jinja_env.globals[\"my_get_stuff_custom_name_2\"](), \"get_stuff_2\"\n\n    rv = flask.render_template_string(\"{{ my_get_stuff_custom_name_2() }}\")\n    assert rv == \"get_stuff_2\"\n\n    @app.template_global(name=\"my_get_stuff_custom_name_3\")\n    def get_stuff_3():\n        return \"get_stuff_3\"\n\n    assert \"my_get_stuff_custom_name_3\" in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals[\"my_get_stuff_custom_name_3\"] == get_stuff_3\n    assert app.jinja_env.globals[\"my_get_stuff_custom_name_3\"](), \"get_stuff_3\"\n\n    rv = flask.render_template_string(\"{{ my_get_stuff_custom_name_3() }}\")\n    assert rv == \"get_stuff_3\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "app_ctx": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "app_ctx"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "app_ctx": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_add_template_global` in tests\\test_templating.py",
      "possible_syscalls": [],
      "confidence": 0.16,
      "evidence": [
        "function test_add_template_global in tests\\test_templating.py",
        "matched template: handle a HTTP route request and return response (sim=0.09)"
      ]
    },
    {
      "name": "test_custom_template_loader",
      "description": "handle a HTTP route request and return response. Function `test_custom_template_loader`.",
      "predicted_filename": "tests\\test_templating.py",
      "predicted_code_snippet": "def test_custom_template_loader(client):\n    class MyFlask(flask.Flask):\n        def create_global_jinja_loader(self):\n            from jinja2 import DictLoader\n\n            return DictLoader({\"index.html\": \"Hello Custom World!\"})\n\n    app = MyFlask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"index.html\")\n\n    c = app.test_client()\n    rv = c.get(\"/\")\n    assert rv.data == b\"Hello Custom World!\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_custom_template_loader` in tests\\test_templating.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function test_custom_template_loader in tests\\test_templating.py",
        "matched template: handle a HTTP route request and return response (sim=0.22)"
      ]
    },
    {
      "name": "test_iterable_loader",
      "description": "handle a HTTP route request and return response. Function `test_iterable_loader`.",
      "predicted_filename": "tests\\test_templating.py",
      "predicted_code_snippet": "def test_iterable_loader(app, client):\n    @app.context_processor\n    def context_processor():\n        return {\"whiskey\": \"Jameson\"}\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\n            [\n                \"no_template.xml\",  # should skip this one\n                \"simple_template.html\",  # should render this\n                \"context_template.html\",\n            ],\n            value=23,\n        )\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"<h1>Jameson</h1>\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object",
        "properties": {
          "whiskey": {
            "type": "string"
          }
        },
        "required": [
          "whiskey"
        ]
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object",
          "properties": {
            "whiskey": {
              "type": "string"
            }
          },
          "required": [
            "whiskey"
          ]
        }
      },
      "explanation": "Detected Python function `test_iterable_loader` in tests\\test_templating.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function test_iterable_loader in tests\\test_templating.py",
        "matched template: handle a HTTP route request and return response (sim=0.21)"
      ]
    },
    {
      "name": "test_templates_auto_reload",
      "description": "execute a shell command. Function `test_templates_auto_reload`.",
      "predicted_filename": "tests\\test_templating.py",
      "predicted_code_snippet": "def test_templates_auto_reload(app):\n    # debug is False, config option is None\n    assert app.debug is False\n    assert app.config[\"TEMPLATES_AUTO_RELOAD\"] is None\n    assert app.jinja_env.auto_reload is False\n    # debug is False, config option is False\n    app = flask.Flask(__name__)\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = False\n    assert app.debug is False\n    assert app.jinja_env.auto_reload is False\n    # debug is False, config option is True\n    app = flask.Flask(__name__)\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = True\n    assert app.debug is False\n    assert app.jinja_env.auto_reload is True\n    # debug is True, config option is None\n    app = flask.Flask(__name__)\n    app.config[\"DEBUG\"] = True\n    assert app.config[\"TEMPLATES_AUTO_RELOAD\"] is None\n    assert app.jinja_env.auto_reload is True\n    # debug is True, config option is False\n    app = flask.Flask(__name__)\n    app.config[\"DEBUG\"] = True\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = False\n    assert app.jinja_env.auto_reload is False\n    # debug is True, config option is True\n    app = flask.Flask(__name__)\n    app.config[\"DEBUG\"] = True\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = True\n    assert app.jinja_env.auto_reload is True",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_templates_auto_reload` in tests\\test_templating.py",
      "possible_syscalls": [],
      "confidence": 0.16,
      "evidence": [
        "function test_templates_auto_reload in tests\\test_templating.py",
        "matched template: execute a shell command (sim=0.06)"
      ]
    },
    {
      "name": "test_templates_auto_reload_debug_run",
      "description": "cache results to disk or memory. Function `test_templates_auto_reload_debug_run`.",
      "predicted_filename": "tests\\test_templating.py",
      "predicted_code_snippet": "def test_templates_auto_reload_debug_run(app, monkeypatch):\n    def run_simple_mock(*args, **kwargs):\n        pass\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n\n    app.run()\n    assert not app.jinja_env.auto_reload\n\n    app.run(debug=True)\n    assert app.jinja_env.auto_reload",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "monkeypatch": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "monkeypatch"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "monkeypatch": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_templates_auto_reload_debug_run` in tests\\test_templating.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function test_templates_auto_reload_debug_run in tests\\test_templating.py",
        "matched template: cache results to disk or memory (sim=0.15)"
      ]
    },
    {
      "name": "test_template_loader_debugging",
      "description": "write data to a file. Function `test_template_loader_debugging`.",
      "predicted_filename": "tests\\test_templating.py",
      "predicted_code_snippet": "def test_template_loader_debugging(test_apps, monkeypatch):\n    from blueprintapp import app\n\n    called = []\n\n    class _TestHandler(logging.Handler):\n        def handle(self, record):\n            called.append(True)\n            text = str(record.msg)\n            assert \"1: trying loader of application 'blueprintapp'\" in text\n            assert (\n                \"2: trying loader of blueprint 'admin' (blueprintapp.apps.admin)\"\n            ) in text\n            assert (\n                \"trying loader of blueprint 'frontend' (blueprintapp.apps.frontend)\"\n            ) in text\n            assert \"Error: the template could not be found\" in text\n            assert (\n                \"looked up from an endpoint that belongs to the blueprint 'frontend'\"\n            ) in text\n            assert \"See https://flask.palletsprojects.com/blueprints/#templates\" in text\n\n    with app.test_client() as c:\n        monkeypatch.setitem(app.config, \"EXPLAIN_TEMPLATE_LOADING\", True)\n        monkeypatch.setattr(\n            logging.getLogger(\"blueprintapp\"), \"handlers\", [_TestHandler()]\n        )\n\n        with pytest.raises(TemplateNotFound) as excinfo:\n            c.get(\"/missing\")\n\n        assert \"missing_template.html\" in str(excinfo.value)\n\n    assert len(called) == 1",
      "input_schema": {
        "type": "object",
        "properties": {
          "test_apps": {
            "type": "string",
            "required": true
          },
          "monkeypatch": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "test_apps",
          "monkeypatch"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "test_apps": "string",
          "monkeypatch": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_template_loader_debugging` in tests\\test_templating.py",
      "possible_syscalls": [],
      "confidence": 0.16,
      "evidence": [
        "function test_template_loader_debugging in tests\\test_templating.py",
        "matched template: write data to a file (sim=0.09)"
      ]
    },
    {
      "name": "test_custom_jinja_env",
      "description": "handle a HTTP route request and return response. Function `test_custom_jinja_env`.",
      "predicted_filename": "tests\\test_templating.py",
      "predicted_code_snippet": "def test_custom_jinja_env():\n    class CustomEnvironment(flask.templating.Environment):\n        pass\n\n    class CustomFlask(flask.Flask):\n        jinja_environment = CustomEnvironment\n\n    app = CustomFlask(__name__)\n    assert isinstance(app.jinja_env, CustomEnvironment)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_custom_jinja_env` in tests\\test_templating.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_custom_jinja_env in tests\\test_templating.py",
        "matched template: handle a HTTP route request and return response (sim=0.20)"
      ]
    },
    {
      "name": "test_environ_defaults_from_config",
      "description": "handle a HTTP route request and return response. Function `test_environ_defaults_from_config`.",
      "predicted_filename": "tests\\test_testing.py",
      "predicted_code_snippet": "def test_environ_defaults_from_config(app, client):\n    app.config[\"SERVER_NAME\"] = \"example.com:1234\"\n    app.config[\"APPLICATION_ROOT\"] = \"/foo\"\n\n    @app.route(\"/\")\n    def index():\n        return flask.request.url\n\n    ctx = app.test_request_context()\n    assert ctx.request.url == \"http://example.com:1234/foo/\"\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"http://example.com:1234/foo/\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_environ_defaults_from_config` in tests\\test_testing.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.22,
      "evidence": [
        "function test_environ_defaults_from_config in tests\\test_testing.py",
        "matched template: handle a HTTP route request and return response (sim=0.24)"
      ]
    },
    {
      "name": "test_environ_defaults",
      "description": "handle a HTTP route request and return response. Function `test_environ_defaults`.",
      "predicted_filename": "tests\\test_testing.py",
      "predicted_code_snippet": "def test_environ_defaults(app, client, app_ctx, req_ctx):\n    @app.route(\"/\")\n    def index():\n        return flask.request.url\n\n    ctx = app.test_request_context()\n    assert ctx.request.url == \"http://localhost/\"\n    with client:\n        rv = client.get(\"/\")\n        assert rv.data == b\"http://localhost/\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          },
          "app_ctx": {
            "type": "string",
            "required": true
          },
          "req_ctx": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client",
          "app_ctx",
          "req_ctx"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string",
          "app_ctx": "string",
          "req_ctx": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_environ_defaults` in tests\\test_testing.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.22,
      "evidence": [
        "function test_environ_defaults in tests\\test_testing.py",
        "matched template: handle a HTTP route request and return response (sim=0.24)"
      ]
    },
    {
      "name": "test_environ_base_default",
      "description": "make an HTTP request to an external API. Function `test_environ_base_default`.",
      "predicted_filename": "tests\\test_testing.py",
      "predicted_code_snippet": "def test_environ_base_default(app, client):\n    @app.route(\"/\")\n    def index():\n        flask.g.remote_addr = flask.request.remote_addr\n        flask.g.user_agent = flask.request.user_agent.string\n        return \"\"\n\n    with client:\n        client.get(\"/\")\n        assert flask.g.remote_addr == \"127.0.0.1\"\n        assert flask.g.user_agent == (\n            f\"Werkzeug/{importlib.metadata.version('werkzeug')}\"\n        )",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_environ_base_default` in tests\\test_testing.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.19,
      "evidence": [
        "function test_environ_base_default in tests\\test_testing.py",
        "matched template: make an HTTP request to an external API (sim=0.18)"
      ]
    },
    {
      "name": "test_environ_base_modified",
      "description": "make an HTTP request to an external API. Function `test_environ_base_modified`.",
      "predicted_filename": "tests\\test_testing.py",
      "predicted_code_snippet": "def test_environ_base_modified(app, client):\n    @app.route(\"/\")\n    def index():\n        flask.g.remote_addr = flask.request.remote_addr\n        flask.g.user_agent = flask.request.user_agent.string\n        return \"\"\n\n    client.environ_base[\"REMOTE_ADDR\"] = \"192.168.0.22\"\n    client.environ_base[\"HTTP_USER_AGENT\"] = \"Foo\"\n\n    with client:\n        client.get(\"/\")\n        assert flask.g.remote_addr == \"192.168.0.22\"\n        assert flask.g.user_agent == \"Foo\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_environ_base_modified` in tests\\test_testing.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.21,
      "evidence": [
        "function test_environ_base_modified in tests\\test_testing.py",
        "matched template: make an HTTP request to an external API (sim=0.24)"
      ]
    },
    {
      "name": "test_client_open_environ",
      "description": "make an HTTP request to an external API. Function `test_client_open_environ`.",
      "predicted_filename": "tests\\test_testing.py",
      "predicted_code_snippet": "def test_client_open_environ(app, client, request):\n    @app.route(\"/index\")\n    def index():\n        return flask.request.remote_addr\n\n    builder = EnvironBuilder(app, path=\"/index\", method=\"GET\")\n    request.addfinalizer(builder.close)\n\n    rv = client.open(builder)\n    assert rv.data == b\"127.0.0.1\"\n\n    environ = builder.get_environ()\n    client.environ_base[\"REMOTE_ADDR\"] = \"127.0.0.2\"\n    rv = client.open(environ)\n    assert rv.data == b\"127.0.0.2\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          },
          "request": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client",
          "request"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string",
          "request": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_client_open_environ` in tests\\test_testing.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.22,
      "evidence": [
        "function test_client_open_environ in tests\\test_testing.py",
        "matched template: make an HTTP request to an external API (sim=0.26)"
      ]
    },
    {
      "name": "test_specify_url_scheme",
      "description": "handle a HTTP route request and return response. Function `test_specify_url_scheme`.",
      "predicted_filename": "tests\\test_testing.py",
      "predicted_code_snippet": "def test_specify_url_scheme(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.request.url\n\n    ctx = app.test_request_context(url_scheme=\"https\")\n    assert ctx.request.url == \"https://localhost/\"\n\n    rv = client.get(\"/\", url_scheme=\"https\")\n    assert rv.data == b\"https://localhost/\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_specify_url_scheme` in tests\\test_testing.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.24,
      "evidence": [
        "function test_specify_url_scheme in tests\\test_testing.py",
        "matched template: handle a HTTP route request and return response (sim=0.29)"
      ]
    },
    {
      "name": "test_path_is_url",
      "description": "make an HTTP request to an external API. Function `test_path_is_url`.",
      "predicted_filename": "tests\\test_testing.py",
      "predicted_code_snippet": "def test_path_is_url(app):\n    eb = EnvironBuilder(app, \"https://example.com/\")\n    assert eb.url_scheme == \"https\"\n    assert eb.host == \"example.com\"\n    assert eb.script_root == \"\"\n    assert eb.path == \"/\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_path_is_url` in tests\\test_testing.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.23,
      "evidence": [
        "function test_path_is_url in tests\\test_testing.py",
        "matched template: make an HTTP request to an external API (sim=0.28)"
      ]
    },
    {
      "name": "test_environbuilder_json_dumps",
      "description": "parse JSON input and validate fields. Function `test_environbuilder_json_dumps`.",
      "predicted_filename": "tests\\test_testing.py",
      "predicted_code_snippet": "def test_environbuilder_json_dumps(app):\n    \"\"\"EnvironBuilder.json_dumps() takes settings from the app.\"\"\"\n    app.json.ensure_ascii = False\n    eb = EnvironBuilder(app, json=\"\\u20ac\")\n    assert eb.input_stream.read().decode(\"utf8\") == '\"\\u20ac\"'",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_environbuilder_json_dumps` in tests\\test_testing.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.23,
      "evidence": [
        "function test_environbuilder_json_dumps in tests\\test_testing.py",
        "matched template: parse JSON input and validate fields (sim=0.26)"
      ]
    },
    {
      "name": "test_blueprint_with_subdomain",
      "description": "handle a HTTP route request and return response. Function `test_blueprint_with_subdomain`.",
      "predicted_filename": "tests\\test_testing.py",
      "predicted_code_snippet": "def test_blueprint_with_subdomain():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"example.com:1234\"\n    app.config[\"APPLICATION_ROOT\"] = \"/foo\"\n    client = app.test_client()\n\n    bp = flask.Blueprint(\"company\", __name__, subdomain=\"xxx\")\n\n    @bp.route(\"/\")\n    def index():\n        return flask.request.url\n\n    app.register_blueprint(bp)\n\n    ctx = app.test_request_context(\"/\", subdomain=\"xxx\")\n    assert ctx.request.url == \"http://xxx.example.com:1234/foo/\"\n\n    with ctx:\n        assert ctx.request.blueprint == bp.name\n\n    rv = client.get(\"/\", subdomain=\"xxx\")\n    assert rv.data == b\"http://xxx.example.com:1234/foo/\"",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_blueprint_with_subdomain` in tests\\test_testing.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.23,
      "evidence": [
        "function test_blueprint_with_subdomain in tests\\test_testing.py",
        "matched template: handle a HTTP route request and return response (sim=0.27)"
      ]
    },
    {
      "name": "test_redirect_session",
      "description": "handle a HTTP route request and return response. Function `test_redirect_session`.",
      "predicted_filename": "tests\\test_testing.py",
      "predicted_code_snippet": "def test_redirect_session(app, client, app_ctx):\n    @app.route(\"/redirect\")\n    def index():\n        flask.session[\"redirect\"] = True\n        return flask.redirect(\"/target\")\n\n    @app.route(\"/target\")\n    def get_session():\n        flask.session[\"target\"] = True\n        return \"\"\n\n    with client:\n        client.get(\"/redirect\", follow_redirects=True)\n        assert flask.session[\"redirect\"] is True\n        assert flask.session[\"target\"] is True",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          },
          "app_ctx": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client",
          "app_ctx"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string",
          "app_ctx": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_redirect_session` in tests\\test_testing.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.23,
      "evidence": [
        "function test_redirect_session in tests\\test_testing.py",
        "matched template: handle a HTTP route request and return response (sim=0.27)"
      ]
    },
    {
      "name": "test_session_transactions",
      "description": "stream data over websocket. Function `test_session_transactions`.",
      "predicted_filename": "tests\\test_testing.py",
      "predicted_code_snippet": "def test_session_transactions(app, client):\n    @app.route(\"/\")\n    def index():\n        return str(flask.session[\"foo\"])\n\n    with client:\n        with client.session_transaction() as sess:\n            assert len(sess) == 0\n            sess[\"foo\"] = [42]\n            assert len(sess) == 1\n        rv = client.get(\"/\")\n        assert rv.data == b\"[42]\"\n        with client.session_transaction() as sess:\n            assert len(sess) == 1\n            assert sess[\"foo\"] == [42]",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_session_transactions` in tests\\test_testing.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.2,
      "evidence": [
        "function test_session_transactions in tests\\test_testing.py",
        "matched template: stream data over websocket (sim=0.20)"
      ]
    },
    {
      "name": "test_session_transactions_no_null_sessions",
      "description": "authenticate a user and return a token. Function `test_session_transactions_no_null_sessions`.",
      "predicted_filename": "tests\\test_testing.py",
      "predicted_code_snippet": "def test_session_transactions_no_null_sessions():\n    app = flask.Flask(__name__)\n\n    with app.test_client() as c:\n        with pytest.raises(RuntimeError) as e:\n            with c.session_transaction():\n                pass\n        assert \"Session backend did not open a session\" in str(e.value)",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_session_transactions_no_null_sessions` in tests\\test_testing.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.2,
      "evidence": [
        "function test_session_transactions_no_null_sessions in tests\\test_testing.py",
        "matched template: authenticate a user and return a token (sim=0.20)"
      ]
    },
    {
      "name": "test_session_transactions_keep_context",
      "description": "stream data over websocket. Function `test_session_transactions_keep_context`.",
      "predicted_filename": "tests\\test_testing.py",
      "predicted_code_snippet": "def test_session_transactions_keep_context(app, client, req_ctx):\n    client.get(\"/\")\n    req = flask.request._get_current_object()\n    assert req is not None\n    with client.session_transaction():\n        assert req is flask.request._get_current_object()",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          },
          "req_ctx": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client",
          "req_ctx"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string",
          "req_ctx": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_session_transactions_keep_context` in tests\\test_testing.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.19,
      "evidence": [
        "function test_session_transactions_keep_context in tests\\test_testing.py",
        "matched template: stream data over websocket (sim=0.19)"
      ]
    },
    {
      "name": "test_session_transaction_needs_cookies",
      "description": "authenticate a user and return a token. Function `test_session_transaction_needs_cookies`.",
      "predicted_filename": "tests\\test_testing.py",
      "predicted_code_snippet": "def test_session_transaction_needs_cookies(app):\n    c = app.test_client(use_cookies=False)\n\n    with pytest.raises(TypeError, match=\"Cookies are disabled.\"):\n        with c.session_transaction():\n            pass",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_session_transaction_needs_cookies` in tests\\test_testing.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.2,
      "evidence": [
        "function test_session_transaction_needs_cookies in tests\\test_testing.py",
        "matched template: authenticate a user and return a token (sim=0.22)"
      ]
    },
    {
      "name": "test_test_client_context_binding",
      "description": "handle a HTTP route request and return response. Function `test_test_client_context_binding`.",
      "predicted_filename": "tests\\test_testing.py",
      "predicted_code_snippet": "def test_test_client_context_binding(app, client):\n    app.testing = False\n\n    @app.route(\"/\")\n    def index():\n        flask.g.value = 42\n        return \"Hello World!\"\n\n    @app.route(\"/other\")\n    def other():\n        raise ZeroDivisionError\n\n    with client:\n        resp = client.get(\"/\")\n        assert flask.g.value == 42\n        assert resp.data == b\"Hello World!\"\n        assert resp.status_code == 200\n\n    with client:\n        resp = client.get(\"/other\")\n        assert not hasattr(flask.g, \"value\")\n        assert b\"Internal Server Error\" in resp.data\n        assert resp.status_code == 500\n        flask.g.value = 23\n\n    with pytest.raises(RuntimeError):\n        flask.g.value",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_test_client_context_binding` in tests\\test_testing.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.2,
      "evidence": [
        "function test_test_client_context_binding in tests\\test_testing.py",
        "matched template: handle a HTTP route request and return response (sim=0.21)"
      ]
    },
    {
      "name": "test_reuse_client",
      "description": "handle a HTTP route request and return response. Function `test_reuse_client`.",
      "predicted_filename": "tests\\test_testing.py",
      "predicted_code_snippet": "def test_reuse_client(client):\n    c = client\n\n    with c:\n        assert client.get(\"/\").status_code == 404\n\n    with c:\n        assert client.get(\"/\").status_code == 404",
      "input_schema": {
        "type": "object",
        "properties": {
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_reuse_client` in tests\\test_testing.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.21,
      "evidence": [
        "function test_reuse_client in tests\\test_testing.py",
        "matched template: handle a HTTP route request and return response (sim=0.24)"
      ]
    },
    {
      "name": "test_full_url_request",
      "description": "handle a HTTP route request and return response. Function `test_full_url_request`.",
      "predicted_filename": "tests\\test_testing.py",
      "predicted_code_snippet": "def test_full_url_request(app, client):\n    @app.route(\"/action\", methods=[\"POST\"])\n    def action():\n        return \"x\"\n\n    with client:\n        rv = client.post(\"http://domain.com/action?vodka=42\", data={\"gin\": 43})\n        assert rv.status_code == 200\n        assert \"gin\" in flask.request.form\n        assert \"vodka\" in flask.request.args",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_full_url_request` in tests\\test_testing.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.24,
      "evidence": [
        "function test_full_url_request in tests\\test_testing.py",
        "matched template: handle a HTTP route request and return response (sim=0.30)"
      ]
    },
    {
      "name": "test_json_request_and_response",
      "description": "parse JSON input and validate fields. Function `test_json_request_and_response`.",
      "predicted_filename": "tests\\test_testing.py",
      "predicted_code_snippet": "def test_json_request_and_response(app, client):\n    @app.route(\"/echo\", methods=[\"POST\"])\n    def echo():\n        return jsonify(flask.request.get_json())\n\n    with client:\n        json_data = {\"drink\": {\"gin\": 1, \"tonic\": True}, \"price\": 10}\n        rv = client.post(\"/echo\", json=json_data)\n\n        # Request should be in JSON\n        assert flask.request.is_json\n        assert flask.request.get_json() == json_data\n\n        # Response should be in JSON\n        assert rv.status_code == 200\n        assert rv.is_json\n        assert rv.get_json() == json_data",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_json_request_and_response` in tests\\test_testing.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.24,
      "evidence": [
        "function test_json_request_and_response in tests\\test_testing.py",
        "matched template: parse JSON input and validate fields (sim=0.29)"
      ]
    },
    {
      "name": "test_client_json_no_app_context",
      "description": "make an HTTP request to an external API. Function `test_client_json_no_app_context`.",
      "predicted_filename": "tests\\test_testing.py",
      "predicted_code_snippet": "def test_client_json_no_app_context(app, client):\n    @app.route(\"/hello\", methods=[\"POST\"])\n    def hello():\n        return f\"Hello, {flask.request.json['name']}!\"\n\n    class Namespace:\n        count = 0\n\n        def add(self, app):\n            self.count += 1\n\n    ns = Namespace()\n\n    with appcontext_popped.connected_to(ns.add, app):\n        rv = client.post(\"/hello\", json={\"name\": \"Flask\"})\n\n    assert rv.get_data(as_text=True) == \"Hello, Flask!\"\n    assert ns.count == 1",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_client_json_no_app_context` in tests\\test_testing.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.22,
      "evidence": [
        "function test_client_json_no_app_context in tests\\test_testing.py",
        "matched template: make an HTTP request to an external API (sim=0.26)"
      ]
    },
    {
      "name": "test_subdomain",
      "description": "handle a HTTP route request and return response. Function `test_subdomain`.",
      "predicted_filename": "tests\\test_testing.py",
      "predicted_code_snippet": "def test_subdomain():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"example.com\"\n    client = app.test_client()\n\n    @app.route(\"/\", subdomain=\"<company_id>\")\n    def view(company_id):\n        return company_id\n\n    with app.test_request_context():\n        url = flask.url_for(\"view\", company_id=\"xxx\")\n\n    with client:\n        response = client.get(url)\n\n    assert 200 == response.status_code\n    assert b\"xxx\" == response.data",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_subdomain` in tests\\test_testing.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.21,
      "evidence": [
        "function test_subdomain in tests\\test_testing.py",
        "matched template: handle a HTTP route request and return response (sim=0.23)"
      ]
    },
    {
      "name": "test_nosubdomain",
      "description": "stream data over websocket. Function `test_nosubdomain`.",
      "predicted_filename": "tests\\test_testing.py",
      "predicted_code_snippet": "def test_nosubdomain(app, client):\n    app.config[\"SERVER_NAME\"] = \"example.com\"\n\n    @app.route(\"/<company_id>\")\n    def view(company_id):\n        return company_id\n\n    with app.test_request_context():\n        url = flask.url_for(\"view\", company_id=\"xxx\")\n\n    with client:\n        response = client.get(url)\n\n    assert 200 == response.status_code\n    assert b\"xxx\" == response.data",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_nosubdomain` in tests\\test_testing.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.19,
      "evidence": [
        "function test_nosubdomain in tests\\test_testing.py",
        "matched template: stream data over websocket (sim=0.19)"
      ]
    },
    {
      "name": "test_cli_runner_class",
      "description": "parse JSON input and validate fields. Function `test_cli_runner_class`.",
      "predicted_filename": "tests\\test_testing.py",
      "predicted_code_snippet": "def test_cli_runner_class(app):\n    runner = app.test_cli_runner()\n    assert isinstance(runner, FlaskCliRunner)\n\n    class SubRunner(FlaskCliRunner):\n        pass\n\n    app.test_cli_runner_class = SubRunner\n    runner = app.test_cli_runner()\n    assert isinstance(runner, SubRunner)",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_cli_runner_class` in tests\\test_testing.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.19,
      "evidence": [
        "function test_cli_runner_class in tests\\test_testing.py",
        "matched template: parse JSON input and validate fields (sim=0.19)"
      ]
    },
    {
      "name": "test_cli_invoke",
      "description": "execute a shell command. Function `test_cli_invoke`.",
      "predicted_filename": "tests\\test_testing.py",
      "predicted_code_snippet": "def test_cli_invoke(app):\n    @app.cli.command(\"hello\")\n    def hello_command():\n        click.echo(\"Hello, World!\")\n\n    runner = app.test_cli_runner()\n    # invoke with command name\n    result = runner.invoke(args=[\"hello\"])\n    assert \"Hello\" in result.output\n    # invoke with command object\n    result = runner.invoke(hello_command)\n    assert \"Hello\" in result.output",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_cli_invoke` in tests\\test_testing.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.26,
      "evidence": [
        "function test_cli_invoke in tests\\test_testing.py",
        "matched template: execute a shell command (sim=0.33)"
      ]
    },
    {
      "name": "test_cli_custom_obj",
      "description": "execute a shell command. Function `test_cli_custom_obj`.",
      "predicted_filename": "tests\\test_testing.py",
      "predicted_code_snippet": "def test_cli_custom_obj(app):\n    class NS:\n        called = False\n\n    def create_app():\n        NS.called = True\n        return app\n\n    @app.cli.command(\"hello\")\n    def hello_command():\n        click.echo(\"Hello, World!\")\n\n    script_info = ScriptInfo(create_app=create_app)\n    runner = app.test_cli_runner()\n    runner.invoke(hello_command, obj=script_info)\n    assert NS.called",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_cli_custom_obj` in tests\\test_testing.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.23,
      "evidence": [
        "function test_cli_custom_obj in tests\\test_testing.py",
        "matched template: execute a shell command (sim=0.27)"
      ]
    },
    {
      "name": "test_client_pop_all_preserved",
      "description": "stream data over websocket. Function `test_client_pop_all_preserved`.",
      "predicted_filename": "tests\\test_testing.py",
      "predicted_code_snippet": "def test_client_pop_all_preserved(app, req_ctx, client):\n    @app.route(\"/\")\n    def index():\n        # stream_with_context pushes a third context, preserved by response\n        return flask.stream_with_context(\"hello\")\n\n    # req_ctx fixture pushed an initial context\n    with client:\n        # request pushes a second request context, preserved by client\n        rv = client.get(\"/\")\n\n    # close the response, releasing the context held by stream_with_context\n    rv.close()\n    # only req_ctx fixture should still be pushed\n    assert _cv_app.get(None) is req_ctx",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "req_ctx": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "req_ctx",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "req_ctx": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_client_pop_all_preserved` in tests\\test_testing.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.24,
      "evidence": [
        "function test_client_pop_all_preserved in tests\\test_testing.py",
        "matched template: stream data over websocket (sim=0.29)"
      ]
    },
    {
      "name": "test_error_handler_no_match",
      "description": "validate and sanitize user input. Function `test_error_handler_no_match`.",
      "predicted_filename": "tests\\test_user_error_handler.py",
      "predicted_code_snippet": "def test_error_handler_no_match(app, client):\n    class CustomException(Exception):\n        pass\n\n    @app.errorhandler(CustomException)\n    def custom_exception_handler(e):\n        assert isinstance(e, CustomException)\n        return \"custom\"\n\n    with pytest.raises(TypeError) as exc_info:\n        app.register_error_handler(CustomException(), None)\n\n    assert \"CustomException() is an instance, not a class.\" in str(exc_info.value)\n\n    with pytest.raises(ValueError) as exc_info:\n        app.register_error_handler(list, None)\n\n    assert \"'list' is not a subclass of Exception.\" in str(exc_info.value)\n\n    @app.errorhandler(500)\n    def handle_500(e):\n        assert isinstance(e, InternalServerError)\n\n        if e.original_exception is not None:\n            return f\"wrapped {type(e.original_exception).__name__}\"\n\n        return \"direct\"\n\n    with pytest.raises(ValueError) as exc_info:\n        app.register_error_handler(999, None)\n\n    assert \"Use a subclass of HTTPException\" in str(exc_info.value)\n\n    @app.route(\"/custom\")\n    def custom_test():\n        raise CustomException()\n\n    @app.route(\"/keyerror\")\n    def key_error():\n        raise KeyError()\n\n    @app.route(\"/abort\")\n    def do_abort():\n        flask.abort(500)\n\n    app.testing = False\n    assert client.get(\"/custom\").data == b\"custom\"\n    assert client.get(\"/keyerror\").data == b\"wrapped KeyError\"\n    assert client.get(\"/abort\").data == b\"direct\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_error_handler_no_match` in tests\\test_user_error_handler.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function test_error_handler_no_match in tests\\test_user_error_handler.py",
        "matched template: validate and sanitize user input (sim=0.14)"
      ]
    },
    {
      "name": "test_error_handler_subclass",
      "description": "handle a HTTP route request and return response. Function `test_error_handler_subclass`.",
      "predicted_filename": "tests\\test_user_error_handler.py",
      "predicted_code_snippet": "def test_error_handler_subclass(app):\n    class ParentException(Exception):\n        pass\n\n    class ChildExceptionUnregistered(ParentException):\n        pass\n\n    class ChildExceptionRegistered(ParentException):\n        pass\n\n    @app.errorhandler(ParentException)\n    def parent_exception_handler(e):\n        assert isinstance(e, ParentException)\n        return \"parent\"\n\n    @app.errorhandler(ChildExceptionRegistered)\n    def child_exception_handler(e):\n        assert isinstance(e, ChildExceptionRegistered)\n        return \"child-registered\"\n\n    @app.route(\"/parent\")\n    def parent_test():\n        raise ParentException()\n\n    @app.route(\"/child-unregistered\")\n    def unregistered_test():\n        raise ChildExceptionUnregistered()\n\n    @app.route(\"/child-registered\")\n    def registered_test():\n        raise ChildExceptionRegistered()\n\n    c = app.test_client()\n\n    assert c.get(\"/parent\").data == b\"parent\"\n    assert c.get(\"/child-unregistered\").data == b\"parent\"\n    assert c.get(\"/child-registered\").data == b\"child-registered\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_error_handler_subclass` in tests\\test_user_error_handler.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function test_error_handler_subclass in tests\\test_user_error_handler.py",
        "matched template: handle a HTTP route request and return response (sim=0.19)"
      ]
    },
    {
      "name": "test_error_handler_http_subclass",
      "description": "handle a HTTP route request and return response. Function `test_error_handler_http_subclass`.",
      "predicted_filename": "tests\\test_user_error_handler.py",
      "predicted_code_snippet": "def test_error_handler_http_subclass(app):\n    class ForbiddenSubclassRegistered(Forbidden):\n        pass\n\n    class ForbiddenSubclassUnregistered(Forbidden):\n        pass\n\n    @app.errorhandler(403)\n    def code_exception_handler(e):\n        assert isinstance(e, Forbidden)\n        return \"forbidden\"\n\n    @app.errorhandler(ForbiddenSubclassRegistered)\n    def subclass_exception_handler(e):\n        assert isinstance(e, ForbiddenSubclassRegistered)\n        return \"forbidden-registered\"\n\n    @app.route(\"/forbidden\")\n    def forbidden_test():\n        raise Forbidden()\n\n    @app.route(\"/forbidden-registered\")\n    def registered_test():\n        raise ForbiddenSubclassRegistered()\n\n    @app.route(\"/forbidden-unregistered\")\n    def unregistered_test():\n        raise ForbiddenSubclassUnregistered()\n\n    c = app.test_client()\n\n    assert c.get(\"/forbidden\").data == b\"forbidden\"\n    assert c.get(\"/forbidden-unregistered\").data == b\"forbidden\"\n    assert c.get(\"/forbidden-registered\").data == b\"forbidden-registered\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_error_handler_http_subclass` in tests\\test_user_error_handler.py",
      "possible_syscalls": [],
      "confidence": 0.25,
      "evidence": [
        "function test_error_handler_http_subclass in tests\\test_user_error_handler.py",
        "matched template: handle a HTTP route request and return response (sim=0.30)"
      ]
    },
    {
      "name": "test_error_handler_blueprint",
      "description": "handle a HTTP route request and return response. Function `test_error_handler_blueprint`.",
      "predicted_filename": "tests\\test_user_error_handler.py",
      "predicted_code_snippet": "def test_error_handler_blueprint(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.errorhandler(500)\n    def bp_exception_handler(e):\n        return \"bp-error\"\n\n    @bp.route(\"/error\")\n    def bp_test():\n        raise InternalServerError()\n\n    @app.errorhandler(500)\n    def app_exception_handler(e):\n        return \"app-error\"\n\n    @app.route(\"/error\")\n    def app_test():\n        raise InternalServerError()\n\n    app.register_blueprint(bp, url_prefix=\"/bp\")\n\n    c = app.test_client()\n\n    assert c.get(\"/error\").data == b\"app-error\"\n    assert c.get(\"/bp/error\").data == b\"bp-error\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_error_handler_blueprint` in tests\\test_user_error_handler.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function test_error_handler_blueprint in tests\\test_user_error_handler.py",
        "matched template: handle a HTTP route request and return response (sim=0.25)"
      ]
    },
    {
      "name": "test_default_error_handler",
      "description": "handle a HTTP route request and return response. Function `test_default_error_handler`.",
      "predicted_filename": "tests\\test_user_error_handler.py",
      "predicted_code_snippet": "def test_default_error_handler():\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.errorhandler(HTTPException)\n    def bp_exception_handler(e):\n        assert isinstance(e, HTTPException)\n        assert isinstance(e, NotFound)\n        return \"bp-default\"\n\n    @bp.errorhandler(Forbidden)\n    def bp_forbidden_handler(e):\n        assert isinstance(e, Forbidden)\n        return \"bp-forbidden\"\n\n    @bp.route(\"/undefined\")\n    def bp_registered_test():\n        raise NotFound()\n\n    @bp.route(\"/forbidden\")\n    def bp_forbidden_test():\n        raise Forbidden()\n\n    app = flask.Flask(__name__)\n\n    @app.errorhandler(HTTPException)\n    def catchall_exception_handler(e):\n        assert isinstance(e, HTTPException)\n        assert isinstance(e, NotFound)\n        return \"default\"\n\n    @app.errorhandler(Forbidden)\n    def catchall_forbidden_handler(e):\n        assert isinstance(e, Forbidden)\n        return \"forbidden\"\n\n    @app.route(\"/forbidden\")\n    def forbidden():\n        raise Forbidden()\n\n    @app.route(\"/slash/\")\n    def slash():\n        return \"slash\"\n\n    app.register_blueprint(bp, url_prefix=\"/bp\")\n\n    c = app.test_client()\n    assert c.get(\"/bp/undefined\").data == b\"bp-default\"\n    assert c.get(\"/bp/forbidden\").data == b\"bp-forbidden\"\n    assert c.get(\"/undefined\").data == b\"default\"\n    assert c.get(\"/forbidden\").data == b\"forbidden\"\n    # Don't handle RequestRedirect raised when adding slash.\n    assert c.get(\"/slash\", follow_redirects=True).data == b\"slash\"",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_default_error_handler` in tests\\test_user_error_handler.py",
      "possible_syscalls": [],
      "confidence": 0.22,
      "evidence": [
        "function test_default_error_handler in tests\\test_user_error_handler.py",
        "matched template: handle a HTTP route request and return response (sim=0.26)"
      ]
    },
    {
      "name": "common_test",
      "description": "make an HTTP request to an external API. Function `common_test`.",
      "predicted_filename": "tests\\test_views.py",
      "predicted_code_snippet": "def common_test(app):\n    c = app.test_client()\n\n    assert c.get(\"/\").data == b\"GET\"\n    assert c.post(\"/\").data == b\"POST\"\n    assert c.put(\"/\").status_code == 405\n    meths = parse_set_header(c.open(\"/\", method=\"OPTIONS\").headers[\"Allow\"])\n    assert sorted(meths) == [\"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `common_test` in tests\\test_views.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.2,
      "evidence": [
        "function common_test in tests\\test_views.py",
        "matched template: make an HTTP request to an external API (sim=0.22)"
      ]
    },
    {
      "name": "test_basic_view",
      "description": "handle a HTTP route request and return response. Function `test_basic_view`.",
      "predicted_filename": "tests\\test_views.py",
      "predicted_code_snippet": "def test_basic_view(app):\n    class Index(flask.views.View):\n        methods = [\"GET\", \"POST\"]\n\n        def dispatch_request(self):\n            return flask.request.method\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n    common_test(app)",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_basic_view` in tests\\test_views.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.24,
      "evidence": [
        "function test_basic_view in tests\\test_views.py",
        "matched template: handle a HTTP route request and return response (sim=0.29)"
      ]
    },
    {
      "name": "test_method_based_view",
      "description": "handle a HTTP route request and return response. Function `test_method_based_view`.",
      "predicted_filename": "tests\\test_views.py",
      "predicted_code_snippet": "def test_method_based_view(app):\n    class Index(flask.views.MethodView):\n        def get(self):\n            return \"GET\"\n\n        def post(self):\n            return \"POST\"\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n\n    common_test(app)",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_method_based_view` in tests\\test_views.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.22,
      "evidence": [
        "function test_method_based_view in tests\\test_views.py",
        "matched template: handle a HTTP route request and return response (sim=0.25)"
      ]
    },
    {
      "name": "test_view_patching",
      "description": "handle a HTTP route request and return response. Function `test_view_patching`.",
      "predicted_filename": "tests\\test_views.py",
      "predicted_code_snippet": "def test_view_patching(app):\n    class Index(flask.views.MethodView):\n        def get(self):\n            raise ZeroDivisionError\n\n        def post(self):\n            raise ZeroDivisionError\n\n    class Other(Index):\n        def get(self):\n            return \"GET\"\n\n        def post(self):\n            return \"POST\"\n\n    view = Index.as_view(\"index\")\n    view.view_class = Other\n    app.add_url_rule(\"/\", view_func=view)\n    common_test(app)",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_view_patching` in tests\\test_views.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.2,
      "evidence": [
        "function test_view_patching in tests\\test_views.py",
        "matched template: handle a HTTP route request and return response (sim=0.22)"
      ]
    },
    {
      "name": "test_view_inheritance",
      "description": "handle a HTTP route request and return response. Function `test_view_inheritance`.",
      "predicted_filename": "tests\\test_views.py",
      "predicted_code_snippet": "def test_view_inheritance(app, client):\n    class Index(flask.views.MethodView):\n        def get(self):\n            return \"GET\"\n\n        def post(self):\n            return \"POST\"\n\n    class BetterIndex(Index):\n        def delete(self):\n            return \"DELETE\"\n\n    app.add_url_rule(\"/\", view_func=BetterIndex.as_view(\"index\"))\n\n    meths = parse_set_header(client.open(\"/\", method=\"OPTIONS\").headers[\"Allow\"])\n    assert sorted(meths) == [\"DELETE\", \"GET\", \"HEAD\", \"OPTIONS\", \"POST\"]",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_view_inheritance` in tests\\test_views.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.2,
      "evidence": [
        "function test_view_inheritance in tests\\test_views.py",
        "matched template: handle a HTTP route request and return response (sim=0.21)"
      ]
    },
    {
      "name": "test_view_decorators",
      "description": "handle a HTTP route request and return response. Function `test_view_decorators`.",
      "predicted_filename": "tests\\test_views.py",
      "predicted_code_snippet": "def test_view_decorators(app, client):\n    def add_x_parachute(f):\n        def new_function(*args, **kwargs):\n            resp = flask.make_response(f(*args, **kwargs))\n            resp.headers[\"X-Parachute\"] = \"awesome\"\n            return resp\n\n        return new_function\n\n    class Index(flask.views.View):\n        decorators = [add_x_parachute]\n\n        def dispatch_request(self):\n            return \"Awesome\"\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n    rv = client.get(\"/\")\n    assert rv.headers[\"X-Parachute\"] == \"awesome\"\n    assert rv.data == b\"Awesome\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_view_decorators` in tests\\test_views.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.24,
      "evidence": [
        "function test_view_decorators in tests\\test_views.py",
        "matched template: handle a HTTP route request and return response (sim=0.30)"
      ]
    },
    {
      "name": "test_view_provide_automatic_options_attr",
      "description": "handle a HTTP route request and return response. Function `test_view_provide_automatic_options_attr`.",
      "predicted_filename": "tests\\test_views.py",
      "predicted_code_snippet": "def test_view_provide_automatic_options_attr():\n    app = flask.Flask(__name__)\n\n    class Index1(flask.views.View):\n        provide_automatic_options = False\n\n        def dispatch_request(self):\n            return \"Hello World!\"\n\n    app.add_url_rule(\"/\", view_func=Index1.as_view(\"index\"))\n    c = app.test_client()\n    rv = c.open(\"/\", method=\"OPTIONS\")\n    assert rv.status_code == 405\n\n    app = flask.Flask(__name__)\n\n    class Index2(flask.views.View):\n        methods = [\"OPTIONS\"]\n        provide_automatic_options = True\n\n        def dispatch_request(self):\n            return \"Hello World!\"\n\n    app.add_url_rule(\"/\", view_func=Index2.as_view(\"index\"))\n    c = app.test_client()\n    rv = c.open(\"/\", method=\"OPTIONS\")\n    assert sorted(rv.allow) == [\"OPTIONS\"]\n\n    app = flask.Flask(__name__)\n\n    class Index3(flask.views.View):\n        def dispatch_request(self):\n            return \"Hello World!\"\n\n    app.add_url_rule(\"/\", view_func=Index3.as_view(\"index\"))\n    c = app.test_client()\n    rv = c.open(\"/\", method=\"OPTIONS\")\n    assert \"OPTIONS\" in rv.allow",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_view_provide_automatic_options_attr` in tests\\test_views.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.22,
      "evidence": [
        "function test_view_provide_automatic_options_attr in tests\\test_views.py",
        "matched template: handle a HTTP route request and return response (sim=0.25)"
      ]
    },
    {
      "name": "test_implicit_head",
      "description": "handle a HTTP route request and return response. Function `test_implicit_head`.",
      "predicted_filename": "tests\\test_views.py",
      "predicted_code_snippet": "def test_implicit_head(app, client):\n    class Index(flask.views.MethodView):\n        def get(self):\n            return flask.Response(\"Blub\", headers={\"X-Method\": flask.request.method})\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n    rv = client.get(\"/\")\n    assert rv.data == b\"Blub\"\n    assert rv.headers[\"X-Method\"] == \"GET\"\n    rv = client.head(\"/\")\n    assert rv.data == b\"\"\n    assert rv.headers[\"X-Method\"] == \"HEAD\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_implicit_head` in tests\\test_views.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.24,
      "evidence": [
        "function test_implicit_head in tests\\test_views.py",
        "matched template: handle a HTTP route request and return response (sim=0.30)"
      ]
    },
    {
      "name": "test_explicit_head",
      "description": "handle a HTTP route request and return response. Function `test_explicit_head`.",
      "predicted_filename": "tests\\test_views.py",
      "predicted_code_snippet": "def test_explicit_head(app, client):\n    class Index(flask.views.MethodView):\n        def get(self):\n            return \"GET\"\n\n        def head(self):\n            return flask.Response(\"\", headers={\"X-Method\": \"HEAD\"})\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n    rv = client.get(\"/\")\n    assert rv.data == b\"GET\"\n    rv = client.head(\"/\")\n    assert rv.data == b\"\"\n    assert rv.headers[\"X-Method\"] == \"HEAD\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_explicit_head` in tests\\test_views.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.24,
      "evidence": [
        "function test_explicit_head in tests\\test_views.py",
        "matched template: handle a HTTP route request and return response (sim=0.30)"
      ]
    },
    {
      "name": "test_endpoint_override",
      "description": "handle a HTTP route request and return response. Function `test_endpoint_override`.",
      "predicted_filename": "tests\\test_views.py",
      "predicted_code_snippet": "def test_endpoint_override(app):\n    app.debug = True\n\n    class Index(flask.views.View):\n        methods = [\"GET\", \"POST\"]\n\n        def dispatch_request(self):\n            return flask.request.method\n\n    app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n\n    with pytest.raises(AssertionError):\n        app.add_url_rule(\"/\", view_func=Index.as_view(\"index\"))\n\n    # But these tests should still pass. We just log a warning.\n    common_test(app)",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_endpoint_override` in tests\\test_views.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.23,
      "evidence": [
        "function test_endpoint_override in tests\\test_views.py",
        "matched template: handle a HTTP route request and return response (sim=0.28)"
      ]
    },
    {
      "name": "test_methods_var_inheritance",
      "description": "handle a HTTP route request and return response. Function `test_methods_var_inheritance`.",
      "predicted_filename": "tests\\test_views.py",
      "predicted_code_snippet": "def test_methods_var_inheritance(app, client):\n    class BaseView(flask.views.MethodView):\n        methods = [\"GET\", \"PROPFIND\"]\n\n    class ChildView(BaseView):\n        def get(self):\n            return \"GET\"\n\n        def propfind(self):\n            return \"PROPFIND\"\n\n    app.add_url_rule(\"/\", view_func=ChildView.as_view(\"index\"))\n\n    assert client.get(\"/\").data == b\"GET\"\n    assert client.open(\"/\", method=\"PROPFIND\").data == b\"PROPFIND\"\n    assert ChildView.methods == {\"PROPFIND\", \"GET\"}",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_methods_var_inheritance` in tests\\test_views.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.21,
      "evidence": [
        "function test_methods_var_inheritance in tests\\test_views.py",
        "matched template: handle a HTTP route request and return response (sim=0.22)"
      ]
    },
    {
      "name": "test_multiple_inheritance",
      "description": "handle a HTTP route request and return response. Function `test_multiple_inheritance`.",
      "predicted_filename": "tests\\test_views.py",
      "predicted_code_snippet": "def test_multiple_inheritance(app, client):\n    class GetView(flask.views.MethodView):\n        def get(self):\n            return \"GET\"\n\n    class DeleteView(flask.views.MethodView):\n        def delete(self):\n            return \"DELETE\"\n\n    class GetDeleteView(GetView, DeleteView):\n        pass\n\n    app.add_url_rule(\"/\", view_func=GetDeleteView.as_view(\"index\"))\n\n    assert client.get(\"/\").data == b\"GET\"\n    assert client.delete(\"/\").data == b\"DELETE\"\n    assert sorted(GetDeleteView.methods) == [\"DELETE\", \"GET\"]",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_multiple_inheritance` in tests\\test_views.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.2,
      "evidence": [
        "function test_multiple_inheritance in tests\\test_views.py",
        "matched template: handle a HTTP route request and return response (sim=0.20)"
      ]
    },
    {
      "name": "test_remove_method_from_parent",
      "description": "handle a HTTP route request and return response. Function `test_remove_method_from_parent`.",
      "predicted_filename": "tests\\test_views.py",
      "predicted_code_snippet": "def test_remove_method_from_parent(app, client):\n    class GetView(flask.views.MethodView):\n        def get(self):\n            return \"GET\"\n\n    class OtherView(flask.views.MethodView):\n        def post(self):\n            return \"POST\"\n\n    class View(GetView, OtherView):\n        methods = [\"GET\"]\n\n    app.add_url_rule(\"/\", view_func=View.as_view(\"index\"))\n\n    assert client.get(\"/\").data == b\"GET\"\n    assert client.post(\"/\").status_code == 405\n    assert sorted(View.methods) == [\"GET\"]",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_remove_method_from_parent` in tests\\test_views.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.22,
      "evidence": [
        "function test_remove_method_from_parent in tests\\test_views.py",
        "matched template: handle a HTTP route request and return response (sim=0.25)"
      ]
    },
    {
      "name": "test_init_once",
      "description": "handle a HTTP route request and return response. Function `test_init_once`.",
      "predicted_filename": "tests\\test_views.py",
      "predicted_code_snippet": "def test_init_once(app, client):\n    n = 0\n\n    class CountInit(flask.views.View):\n        init_every_request = False\n\n        def __init__(self):\n            nonlocal n\n            n += 1\n\n        def dispatch_request(self):\n            return str(n)\n\n    app.add_url_rule(\"/\", view_func=CountInit.as_view(\"index\"))\n    assert client.get(\"/\").data == b\"1\"\n    assert client.get(\"/\").data == b\"1\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "app": {
            "type": "string",
            "required": true
          },
          "client": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "app",
          "client"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "app": "string",
          "client": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `test_init_once` in tests\\test_views.py",
      "possible_syscalls": [
        {
          "syscall": "open/read/write",
          "reason": "file open calls found"
        }
      ],
      "confidence": 0.24,
      "evidence": [
        "function test_init_once in tests\\test_views.py",
        "matched template: handle a HTTP route request and return response (sim=0.29)"
      ]
    },
    {
      "name": "index",
      "description": "handle a HTTP route request and return response. Function `index`.",
      "predicted_filename": "tests\\test_apps\\blueprintapp\\apps\\admin\\__init__.py",
      "predicted_code_snippet": "def index():\n    return render_template(\"admin/index.html\")",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `index` in tests\\test_apps\\blueprintapp\\apps\\admin\\__init__.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function index in tests\\test_apps\\blueprintapp\\apps\\admin\\__init__.py",
        "matched template: handle a HTTP route request and return response (sim=0.21)"
      ]
    },
    {
      "name": "index2",
      "description": "handle a HTTP route request and return response. Function `index2`.",
      "predicted_filename": "tests\\test_apps\\blueprintapp\\apps\\admin\\__init__.py",
      "predicted_code_snippet": "def index2():\n    return render_template(\"./admin/index.html\")",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `index2` in tests\\test_apps\\blueprintapp\\apps\\admin\\__init__.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function index2 in tests\\test_apps\\blueprintapp\\apps\\admin\\__init__.py",
        "matched template: handle a HTTP route request and return response (sim=0.21)"
      ]
    },
    {
      "name": "index",
      "description": "handle a HTTP route request and return response. Function `index`.",
      "predicted_filename": "tests\\test_apps\\blueprintapp\\apps\\frontend\\__init__.py",
      "predicted_code_snippet": "def index():\n    return render_template(\"frontend/index.html\")",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `index` in tests\\test_apps\\blueprintapp\\apps\\frontend\\__init__.py",
      "possible_syscalls": [],
      "confidence": 0.21,
      "evidence": [
        "function index in tests\\test_apps\\blueprintapp\\apps\\frontend\\__init__.py",
        "matched template: handle a HTTP route request and return response (sim=0.24)"
      ]
    },
    {
      "name": "missing_template",
      "description": "handle a HTTP route request and return response. Function `missing_template`.",
      "predicted_filename": "tests\\test_apps\\blueprintapp\\apps\\frontend\\__init__.py",
      "predicted_code_snippet": "def missing_template():\n    return render_template(\"missing_template.html\")",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `missing_template` in tests\\test_apps\\blueprintapp\\apps\\frontend\\__init__.py",
      "possible_syscalls": [],
      "confidence": 0.2,
      "evidence": [
        "function missing_template in tests\\test_apps\\blueprintapp\\apps\\frontend\\__init__.py",
        "matched template: handle a HTTP route request and return response (sim=0.22)"
      ]
    },
    {
      "name": "create_app",
      "description": "make an HTTP request to an external API. Function `create_app`.",
      "predicted_filename": "tests\\test_apps\\cliapp\\factory.py",
      "predicted_code_snippet": "def create_app():\n    return Flask(\"app\")",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `create_app` in tests\\test_apps\\cliapp\\factory.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function create_app in tests\\test_apps\\cliapp\\factory.py",
        "matched template: make an HTTP request to an external API (sim=0.15)"
      ]
    },
    {
      "name": "create_app2",
      "description": "make an HTTP request to an external API. Function `create_app2`.",
      "predicted_filename": "tests\\test_apps\\cliapp\\factory.py",
      "predicted_code_snippet": "def create_app2(foo, bar):\n    return Flask(\"_\".join([\"app2\", foo, bar]))",
      "input_schema": {
        "type": "object",
        "properties": {
          "foo": {
            "type": "string",
            "required": true
          },
          "bar": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "foo",
          "bar"
        ]
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {
          "foo": "string",
          "bar": "string"
        },
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `create_app2` in tests\\test_apps\\cliapp\\factory.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function create_app2 in tests\\test_apps\\cliapp\\factory.py",
        "matched template: make an HTTP request to an external API (sim=0.14)"
      ]
    },
    {
      "name": "no_app",
      "description": "make an HTTP request to an external API. Function `no_app`.",
      "predicted_filename": "tests\\test_apps\\cliapp\\factory.py",
      "predicted_code_snippet": "def no_app():\n    pass",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `no_app` in tests\\test_apps\\cliapp\\factory.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function no_app in tests\\test_apps\\cliapp\\factory.py",
        "matched template: make an HTTP request to an external API (sim=0.17)"
      ]
    },
    {
      "name": "hello",
      "description": "handle a HTTP route request and return response. Function `hello`.",
      "predicted_filename": "tests\\test_apps\\helloworld\\hello.py",
      "predicted_code_snippet": "def hello():\n    return \"Hello World!\"",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "object"
        }
      },
      "explanation": "Detected Python function `hello` in tests\\test_apps\\helloworld\\hello.py",
      "possible_syscalls": [],
      "confidence": 0.29,
      "evidence": [
        "function hello in tests\\test_apps\\helloworld\\hello.py",
        "matched template: handle a HTTP route request and return response (sim=0.37)"
      ]
    },
    {
      "name": "after_sync",
      "description": "handle a HTTP route request and return response. Function `after_sync`.",
      "predicted_filename": "tests\\type_check\\typing_app_decorators.py",
      "predicted_code_snippet": "def after_sync(response: Response) -> Response:\n    return Response()",
      "input_schema": {
        "type": "object",
        "properties": {
          "response": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "response"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "response": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `after_sync` in tests\\type_check\\typing_app_decorators.py",
      "possible_syscalls": [],
      "confidence": 0.19,
      "evidence": [
        "function after_sync in tests\\type_check\\typing_app_decorators.py",
        "matched template: handle a HTTP route request and return response (sim=0.18)"
      ]
    },
    {
      "name": "before_sync",
      "description": "stream data over websocket. Function `before_sync`.",
      "predicted_filename": "tests\\type_check\\typing_app_decorators.py",
      "predicted_code_snippet": "def before_sync() -> None: ...",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `before_sync` in tests\\type_check\\typing_app_decorators.py",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "function before_sync in tests\\type_check\\typing_app_decorators.py",
        "matched template: stream data over websocket (sim=0.15)"
      ]
    },
    {
      "name": "teardown_sync",
      "description": "stream data over websocket. Function `teardown_sync`.",
      "predicted_filename": "tests\\type_check\\typing_app_decorators.py",
      "predicted_code_snippet": "def teardown_sync(exc: BaseException | None) -> None: ...",
      "input_schema": {
        "type": "object",
        "properties": {
          "exc": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "exc"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "exc": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `teardown_sync` in tests\\type_check\\typing_app_decorators.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "function teardown_sync in tests\\type_check\\typing_app_decorators.py",
        "matched template: stream data over websocket (sim=0.14)"
      ]
    },
    {
      "name": "handle_400",
      "description": "handle a HTTP route request and return response. Function `handle_400`.",
      "predicted_filename": "tests\\type_check\\typing_error_handler.py",
      "predicted_code_snippet": "def handle_400(e: BadRequest) -> str:\n    return \"\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "e": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "e"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "e": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `handle_400` in tests\\type_check\\typing_error_handler.py",
      "possible_syscalls": [],
      "confidence": 0.29,
      "evidence": [
        "function handle_400 in tests\\type_check\\typing_error_handler.py",
        "matched template: handle a HTTP route request and return response (sim=0.37)"
      ]
    },
    {
      "name": "handle_custom",
      "description": "handle a HTTP route request and return response. Function `handle_custom`.",
      "predicted_filename": "tests\\type_check\\typing_error_handler.py",
      "predicted_code_snippet": "def handle_custom(e: ValueError) -> str:\n    return \"\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "e": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "e"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "e": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `handle_custom` in tests\\type_check\\typing_error_handler.py",
      "possible_syscalls": [],
      "confidence": 0.28,
      "evidence": [
        "function handle_custom in tests\\type_check\\typing_error_handler.py",
        "matched template: handle a HTTP route request and return response (sim=0.35)"
      ]
    },
    {
      "name": "handle_accept_base",
      "description": "handle a HTTP route request and return response. Function `handle_accept_base`.",
      "predicted_filename": "tests\\type_check\\typing_error_handler.py",
      "predicted_code_snippet": "def handle_accept_base(e: Exception) -> str:\n    return \"\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "e": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "e"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "e": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `handle_accept_base` in tests\\type_check\\typing_error_handler.py",
      "possible_syscalls": [],
      "confidence": 0.29,
      "evidence": [
        "function handle_accept_base in tests\\type_check\\typing_error_handler.py",
        "matched template: handle a HTTP route request and return response (sim=0.37)"
      ]
    },
    {
      "name": "handle_multiple",
      "description": "handle a HTTP route request and return response. Function `handle_multiple`.",
      "predicted_filename": "tests\\type_check\\typing_error_handler.py",
      "predicted_code_snippet": "def handle_multiple(e: BadRequest | NotFound) -> str:\n    return \"\"",
      "input_schema": {
        "type": "object",
        "properties": {
          "e": {
            "type": "string",
            "required": true
          }
        },
        "required": [
          "e"
        ]
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "e": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `handle_multiple` in tests\\type_check\\typing_error_handler.py",
      "possible_syscalls": [],
      "confidence": 0.28,
      "evidence": [
        "function handle_multiple in tests\\type_check\\typing_error_handler.py",
        "matched template: handle a HTTP route request and return response (sim=0.36)"
      ]
    },
    {
      "name": "hello_str",
      "description": "handle a HTTP route request and return response. Function `hello_str`.",
      "predicted_filename": "tests\\type_check\\typing_route.py",
      "predicted_code_snippet": "def hello_str() -> str:\n    return \"<p>Hello, World!</p>\"",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `hello_str` in tests\\type_check\\typing_route.py",
      "possible_syscalls": [],
      "confidence": 0.26,
      "evidence": [
        "function hello_str in tests\\type_check\\typing_route.py",
        "matched template: handle a HTTP route request and return response (sim=0.32)"
      ]
    },
    {
      "name": "hello_bytes",
      "description": "stream data over websocket. Function `hello_bytes`.",
      "predicted_filename": "tests\\type_check\\typing_route.py",
      "predicted_code_snippet": "def hello_bytes() -> bytes:\n    return b\"<p>Hello, World!</p>\"",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `hello_bytes` in tests\\type_check\\typing_route.py",
      "possible_syscalls": [],
      "confidence": 0.27,
      "evidence": [
        "function hello_bytes in tests\\type_check\\typing_route.py",
        "matched template: stream data over websocket (sim=0.35)"
      ]
    },
    {
      "name": "hello_json",
      "description": "serialize object to JSON. Function `hello_json`.",
      "predicted_filename": "tests\\type_check\\typing_route.py",
      "predicted_code_snippet": "def hello_json() -> Response:\n    return jsonify(\"Hello, World!\")",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `hello_json` in tests\\type_check\\typing_route.py",
      "possible_syscalls": [],
      "confidence": 0.28,
      "evidence": [
        "function hello_json in tests\\type_check\\typing_route.py",
        "matched template: serialize object to JSON (sim=0.36)"
      ]
    },
    {
      "name": "hello_json_dict",
      "description": "serialize object to JSON. Function `hello_json_dict`.",
      "predicted_filename": "tests\\type_check\\typing_route.py",
      "predicted_code_snippet": "def hello_json_dict() -> dict[str, t.Any]:\n    return {\"response\": \"Hello, World!\"}",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `hello_json_dict` in tests\\type_check\\typing_route.py",
      "possible_syscalls": [],
      "confidence": 0.28,
      "evidence": [
        "function hello_json_dict in tests\\type_check\\typing_route.py",
        "matched template: serialize object to JSON (sim=0.36)"
      ]
    },
    {
      "name": "hello_json_list",
      "description": "serialize object to JSON. Function `hello_json_list`.",
      "predicted_filename": "tests\\type_check\\typing_route.py",
      "predicted_code_snippet": "def hello_json_list() -> list[t.Any]:\n    return [{\"message\": \"Hello\"}, {\"message\": \"World\"}]",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "array"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "array"
        }
      },
      "explanation": "Detected Python function `hello_json_list` in tests\\type_check\\typing_route.py",
      "possible_syscalls": [],
      "confidence": 0.28,
      "evidence": [
        "function hello_json_list in tests\\type_check\\typing_route.py",
        "matched template: serialize object to JSON (sim=0.36)"
      ]
    },
    {
      "name": "typed_dict",
      "description": "parse JSON input and validate fields. Function `typed_dict`.",
      "predicted_filename": "tests\\type_check\\typing_route.py",
      "predicted_code_snippet": "def typed_dict() -> StatusJSON:\n    return {\"status\": \"ok\"}",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `typed_dict` in tests\\type_check\\typing_route.py",
      "possible_syscalls": [],
      "confidence": 0.27,
      "evidence": [
        "function typed_dict in tests\\type_check\\typing_route.py",
        "matched template: parse JSON input and validate fields (sim=0.34)"
      ]
    },
    {
      "name": "hello_generator",
      "description": "stream data over websocket. Function `hello_generator`.",
      "predicted_filename": "tests\\type_check\\typing_route.py",
      "predicted_code_snippet": "def hello_generator() -> t.Generator[str, None, None]:\n    def show() -> t.Generator[str, None, None]:\n        for x in range(100):\n            yield f\"data:{x}\\n\\n\"\n\n    return show()",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `hello_generator` in tests\\type_check\\typing_route.py",
      "possible_syscalls": [],
      "confidence": 0.25,
      "evidence": [
        "function hello_generator in tests\\type_check\\typing_route.py",
        "matched template: stream data over websocket (sim=0.31)"
      ]
    },
    {
      "name": "hello_generator_expression",
      "description": "stream data over websocket. Function `hello_generator_expression`.",
      "predicted_filename": "tests\\type_check\\typing_route.py",
      "predicted_code_snippet": "def hello_generator_expression() -> t.Iterator[bytes]:\n    return (f\"data:{x}\\n\\n\".encode() for x in range(100))",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `hello_generator_expression` in tests\\type_check\\typing_route.py",
      "possible_syscalls": [],
      "confidence": 0.25,
      "evidence": [
        "function hello_generator_expression in tests\\type_check\\typing_route.py",
        "matched template: stream data over websocket (sim=0.31)"
      ]
    },
    {
      "name": "hello_iterator",
      "description": "stream data over websocket. Function `hello_iterator`.",
      "predicted_filename": "tests\\type_check\\typing_route.py",
      "predicted_code_snippet": "def hello_iterator() -> t.Iterator[str]:\n    return iter([f\"data:{x}\\n\\n\" for x in range(100)])",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `hello_iterator` in tests\\type_check\\typing_route.py",
      "possible_syscalls": [],
      "confidence": 0.26,
      "evidence": [
        "function hello_iterator in tests\\type_check\\typing_route.py",
        "matched template: stream data over websocket (sim=0.32)"
      ]
    },
    {
      "name": "tuple_status",
      "description": "handle a HTTP route request and return response. Function `tuple_status`.",
      "predicted_filename": "tests\\type_check\\typing_route.py",
      "predicted_code_snippet": "def tuple_status(code: int = 200) -> tuple[str, int]:\n    return \"hello\", code",
      "input_schema": {
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "required": false
          }
        },
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "code": "integer"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `tuple_status` in tests\\type_check\\typing_route.py",
      "possible_syscalls": [],
      "confidence": 0.25,
      "evidence": [
        "function tuple_status in tests\\type_check\\typing_route.py",
        "matched template: handle a HTTP route request and return response (sim=0.30)"
      ]
    },
    {
      "name": "tuple_status_enum",
      "description": "stream data over websocket. Function `tuple_status_enum`.",
      "predicted_filename": "tests\\type_check\\typing_route.py",
      "predicted_code_snippet": "def tuple_status_enum() -> tuple[str, int]:\n    return \"hello\", HTTPStatus.OK",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `tuple_status_enum` in tests\\type_check\\typing_route.py",
      "possible_syscalls": [],
      "confidence": 0.24,
      "evidence": [
        "function tuple_status_enum in tests\\type_check\\typing_route.py",
        "matched template: stream data over websocket (sim=0.29)"
      ]
    },
    {
      "name": "tuple_headers",
      "description": "handle a HTTP route request and return response. Function `tuple_headers`.",
      "predicted_filename": "tests\\type_check\\typing_route.py",
      "predicted_code_snippet": "def tuple_headers() -> tuple[str, dict[str, str]]:\n    return \"Hello, World!\", {\"Content-Type\": \"text/plain\"}",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `tuple_headers` in tests\\type_check\\typing_route.py",
      "possible_syscalls": [],
      "confidence": 0.24,
      "evidence": [
        "function tuple_headers in tests\\type_check\\typing_route.py",
        "matched template: handle a HTTP route request and return response (sim=0.28)"
      ]
    },
    {
      "name": "return_template",
      "description": "handle a HTTP route request and return response. Function `return_template`.",
      "predicted_filename": "tests\\type_check\\typing_route.py",
      "predicted_code_snippet": "def return_template(name: str | None = None) -> str:\n    return render_template(\"index.html\", name=name)",
      "input_schema": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "required": false
          }
        },
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {
          "name": "string"
        },
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `return_template` in tests\\type_check\\typing_route.py",
      "possible_syscalls": [],
      "confidence": 0.27,
      "evidence": [
        "function return_template in tests\\type_check\\typing_route.py",
        "matched template: handle a HTTP route request and return response (sim=0.34)"
      ]
    },
    {
      "name": "return_template_stream",
      "description": "stream data over websocket. Function `return_template_stream`.",
      "predicted_filename": "tests\\type_check\\typing_route.py",
      "predicted_code_snippet": "def return_template_stream() -> t.Iterator[str]:\n    return stream_template(\"index.html\", name=\"Hello\")",
      "input_schema": {
        "type": "object",
        "properties": {},
        "required": []
      },
      "output_schema": {
        "type": "string"
      },
      "payload_shape": {
        "request": {},
        "response": {
          "type": "string"
        }
      },
      "explanation": "Detected Python function `return_template_stream` in tests\\type_check\\typing_route.py",
      "possible_syscalls": [],
      "confidence": 0.29,
      "evidence": [
        "function return_template_stream in tests\\type_check\\typing_route.py",
        "matched template: stream data over websocket (sim=0.38)"
      ]
    },
    {
      "name": "cli",
      "description": "execute a shell command. File `docs\\cli.rst`.",
      "predicted_filename": "docs\\cli.rst",
      "predicted_code_snippet": ".. currentmodule:: flask\n\nCommand Line Interface\n======================\n\nInstalling Flask installs the ``flask`` script, a `Click`_ command line\ninterface, in your virtualenv. Executed from the terminal, this script gives\naccess to built-in, extension, and application-defined commands. The ``--help``\noption will give more information about any commands and options.\n\n.. _Click: https://click.palletsprojects.com/\n\n\nApplication Discovery\n---------------------\n\nThe ``flask`` command is installed by Flask, not your application; it must be\ntold where to find your application in order to use it. The ``--app``\noption is used to specify how to load the application.\n\nWhile ``--app`` supports a variety of options for specifying your\napplication, most use cases should be simple. Here are the typical values:\n\n(nothing)\n    The name \"app\" or \"wsgi\" is imported (as a \".py\" file, or package),\n    automatically detecting an app (``app`` or ``application``) or\n    factory (``create_app`` or ``make_app``).\n\n``--app hello``\n    The given name is imported, automatically detecting an app (``app``",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file docs\\cli.rst",
      "possible_syscalls": [],
      "confidence": 0.18,
      "evidence": [
        "file docs\\cli.rst exists under tools/"
      ]
    },
    {
      "name": "app",
      "description": "write data to a file. File `tests\\test_apps\\cliapp\\app.py`.",
      "predicted_filename": "tests\\test_apps\\cliapp\\app.py",
      "predicted_code_snippet": "from flask import Flask\n\ntestapp = Flask(\"testapp\")",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file tests\\test_apps\\cliapp\\app.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "file tests\\test_apps\\cliapp\\app.py exists under tools/"
      ]
    },
    {
      "name": "importerrorapp",
      "description": "make an HTTP request to an external API. File `tests\\test_apps\\cliapp\\importerrorapp.py`.",
      "predicted_filename": "tests\\test_apps\\cliapp\\importerrorapp.py",
      "predicted_code_snippet": "from flask import Flask\n\nraise ImportError()\n\ntestapp = Flask(\"testapp\")",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file tests\\test_apps\\cliapp\\importerrorapp.py",
      "possible_syscalls": [],
      "confidence": 0.16,
      "evidence": [
        "file tests\\test_apps\\cliapp\\importerrorapp.py exists under tools/"
      ]
    },
    {
      "name": "message",
      "description": "send an email notification. File `tests\\test_apps\\cliapp\\message.txt`.",
      "predicted_filename": "tests\\test_apps\\cliapp\\message.txt",
      "predicted_code_snippet": "So long, and thanks for all the fish.",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file tests\\test_apps\\cliapp\\message.txt",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "file tests\\test_apps\\cliapp\\message.txt exists under tools/"
      ]
    },
    {
      "name": "multiapp",
      "description": "make an HTTP request to an external API. File `tests\\test_apps\\cliapp\\multiapp.py`.",
      "predicted_filename": "tests\\test_apps\\cliapp\\multiapp.py",
      "predicted_code_snippet": "from flask import Flask\n\napp1 = Flask(\"app1\")\napp2 = Flask(\"app2\")",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file tests\\test_apps\\cliapp\\multiapp.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "file tests\\test_apps\\cliapp\\multiapp.py exists under tools/"
      ]
    },
    {
      "name": "__init__",
      "description": "send an email notification. File `tests\\test_apps\\cliapp\\__init__.py`.",
      "predicted_filename": "tests\\test_apps\\cliapp\\__init__.py",
      "predicted_code_snippet": "",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file tests\\test_apps\\cliapp\\__init__.py",
      "possible_syscalls": [],
      "confidence": 0.16,
      "evidence": [
        "file tests\\test_apps\\cliapp\\__init__.py exists under tools/"
      ]
    },
    {
      "name": "__init__",
      "description": "write data to a file. File `tests\\test_apps\\cliapp\\inner1\\__init__.py`.",
      "predicted_filename": "tests\\test_apps\\cliapp\\inner1\\__init__.py",
      "predicted_code_snippet": "from flask import Flask\n\napplication = Flask(__name__)",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file tests\\test_apps\\cliapp\\inner1\\__init__.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "file tests\\test_apps\\cliapp\\inner1\\__init__.py exists under tools/"
      ]
    },
    {
      "name": "flask",
      "description": "write data to a file. File `tests\\test_apps\\cliapp\\inner1\\inner2\\flask.py`.",
      "predicted_filename": "tests\\test_apps\\cliapp\\inner1\\inner2\\flask.py",
      "predicted_code_snippet": "from flask import Flask\n\napp = Flask(__name__)",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file tests\\test_apps\\cliapp\\inner1\\inner2\\flask.py",
      "possible_syscalls": [],
      "confidence": 0.17,
      "evidence": [
        "file tests\\test_apps\\cliapp\\inner1\\inner2\\flask.py exists under tools/"
      ]
    },
    {
      "name": "__init__",
      "description": "send an email notification. File `tests\\test_apps\\cliapp\\inner1\\inner2\\__init__.py`.",
      "predicted_filename": "tests\\test_apps\\cliapp\\inner1\\inner2\\__init__.py",
      "predicted_code_snippet": "",
      "input_schema": {
        "type": "object"
      },
      "output_schema": {
        "type": "object"
      },
      "payload_shape": {
        "request": {},
        "response": {}
      },
      "explanation": "Inferred tool from tools-like file tests\\test_apps\\cliapp\\inner1\\inner2\\__init__.py",
      "possible_syscalls": [],
      "confidence": 0.16,
      "evidence": [
        "file tests\\test_apps\\cliapp\\inner1\\inner2\\__init__.py exists under tools/"
      ]
    }
  ],
  "run_template": {
    "cmd": null,
    "confidence": 0.0,
    "evidence": []
  },
  "notes": [
    "Analyzed via MCP server."
  ]
}